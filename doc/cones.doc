@comment -*-texinfo-*-
@comment this file contains the cone/fan definitions

@c -------------------------------------------------------------------
@node cone, fan, User defined types, Data types
@section cone
@cindex cone

In the finite dimensional real vector space R^n, a convex rational polyhedral 
cone (in short ``cone'') is the convex set generated by finitely many half-lines 
generated by rational, and hence integer respectively, points. It may or may not 
contain a subspace of R^n (e.g. entire lines). The biggest subspace contained in 
a cone is called ``lineality space''. Modulo its lineality space, each cone is 
generated by a distinct minimal set of half lines, which are referred to as 
``rays''. Moreover, a cone can be represented as a set of points satisfying 
certain homogeneous linear inequalities and equalities. And these two 
characterizations of cones are the two main ways of defining non-trivial cones in 
Singular (see coneViaRays, coneViaNormals).

@smallexample
  cone c;                             // ambient dim 0, no equations,
                                      // no inequalities
  cone c = 17;                        // ambient dim 17, no equations,
                                      // no inequalities
@end smallexample

@menu
* coneViaRays::
* coneViaNormals::
* cone related functions::
@end menu
@c --------------------------------------------------------------------------------
@node coneViaRays,coneViaNormals,,cone
@subsection coneViaRays
@cindex coneViaRays
@table @code
@item @strong{Syntax:}
@code{coneViaRays(} intmat HL @code{)}
@*@code{coneViaRays(} intmat HL, intmat L @code{)}
@*@code{coneViaRays(} intmat HL, intmat L, int flags @code{)}
@item @strong{Type:}
cone
@item @strong{Purpose:}
cone generated by half lines generated by the row vectors of HL
and (if stated) by lines generated by the row vectors of L;
flags may range between 0,..,3 defining an upper and lower bit
(0=0*2+0, 1=0*2+1, 2=1*2+0, 3=1*2+1),
if upper bit is 1, then program assumes that each row vector in HL
generates a ray of the cone, 
if lower bit is 1, then program assumes that the span of the row
vectors of L is the lineality space of the cone,
if either bit is 0, then program computes the information itself.
@item @strong{Example:}
@smallexample
@c example
// Let's define a cone in R^3 generated by the following half lines:
intmat HL[5][3]= 
 1,0, 0,
-1,0, 0,
 0,1, 1,
 0,1,-1,
 0,0, 1;
cone c=coneViaRays(HL);
c;
// Note that (1,0,0) and (-1,0,0) form a line, hence also possible:
intmat HL[3][3]= 
0,1, 1,
0,1,-1,
0,0, 1;
intmat L[1][3]=
1,0,0;
cone c=coneViaRays(HL,L);
c;
// lineality space is exactly Lin(1,0,0)
intmat HL[3][3]= 
0,1, 1,
0,1,-1,
0,0, 1;
intmat L[1][3]=
1,0,0;
cone c=coneViaRays(HL,L,1);
c;
// and that (0,1,-1), (0,1,1) generate rays
intmat HL[3][3]= 
0,1, 1,
0,1,-1;
intmat L[1][3]=
1,0,0;
cone c=coneViaRays(HL,L,3);
c;
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------------------
@node coneViaNormals,cone related functions,coneViaRays,cone
@subsection coneViaNormals
@cindex coneViaNormals
@table @code
@item @strong{Syntax:}
@code{coneViaNormals(} intmat IE @code{)}
@*@code{coneViaNormals(} intmat IE, intmat E @code{)}
@*@code{coneViaNormals(} intmat IE, intmat E, int flags @code{)}
@item @strong{Type:}
cone
@item @strong{Purpose:}
cone consisting of all points x, such that IE*x >= 0 in each component
and (if stated) E*x = 0;
inequalities and (if stated) equations will be transformed, getting rid of
redundancies;
flags may range between 0,..,3 defining an upper and lower bit
(0=0*2+0, 1=0*2+1, 2=1*2+0, 3=1*2+1),
if higher bit is 1, then program assumes each inequality yields a facet,
if lower bit is 1, then program assumes the kernel of E is the span of the cone,
if either bit is 0, then program computes the information itself. 
@item @strong{Example:}
@smallexample
@c example
// Let's define a cone in R^3 given by the following inequalities:
intmat IE[6][3]=  
1,3,5,
1,5,3,
0,1,-1,
0,1,1,
1,0,0,
-1,0,0;
cone c=coneViaNormals(IE);
c;
// Note that the last two inequalities yield x1 = 0, hence also possible:
intmat IE[4][3]=  
0,1,-1,
0,1,1;
intmat E[1][3]=  
1,0,0;
cone c=coneViaNormals(IE,E);
c;
// each inequalities gives rise to a facet
intmat IE[4][3]=  
0,1,-1,
0,1,1;
intmat E[1][3]=  
1,0,0;
cone c=coneViaNormals(IE,E,1);
c;
// and the kernel of E is the span of the cone
intmat IE[4][3]=  
0,1,-1,
0,1,1;
intmat E[1][3]=  
1,0,0;
cone c=coneViaNormals(IE,E,3);
c;
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------------------
@node coneViaNormals,cone related functions,coneViaRays,cone
@subsection coneViaNormals
@cindex coneViaNormals
@table @code
@item @strong{Syntax:}
@code{coneViaNormals(} intmat IE @code{)}
@*@code{coneViaNormals(} intmat IE, intmat E @code{)}
@*@code{coneViaNormals(} intmat IE, intmat E, int flags @code{)}
@item @strong{Type:}
cone
@item @strong{Purpose:}
cone consisting of all points x, such that IE*x >= 0 in each component
and (if stated) E*x = 0;
inequalities and (if stated) equations will be transformed, getting rid of
redundancies;
flags may range between 0,..,3 defining an upper and lower bit
(0=0*2+0, 1=0*2+1, 2=1*2+0, 3=1*2+1),
if higher bit is 1, then program assumes each inequality yields a facet,
if lower bit is 1, then program assumes the kernel of E is the span of the cone,
if either bit is 0, then program computes the information itself. 
@item @strong{Example:}
@smallexample
@c example
// Let's define a cone in R^3 given by the following inequalities:
intmat IE[6][3]=  
1,3,5,
1,5,3,
0,1,-1,
0,1,1,
1,0,0,
-1,0,0;
cone c=coneViaNormals(IE);
c;
// Note that the last two inequalities yield x1 = 0, hence also possible:
intmat IE[4][3]=  
0,1,-1,
0,1,1;
intmat E[1][3]=  
1,0,0;
cone c=coneViaNormals(IE,E);
c;
// each inequalities gives rise to a facet
intmat IE[4][3]=  
0,1,-1,
0,1,1;
intmat E[1][3]=  
1,0,0;
cone c=coneViaNormals(IE,E,1);
c;
// and the kernel of E is the span of the cone
intmat IE[4][3]=  
0,1,-1,
0,1,1;
intmat E[1][3]=  
1,0,0;
cone c=coneViaNormals(IE,E,3);
c;
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------------------
@node quickConeViaNormals,cone related functions,coneViaNormals,cone
@subsection quickConeViaNormals
@cindex coneViaNormals
@table @code
@item @strong{Syntax:}
@code{quickConeViaNormals(} intmat IE @code{)}
@*@code{quickConeViaNormals(} intmat IE, intmat E @code{)}
@*@code{quickConeViaNormals(} intmat IE, intmat E, int flags @code{)}
@item @strong{Type:}
cone
@item @strong{Purpose:}
cone consisting of all points x, such that IE*x >= 0 in each component
and (if stated) E*x = 0;
inequalities and (if stated) equations will be not be transformed, 
only getting rid of obvious redundancies;
flags may range between 0,..,3 defining an upper and lower bit
(0=0*2+0, 1=0*2+1, 2=1*2+0, 3=1*2+1),
if higher bit is 1, then program assumes each inequality yields a facet,
if lower bit is 1, then program assumes the kernel of E is the span of the cone,
if either bit is 0, then program computes the information itself. 
@item @strong{Example:}
@smallexample
@c example
intmat M[11][3]=
0,-1,1,
-1,1,0,
-1,0,1,
-1,-1,2,
-2,2,0,
-2,1,1,
-2,0,2,
-2,-1,3,
-3,2,1,
-3,1,2,
-3,0,3;
cone c=quickConeViaNormals(M);
c;
cone d=coneViaNormals(M);
d;
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------------------
@node cone related functions,,quickConeViaNormals,cone
@subsection cone related functions
@cindex cone related functions

@menu
* canonicalizeCone::
* coneLink::
* containsInSupport::
* containsPositiveVector::
* containsRelatively::
* getAmbientDimension::
* getCodimension::
* getDimension::
* getDualCone::
* getEquations::
* getFacetNormals::
* getGeneratorsOfLinealitySpace::
* getGeneratorsOfSpan::
* getImpliedEquations::
* getInequalities::
* getLinealityDimension::
* getLinealitySpace::
* getLinearForms::
* getMultiplicity::
* getNegated::
* getQuotientLatticeBasis::
* getRays::
* getRelativeInteriorPoint::
* getSemigroupGenerator::
* getUniquePoint::
* hasFace::
* intersectCones::
* isFullSpace::
* isOrigin::
* isPure::
* isSimplicial::
* setLinearForms::
* setMultiplicity::
@end menu

@c --------------------------------------
@node canonicalizeCone,coneLink,,cone related functions
@subsubsection canonicalizeCone
@cindex canonicalizeCone

@table @code
@item @strong{Syntax:}
@code{canonicalizeCone(} cone c, intvec point @code{)}
@item @strong{Type:}
cone
@item @strong{Purpose:}
canonicalized version of the cone, no more redundant inequalities and equations
@item @strong{Example:}
@smallexample
@c example
intmat M[11][3]=
0,-1,1,
-1,1,0,
-1,0,1,
-1,-1,2,
-2,2,0,
-2,1,1,
-2,0,2,
-2,-1,3,
-3,2,1,
-3,1,2,
-3,0,3;
cone c=quickConeViaNormals(M);
c;
canonicalizeCone(c);
@c example
@end smallexample
@end table
@c --------------------------------------
@node coneLink,containsInSupport,canonicalizeCone,cone related functions
@subsubsection coneLink
@cindex coneLink

@table @code
@item @strong{Syntax:}
@code{coneLink(} cone c @code{)}
@item @strong{Type:}
cone
@item @strong{Purpose:}
local version of the given cone around the given point of the cone
@item @strong{Example:}
@smallexample
@c example
intmat M[3][3]=
1,0,0,
0,1,0,
0,0,1;
cone c=coneViaRays(M);
intvec v=1,0,0;
cone cc=coneLink(c,v);
cc;
print(getRays(cc));
intvec w=1,1,1;
cone cd=coneLink(c,w);
cd;
print(getRays(cd));
@c example
@end smallexample
@end table
@c --------------------------------------
@node containsInSupport,containsPositiveVector,coneLink,cone related functions
@subsubsection containsInSupport
@cindex containsInSupport

@table @code
@item @strong{Syntax:}
@code{containsInSupport(} cone c1, cone c2 @code{)}
@*@code{containsInSupport(} cone c, intvec point @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
1 iff c1 entirely contains c2 resp. iff c contains the given point, possibly on one of its facets; 0 otherwise
@item @strong{Example:}
@smallexample
@c example
intmat M[2][2]=
1,0,
0,1;
cone c=coneViaRays(M);
containsInSupport(c,c);
intmat N1[2][2]=
1,1,
0,1;
cone d1=coneViaRays(N1);
containsInSupport(c,d1);
intmat N2[2][2]=
1,1,
1,-1;
cone d2=coneViaRays(N2);
containsInSupport(c,d2);
intvec v1=0,1;
containsInSupport(c,v1);
intvec v2=1,-1;
containsInSupport(c,v2);
@c example
@end smallexample
@end table
@c --------------------------------------
@node containsPositiveVector,containsRelatively,containsInSupport,cone related functions
@subsubsection containsPositiveVector
@cindex containsPositiveVector

@table @code
@item @strong{Syntax:}
@code{containsPositiveVector(} cone c @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
1 iff the cone contains a point with positive coordinates in its relative interior; 0 otherwise
@item @strong{Example:}
@smallexample
@c example
intmat M1[2][2]=
1,1,
1,-1;
cone c1=coneViaRays(M1);
containsPositiveVector(c1);
intmat M2[2][2]=
0,1,
-1,0;
cone c2=coneViaRays(M2);
containsPositiveVector(c2);
@c example
@end smallexample
@end table
@c --------------------------------------
@node containsRelatively,getAmbientDimension,containsPositiveVector,cone related functions
@subsubsection containsRelatively
@cindex containsRelatively

@table @code
@item @strong{Syntax:}
@code{containsRelatively(} cone c, intvec point @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
1 iff the given cone contains the given point in its relative interior; 0 otherwise
@item @strong{Example:}
@smallexample
@c example
intmat M[2][2]=
1,0,
0,1;
cone c=coneViaRays(M);
intvec p1=1,1;
containsRelatively(c,p1);
intvec p2=0,1;
containsRelatively(c,p2);
@c example
@end smallexample
@end table
@c --------------------------------------
@node getAmbientDimension,getCodimension,containsRelatively,cone related functions
@subsubsection getAmbientDimension
@cindex getAmbientDimension

@table @code
@item @strong{Syntax:}
@code{getAmbientDimension(} cone c @code{)}
@*code{getAmbientDimension(} fan f @code{)}
@*code{getAmbientDimension(} polytope p @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
ambient dimension of the cone;
@item @strong{Example:}
@smallexample
@c example
intmat M1[2][2]=
1,0,
0,1;
cone c1=coneViaRays(M1);
getAmbientDimension(c1);
intmat M2[2][3]=
1,0,0,
0,1,0;
cone c2=coneViaRays(M2);
getAmbientDimension(c2);
@c example
@end smallexample
@end table
@c --------------------------------------
@node getCodimension,getDimension,getAmbientDimension,cone related functions
@subsubsection getCodimension
@cindex getCodimension

@table @code
@item @strong{Syntax:}
@code{getCodimension(} cone c @code{)}
@code{getCodimension(} fan f @code{)}
@code{getCodimension(} polytope c @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
codimension of the cone;
@item @strong{Example:}
@smallexample
@c example
intmat M1[1][2]=
1,0;
cone c1=coneViaRays(M1);
getCodimension(c1);
intmat M2[1][2]=
0,0;
cone c2=coneViaRays(M2);
getCodimension(c2);
@c example
@end smallexample
@end table
@c --------------------------------------
@node getDimension,getDualCone,getCodimension,cone related functions
@subsubsection getDimension
@cindex getDimension

@table @code
@item @strong{Syntax:}
@code{getDimension(} cone c @code{)}
@code{getDimension(} fan f @code{)}
@code{getDimension(} polytope p @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
dimension of the cone
@item @strong{Example:}
@smallexample
@c example
intmat M1[1][2]=
1,0;
cone c1=coneViaRays(M1);
getDimension(c1);
intmat M2[1][2]=
0,0;
cone c2=coneViaRays(M2);
getDimension(c2);
@c example
@end smallexample
@end table
@c --------------------------------------
@node getDualCone,getEquations,getDimension,cone related functions
@subsubsection getDualCone
@cindex getDualCone

@table @code
@item @strong{Syntax:}
@code{getDualCone(} cone c @code{)}
@item @strong{Type:}
cone
@item @strong{Purpose:}
the dual of the cone
@item @strong{Example:}
@smallexample
@c example
intmat M1[2][2]=
1,0,
0,1;
cone c1=coneViaRays(M1);
cone d1=getDualCone(c1);
d1;
print(getRays(d1));
intmat M2[2][2]=
1,1,
0,1;
cone c2=coneViaRays(M2);
cone d2=getDualCone(c2);
d2;
print(getRays(d2));
@c example
@end smallexample
@end table
@c --------------------------------------
@node getEquations,getFacetNormals,getDualCone,cone related functions
@subsubsection getEquations
@cindex getEquations

@table @code
@item @strong{Syntax:}
@code{getEquations(} cone c @code{)}
@code{getEquations(} polytope p @code{)}
@item @strong{Type:}
intmat
@item @strong{Purpose:}
equations given by the cone
@item @strong{Example:}
@smallexample
@c example
intmat M1[2][2]=
1,0,
0,1;
cone c1=coneViaRays(M1);
intmat E1=getEquations(c1);
print(E1);
intmat M2[1][2]=
1,0;
cone c2=coneViaRays(M2);
intmat E2=getEquations(c2);
print(E2);
@c example
@end smallexample
@end table
@c --------------------------------------
@node getFacetNormals,getGeneratorsOfLinealitySpace,getEquations,cone related functions
@subsubsection getFacetNormals
@cindex getFacets

@table @code
@item @strong{Syntax:}
@code{getFacetNormals(} cone c @code{)}
@*code{getFacetNormals(} polytope p @code{)}
@item @strong{Type:}
intmat
@item @strong{Purpose:}
inner normal vectors of the facets of the cone
@item @strong{Example:}
@smallexample
@c example
intmat M1[2][2]=
1,0,
0,1;
cone c1=coneViaRays(M1);
intmat F1=getFacetNormals(c1);
print(F1);
intmat M2[2][2]=
1,1,
0,-1;
cone c2=coneViaRays(M2);
intmat F2=getFacetNormals(c2);
print(F2);
@c example
@end smallexample
@end table
@c --------------------------------------
@node getGeneratorsOfLinealitySpace,getGeneratorsOfSpan,getFacetNormals,cone related functions
@subsubsection getGeneratorsOfLinealitySpace
@cindex getGeneratorsOfLinealitySpace

@table @code
@item @strong{Syntax:}
@code{getGeneratorsOfLinealitySpace(} cone c @code{)}
@item @strong{Type:}
intmat
@item @strong{Purpose:}
generating vectors of the lineality space of the cone
@item @strong{Example:}
@smallexample
@c example
intmat M[5][3]=
1,0,0,
0,1,0,
0,0,1,
-1,0,0,
0,-1,0;
cone c=coneViaRays(M);
intmat L=getGeneratorsOfLinealitySpace(c);
print(L);
@c example
@end smallexample
@end table
@c --------------------------------------
@node getGeneratorsOfSpan,getImpliedEquations,getGeneratorsOfLinealitySpace,cone related functions
@subsubsection getGeneratorsOfSpan
@cindex getGeneratorsOfSpan

@table @code
@item @strong{Syntax:}
@code{getGeneratorsOfSpan(} cone c @code{)}
@item @strong{Type:}
intmat
@item @strong{Purpose:}
generating vectors of the span of the cone
@item @strong{Example:}
@smallexample
@c example
intmat M[3][5]=
1,0,0,0,0,
0,1,0,0,0,
0,0,1,0,0;
cone c=coneViaRays(M);
intmat S=getGeneratorsOfSpan(c);
print(S);
@c example
@end smallexample
@end table
@c --------------------------------------
@node getImpliedEquations,getInequalities,getGeneratorsOfSpan,cone related functions
@subsubsection getImpliedEquations
@cindex getImpliedEquations

@table @code
@item @strong{Syntax:}
@code{getImpliedEquations(} cone c @code{)}
@item @strong{Type:}
intmat
@item @strong{Purpose:}
generating vectors of the orthogonal complement of the span of the cone
@item @strong{Example:}
@smallexample
@c example
intmat M[3][5]=
1,0,0,0,0,
0,1,0,0,0,
0,0,1,0,0;
cone c=coneViaRays(M);
intmat I=getImpliedEquations(c);
print(I);
@c example
@end smallexample
@end table
@c --------------------------------------
@node getInequalities,getLinealityDimension,getImpliedEquations,cone related functions
@subsubsection getInequalities
@cindex getInequalities

@table @code
@item @strong{Syntax:}
@code{getInequalities(} cone c @code{)}
@item @strong{Type:}
intmat
@item @strong{Purpose:}
inequalities given by the cone
@item @strong{Example:}
@smallexample
@c example
intmat M1[2][2]=
1,0,
0,1;
cone c1=coneViaRays(M1);
intmat I1=getInequalities(c1);
print(I);
intmat M2[1][2]=
1,0;
cone c2=coneViaRays(M2);
intmat I2=getInequalities(c2);
print(I2);
@c example
@end smallexample
@end table
@c --------------------------------------
@node getLinealityDimension,getLinealitySpace,getInequalities,cone related functions
@subsubsection getLinealityDimension
@cindex getLinealityDimension

@table @code
@item @strong{Syntax:}
@code{getLinealityDimension(} cone c @code{)}
@code{getLinealityDimension(} fan c @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
dimension of the lineality space of the cone
@item @strong{Example:}
@smallexample
@c example
intmat M1[3][3]=
1,0,0,
0,1,0,
0,0,1;
cone c1=coneViaRays(M1);
getLinealityDimension(c1);
intmat M2[4][3]=
1,0,0,
0,1,0,
0,0,1,
-1,0,0;
cone c2=coneViaRays(M2);
getLinealityDimension(c2);
@c example
@end smallexample
@end table
@c --------------------------------------
@node getLinealitySpace,getLinearForms,getLinealityDimension,cone related functions
@subsubsection getLinealitySpace
@cindex getLinealitySpace

@table @code
@item @strong{Syntax:}
@code{getLinealitySpace(} cone c @code{)}
@item @strong{Type:}
cone
@item @strong{Purpose:}
the lineality space of the cone as a new cone
@item @strong{Example:}
@smallexample
@c example
intmat M1[3][3]=
1,0,0,
0,1,0,
0,0,1;
cone c1=coneViaRays(M1);
cone l1=getLinealitySpace(c1);
l1;
intmat M2[4][3]=
1,0,0,
0,1,0,
0,0,1,
-1,0,0;
cone c2=coneViaRays(M2);
cone l2=getLinealitySpace(c2);
l2;
@c example
@end smallexample
@end table
@c --------------------------------------
@node getLinearForms,getMultiplicity,getLinealitySpace,cone related functions
@subsubsection getLinearForms
@cindex getLinearForms

@table @code
@item @strong{Syntax:}
@code{getLinearForms(} cone c @code{)}
@*code{getLinearForms(} polytope p @code{)}
@item @strong{Type:}
intvec
@item @strong{Purpose:}
linear forms of the cone (can be set by setLinearForms); returns empty intmat if not set
@item @strong{Example:}
@smallexample
@c example
intmat M[2][3]=
-1,0,0,
0,-1,0;
cone c=coneViaRays(M);
getLinearForms(c);
intvec v=1,1,1;
setLinearForms(c,v);
getLinearForms(c);
@c example
@end smallexample
@end table
@c --------------------------------------
@node getMultiplicity,getNegated,getLinearForms,cone related functions
@subsubsection getMultiplicity
@cindex getMultiplicity

@table @code
@item @strong{Syntax:}
@code{getMultiplicity(} cone c @code{)}
@*code{getMultiplicity(} polytope p @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
multiplicity of the cone (can be set by setMultiplicity); returns 1 if not set
@item @strong{Example:}
@smallexample
@c example
intmat M[2][3]=
-1,0,0,
0,-1,0;
cone c=coneViaRays(M);
getMultiplicity(c);
setMultiplicity(c,3);
getMultiplicity(c);
@c example
@end smallexample
@end table
@c --------------------------------------
@node getNegated,getQuotientLatticeBasis,getMultiplicity,cone related functions
@subsubsection getNegated
@cindex getNegated

@table @code
@item @strong{Syntax:}
@code{getNegated(} cone c @code{)}
@item @strong{Type:}
cone
@item @strong{Purpose:}
the negated (or negative) of the cone
@item @strong{Example:}
@smallexample
@c example
intmat M[2][2]=
1,0,
0,1;
cone c=coneViaRays(M);
cone cn=getNegated(c);
cn;
print(getRays(cn));
@c example
@end smallexample
@end table
@c --------------------------------------
@node getQuotientLatticeBasis,getRays,getNegated,cone related functions
@subsubsection getQuotientLatticeBasis
@cindex getQuotientLatticeBasis

@table @code
@item @strong{Syntax:}
@code{getQuotientLatticeBasis(} cone c @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
quotient of Z^n intersected with the span of the cone with Z^n intersected with its lineality space
@item @strong{Example:}
@smallexample
@c example
intmat M[3][2]=
1,0,
0,1,
-1,0;
cone c=coneViaRays(M);
intmat Q=getQuotientLatticeBasis(c);
print(Q);
@c example
@end smallexample
@end table
@c --------------------------------------
@node getRays,getRelativeInteriorPoint,getQuotientLatticeBasis,cone related functions
@subsubsection getRays
@cindex getRays

@table @code
@item @strong{Syntax:}
@code{getRays(} cone c @code{)}
@item @strong{Type:}
intmat
@item @strong{Purpose:}
rays of the cone outside the lineality space, rays inside the lineality space will be ignored
@item @strong{Example:}
@smallexample
@c example
intmat M1[2][2]=
1,0,
0,1;
cone c1=coneViaRays(M1);
intmat R1=getRays(c1);
print(R1);
intmat M2[3][2]=
1,0,
0,1,
-1,0;
cone c2=coneViaRays(M2);
intmat R2=getRays(c2);
print(R2);
@c example
@end smallexample
@end table
@c --------------------------------------
@node getRelativeInteriorPoint,getSemigroupGenerator,getRays,cone related functions
@subsubsection getRelativeInteriorPoint
@cindex getRelativeInteriorPoint

@table @code
@item @strong{Syntax:}
@code{getRelativeInteriorPoint(} cone c @code{)}
@item @strong{Type:}
intvec
@item @strong{Purpose:}
point in the relative interior of the cone
@item @strong{Example:}
@smallexample
@c example
intmat M1[2][2]=
1,0,
0,1;
cone c1=coneViaRays(M1);
getRelativeInteriorPoint(c1);
intmat M2[2][2]=
1,0,
1,1;
cone c2=coneViaRays(M2);
getRelativeInteriorPoint(c2);
@c example
@end smallexample
@end table
@c --------------------------------------
@node getSemigroupGenerator,getUniquePoint,getRelativeInteriorPoint,cone related functions
@subsubsection getSemigroupGenerator
@cindex getSemigroupGenerator

@table @code
@item @strong{Syntax:}
@code{getSemigroupGenerator(} cone c @code{)}
@item @strong{Type:}
intvec
@item @strong{Purpose:}
if getDimension(c)=getLinealityDimension(c)+1, then the quotient lattice of Z^n intersected with the span and Z^n intersected with the lineality space is Z^1 and the class of the cone is a semigroup. returns a generator of that semigroup. (like getQuotientLatticeBasis(cone c), but as intvec)
@item @strong{Example:}
@smallexample
@c example
intmat M[3][2]=
1,0,
0,1,
-1,0;
cone c=coneViaRays(M);
getSemigroupGenerator(c);
@c example
@end smallexample
@end table
@c --------------------------------------
@node getUniquePoint,hasFace,getSemigroupGenerator,cone related functions
@subsubsection getUniquePoint
@cindex getUniquePoint

@table @code
@item @strong{Syntax:}
@code{getUniquePoint(} cone c @code{)}
@item @strong{Type:}
intvec
@item @strong{Purpose:}
special-purpose interior point which supports recognition of symmetries among non-intersecting cones (used in implementation of fans)
@item @strong{Example:}
@smallexample
@c example
intmat M1[2][2]=
1,0,
0,1;
cone c1=coneViaRays(M1);
getUniquePoint(c1);
intmat M2[2][2]=
1,0,
1,1;
cone c2=coneViaRays(M2);
getUniquePoint(c2);
@c example
@end smallexample
@end table
@c --------------------------------------
@node hasFace,intersectCones,getUniquePoint,cone related functions
@subsubsection hasFace
@cindex hasFace

@table @code
@item @strong{Syntax:}
@code{hasFace(} cone c1, cone c2 @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
1 iff c1 contains c2 as a face; 0 otherwise
@item @strong{Example:}
@smallexample
@c example
intmat M[2][2]=
1,0,
0,1;
cone c=coneViaRays(M);
intmat N1[1][2]=
1,1;
cone d1=coneViaRays(N1);
hasFace(c,d1);
intmat N2[1][2]=
0,1;
cone d2=coneViaRays(N2);
hasFace(c,d2);
@c example
@end smallexample
@end table
@c --------------------------------------
@node intersectCones,isFullSpace,hasFace,cone related functions
@subsubsection intersectCones
@cindex intersectCones

@table @code
@item @strong{Syntax:}
@code{intersectCones(} cone c1, cone c2 @code{)}
@item @strong{Type:}
cone
@item @strong{Purpose:}
the intersection of the two cones
@item @strong{Example:}
@smallexample
@c example
intmat M1[2][2]=
1,0,
0,1;
cone c1=coneViaRays(M1);
intmat M2[2][2]=
1,1,
1,-1;
cone c2=coneViaRays(M2);
intmat M3[2][2]=
1,0,
0,-1;
cone c3=coneViaRays(M3);
cone c12=intersectCones(c1,c2);
c12;
print(getRays(c12));
cone c23=intersectCones(c2,c3);
c23;
print(getRays(c23));
cone c13=intersectCones(c1,c3);
c13;
print(getRays(c13));
@c example
@end smallexample
@end table
@c --------------------------------------
@node isFullSpace,isOrigin,intersectCones,cone related functions
@subsubsection isFullSpace
@cindex isFullSpace

@table @code
@item @strong{Syntax:}
@code{isFullSpace(} cone c @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
1 iff the cone is the entire ambient space; 0 otherwise
@item @strong{Example:}
@smallexample
@c example
cone c1;
isFullSpace(c1);
intmat M2[2][2]=
1,0,
0,1;
cone c2=coneViaRays(M2);
isFullSpace(c2);
intmat M3[4][2]=
1,0,
0,1,
-1,0,
0,-1;
cone c3=coneViaRays(M3);
isFullSpace(c3);
@c example
@end smallexample
@end table
@c --------------------------------------
@node isOrigin,isSimplicial,isFullSpace,cone related functions
@subsubsection isOrigin
@cindex isOrigin

@table @code
@item @strong{Syntax:}
@code{isOrigin(} cone c @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
1 iff the cone is just the origin of the ambient space; 0 otherwise
@item @strong{Example:}
@smallexample
@c example
cone c1; // full cone in zero-dimensional ambient space
isOrigin(c1);
intmat M2[2][2]=
1,0,
0,1;
cone c2=coneViaRays(M2);
isOrigin(c2);
intmat M3[4][2]=
1,0,
0,1,
-1,0,
0,-1;
cone c3=coneViaRays(M3);
isOrigin(c3);
@c example
@end smallexample
@end table
@c --------------------------------------
@node isSimplicial,setLinearForms,isOrigin,cone related functions
@subsubsection isSimplicial
@cindex isSimplicial

@table @code
@item @strong{Syntax:}
@code{isSimplicial(} cone c @code{)}
@*@code{isSimplicial(} fan f @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
1 iff the cone resp. fan is simplicial; 0 otherwise
@item @strong{Example:}
@smallexample
@c example
intmat M1[3][3]=
1,0,0,
0,1,0,
0,0,1;
cone c1=coneViaRays(M1);
isSimplicial(c1);
intmat M2[4][3]=
1,0,0,
0,1,0,
0,0,1,
1,1,-1;
cone c2=coneViaRays(M2);
isSimplicial(c2);
/***********************/
fan f=emptyFan(3);
isSimplicial(f);
intmat N1[3][3]=
1,0,0,
0,1,0,
0,0,1;
cone d1=coneViaRays(N1);
insertCone(f,d1);
isSimplicial(f);
intmat N2[4][3]=
1,0,0,
0,1,0,
1,0,-1,
0,1,-1;
cone d2=coneViaRays(N2);
insertCone(f,d2);
isSimplicial(f);
@c example
@end smallexample
@end table
@c --------------------------------------
@node setLinearForms,setMultiplicity,isSimplicial,cone related functions
@subsubsection setLinearForms
@cindex setLinearForms

@table @code
@item @strong{Syntax:}
@code{setLinearForms(} cone c, intvec linearform @code{)}
@code*{setLinearForms(} polytope c, intvec linearform @code{)}
@item @strong{Type:}
@item @strong{Purpose:}
adds the information of a linear form to the cone
@item @strong{Example:}
@smallexample
@c example
intmat M[2][3]=
-1,0,0,
0,-1,0;
cone c=coneViaRays(M);
getLinearForms(c);
intvec v=1,1,1;
setLinearForms(c,v);
getLinearForms(c);
@c example
@end smallexample
@end table
@c --------------------------------------
@node setMultiplicity,,setLinearForms,cone related functions
@subsubsection setMultiplicity
@cindex setMultiplicity

@table @code
@item @strong{Syntax:}
@code{setMultiplicity(} cone c, int multiplicity @code{)}
@*code{setMultiplicity(} polytope c, int multiplicity @code{)}
@item @strong{Type:}
@item @strong{Purpose:}
adds the information of a multiplicity to the cone
@item @strong{Example:}
@smallexample
@c example
intmat M[2][3]=
-1,0,0,
0,-1,0;
cone c=coneViaRays(M);
getMultiplicity(c);
setMultiplicity(c,3);
getMultiplicity(c);
@c example
@end smallexample
@end table
@c ---------------------------------------
@node fan, polytope, cone, Data types
@section fan
@cindex fan

@itemize
@item
Every fan has an ambient dimension.
@item
Every cone (of a fan) must have the same lineality space. (This follows
from the mathematical definition of a fan.)
@item
 The lineality space of a fan equals the intersection of all cones in the fan.
(Hence, the lineality space is equal to the lineality space of each cone.)
@item
In particular, the lineality space of the empty fan is the entire ambient
space.

@item
There may be symmetry in a fan: S_n acts on R^n by permuting coordinates;
thereby it acts on rays, cones and the entire fan.
@item
When a fan is invariant under the action of a subgroup of S_n then one may
want to store not only cones but also that subgroup. Then we also only need
to store one cone from each orbit. That is what ZFan (= SINGULAR's fan object)
does.
@item
Mathematically, adding a cone to a given fan will also automatically add all
faces (of every dimension) of that cone. Therefore the implementation only
stores a subset of the cones in the fan. Hence in the implementation, a cone
of a fan represents itself and all its faces.

@item
Internally, there are two ways of representing fans: as a set of (mutually
distinct) cones and as a complex on the set of rays. The second
representation allows for the computation of both all orbits (under the
group action) and orbits of maximal cones, only.
Once the fan representation has been switched from the former to the latter
representation, insertion and deletion of cones will not work anymore.
(A warning will be given.)

@item
A ray intersected with its orthogonal complement is a one-dimensional ray
containing a uniqe non-zero primitive vector. Consequently, these vectors
can be computed uniquely, and stored as rows of a matrix which we will refer
to as the matrix of ray generators.

@item
Access to cones of the fan is provided in three different ways:
@itemize
@item
  1. access to the cones as provided by the user (by means of insertion, removal, 
     extraction)
@item
  2. access to the representatives of all orbits (under the group action)
     coming from maximal cones
@item
  3. access to the representatives of all orbits (under the group action), i.e.,
     of the orbits of all faces of maximal cones
@end itemize
  For variants 2. and 3. access is possible dimension-wise, as specified by the
  user. Then the returned object can be either a list of indices (to rows of
  the matrix of ray generators) or a list of ZCones.
  In the first case, an index must be provided and a ZCone will be returned.
@end itemize

@smallexample
  fan f;                              // ambient dim 0, no cones, lineality
                                      // space = ambient space
  fan f = fan_empty(int n);           // ambient dim = n, no cones,
                                      // symmetry subgroup = <e>
  fan f = n;                          // synonymous convenience method for
                                      // 'fan f = fan_empty(n)'
  fan f = emptyFan(
                 optional intmat G);  // symmetry group generated by rows of
                                      // G; ambient dim = number of columns
                                      // of G
            // Here a row r = r_1, ...r_n represents the permutation
            // which takes i to r_i. SINGULAR will check for the validity
            // of the provided rows, i.e. whether @{r_1,...,r_n@} = @{1,...,n@}
  fan f = fullFan(int n);             // ambient dim = n, the fan consists of
                                      // one cone which equals the ambient
                                      // space, symmetry subgroup = <e>
  fan f = fullFan(
                 optional intmat G);  // symmetry group generated by rows of
                                      // G; ambient dim = number of columns
                                      // of G; the fan consists of one cone
                                      // which equals the ambient space
@end smallexample

@menu
* fan related functions::
@end menu
@c --------------------------------------------------------------------
@node fan related functions,,,fan
@subsection fan related functions
@cindex fan related functions

See also @ref{getAmbientDimension},
@ref{getCodimension},
@ref{getLinealityDimension},
@ref{isSimplicial}.

@menu
* containsInCollection::
* getCone::
* insertCone::
* isCompatible::
@c * isComplete::
* isPure::
* nmaxcones::
* ncones::
* numberOfConesOfDimension::
* quickInsertCone::
@end menu

@c --------------------------------------------------------------------
@node containsInCollection,getCone,,fan related functions
@subsubsection containsInCollection
@cindex containsInCollection

@table @code
@item @strong{Syntax:}
@code{containsInCollection(} fan f, cone c @code{)}
@item @strong{Type:}
cone
@item @strong{Purpose:}
1 iff c is contained in the collection of cones that is f; 0 otherwise
@item @strong{Example:}
@smallexample
@c example
fan f=emptyFan(2);
intmat M[2][2]=
1,0,
0,1;
cone c=coneViaRays(M);
containsInCollection(f,c);
insertCone(f,c);
containsInCollection(f,c);
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------
@node getCone,insertCone,containsInCollection,fan related functions
@subsubsection getCone
@cindex getCone

@table @code
@item @strong{Syntax:}
@code{getCone(} fan f, int dimension, int index, int orbit, int maximal @code{)}
@item @strong{Type:}
cone
@item @strong{Purpose:}
cone (orbit=0) or orbit (orbit=1) of a certain index (ranges from 1 to numberOfConesOfDimension(f,2,0,0)) in a given dimension; if maximal=0, all cones and orbits are considered, if maximal=1, only maximal cones and orbits are considered
@item @strong{Example:}
@smallexample
@c example
intmat M[3][3]=
1,0,0,
0,1,0,
0,0,1;
cone c=coneViaRays(M);
fan f=emptyFan(3);
insertCone(f,c);
getCone(f,2,1,0,0);
getCone(f,2,2,0,0);
getCone(f,2,3,0,0);
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------
@node insertCone,isCompatible,getCone,fan related functions
@subsubsection insertCone
@cindex insertCone

@table @code
@item @strong{Syntax:}
@code{insertCone(} fan f, cone c @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
inserts the cone into the fan, checks for compatibility beforehand
@item @strong{Example:}
@smallexample
@c example
fan f=emptyFan(3);
f;
intmat M[3][3]=
1,0,0,
0,1,0,
0,0,1;
cone c=coneViaRays(M);
insertCone(f,c);
f;
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------
@node isCompatible,isPure,insertCone,fan related functions
@c @node isCompatible,isComplete,insertCone,fan related functions
@subsubsection isCompatible
@cindex isCompatible

@table @code
@item @strong{Syntax:}
@code{isCompatible(} fan f, cone c @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
1 iff cone is compatible with the fan; 0 otherwise
@item @strong{Example:}
@smallexample
@c example
fan f=emptyFan(3);
intmat M1[3][3]=
1,0,0,
0,1,0,
0,0,1;
cone c1=coneViaRays(M1);
isCompatible(f,c1);
insertCone(f,c1);
intmat M2[3][3]=
1,1,1,
1,0,0,
0,1,0;
cone c2=coneViaRays(M2);
isCompatible(f,c2);
intmat M3[3][3]=
1,0,0,
0,1,0,
0,0,-1;
cone c3=coneViaRays(M3);
isCompatible(f,c3);
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------
@c @node isComplete,isPure,isCompatible,fan related functions
@c @subsubsection isComplete
@c @cindex isComplete

@c @table @code
@c @item @strong{Syntax:}
@c @code{isComplete(} fan f @code{)}
@c @item @strong{Type:}
@c int
@c @item @strong{Purpose:}
@c 1 iff the fan is complete; 0 otherwise
@c @item @strong{Example:}
@c @smallexample
@c @c example
@c fan f=fullFan(2);
@c isComplete(f);
@c fan g=emptyFan(2);
@c intmat M1[2][2]=
@c 1,0,
@c 0,1;
@c cone c1=coneViaRays(M1);
@c insertCone(g,c1);
@c isComplete(g);
@c intmat M2[2][2]=
@c 1,0,
@c -1,-1;
@c cone c2=coneViaRays(M2);
@c insertCone(g,c2);
@c isComplete(g,c2);
@c intmat M3[2][2]=
@c -1,-1,
@c 0,1;
@c cone c3=coneViaRays(M3);
@c insertCone(g,c3);
@c isComplete(g,c3);
@c @c example
@c @end smallexample
@c @end table
@c --------------------------------------------------------------------
@node isPure,nmaxcones,isCompatible,fan related functions
@c @node isPure,nmaxcones,isComplete,fan related functions
@subsubsection isPure
@cindex isPure

@table @code
@item @strong{Syntax:}
@code{isPure(} fan f@code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
1 iff the fan is pure; 0 otherwise
@item @strong{Example:}
@smallexample
@c example
fan f=fullFan(2);
isPure(f);
fan g=emptyFan(2);
intmat M1[2][2]=
1,0,
0,1;
cone c1=coneViaRays(M1);
insertCone(g,c1);
isPure(g);
intmat M2[1][2]=
0,-1;
cone c2=coneViaRays(M2);
insertCone(g,c2);
isPure(g,c2);
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------
@node nmaxcones,ncones,isPure,fan related functions
@subsubsection nmaxcones
@cindex nmaxcones

@table @code
@item @strong{Syntax:}
@code{nmaxcones(} fan f @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
number of maximal cones in f
@item @strong{Example:}
@smallexample
@c example
fan f=emptyFan(3);
nmaxcones(f);
intmat M1[3][3]=
1,0,0,
0,1,0,
0,0,1;
cone c1=coneViaRays(M1);
insertCone(f,c1);
nmaxcones(f);
intmat M2[2][3]=
1,0,0,
0,-1,0;
cone c2=coneViaRays(M2);
insertCone(f,c2);
nmaxcones(f);
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------
@node ncones,numberOfConesOfDimension,nmaxcones,fan related functions
@subsubsection ncones
@cindex ncones

@table @code
@item @strong{Syntax:}
@code{ncones(} fan f @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
number of cones in f
@item @strong{Example:}
@smallexample
@c example
fan f=emptyFan(3);
ncones(f);
intmat M1[3][3]=
1,0,0,
0,1,0,
0,0,1;
cone c1=coneViaRays(M1);
insertCone(f,c1);
ncones(f);
intmat M2[2][3]=
1,0,0,
0,-1,0;
cone c2=coneViaRays(M2);
insertCone(f,c2);
ncones(f);
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------
@node numberOfConesOfDimension,quickInsertCone,ncones,fan related functions
@subsubsection numberOfConesOfDimension
@cindex numberOfConesOfDimension

@table @code
@item @strong{Syntax:}
@code{numberOfConesOfDimension(} fan f, int dimension, int orbit, int maximal @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
number of cones (orbit=0) or orbits (orbit=1) of a given dimension; if maximal=0, then all cones are considered, if maximal=1, only maximal cones are considered
@item @strong{Example:}
@smallexample
@c example
fan f=emptyFan(3);
ncones(f);
intmat M[3][3]=
1,0,0,
0,1,0,
0,0,1;
cone c=coneViaRays(M);
insertCone(f,c);
numberOfConesOfDimension(f,0,0,0);
numberOfConesOfDimension(f,0,0,1);
numberOfConesOfDimension(f,1,0,0);
numberOfConesOfDimension(f,0,0,1);
numberOfConesOfDimension(f,2,0,0);
numberOfConesOfDimension(f,2,0,1);
numberOfConesOfDimension(f,3,0,0);
numberOfConesOfDimension(f,3,0,1);
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------
@node quickInsertCone,,numberOfConesOfDimension,fan related functions
@subsubsection quickInsertCone
@cindex quickInsertCone

@table @code
@item @strong{Syntax:}
@code{quickInsertCone(} fan f @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
inserts the cone into the fan, no checking of compatibility
@item @strong{Example:}
@smallexample
@c example
fan f=emptyFan(3);
f;
intmat M[3][3]=
1,0,0,
0,1,0,
0,0,1;
cone c=coneViaRays(M);
quickInsertCone(f,c);
f;
@c example
@end smallexample
@end table
@c ---------------------------------------
@node polytope, pyobject, fan, Data types
@section polytope
@cindex polytope

A rational convex polytope (in short ``polytope'') in R^n is the convex 
hull of rational points. It may or may not be bounded.
It is internally realized as a cone in one dimension higher, intersected 
with the hyperplane x0=1, we will consider it embedded into the projective 
space through R^n -> P R^n, x -> (1,x).
Each polytope is uniquely determined by a minimal set of finitely many 
points, which we will refer to as ``vertices''.  
Moreover, a polytope can be represented as a set of points satisfying certain 
homogeneous linear inequalities and equalities.
And these are the two main ways of constructing non-trivial polytopes.

@menu
* polytopeViaVertices::
* polytopeViaNormals::
* polytope related functions::
@end menu
@c --------------------------------------------------------------------------------
@node polytopeViaVertices,polytopeViaNormals,,polytope
@subsection polytopeViaVertices
@cindex polytopeViaVertices
@table @code
@item @strong{Syntax:}
@code{polytopeViaVertices(} intmat V @code{)}
@*@code{polytopeViaVertices(} intmat V, int flags @code{)}
@item @strong{Type:}
polytope
@item @strong{Purpose:}
polytope generated by the row vectors of V 
(thought of as representatives of points in the projective space);
flags may only be 0 or 1,
if flags is 1, then program assumes that each row vector of M is 
a vertex of the polytope, 
if flags is 0, then program computes the information itself.
@item @strong{Example:}
@smallexample
@c example
// Let's a polytope in R^2 generated by:
intmat V[4][3]= 
1,0,0,
1,1,0,
1,0,1,
1,1,1;
polytope p=polytopeViaVertices(V);
c;
// the input points are exactly the vertices:
intmat V[4][3]= 
1,0,0,
1,1,0,
1,0,1,
1,1,1;
polytope p=polytopeViaVertices(V,1);
c;
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------------------
@node polytopeViaNormals,polytope related functions,polytopeViaVertices,cone
@subsection polytopeViaNormals
@cindex polytopeViaNormals
@table @code
@item @strong{Syntax:}
@code{polytopeViaNormals(} intmat IE @code{)}
@*@code{polytopeViaNormals(} intmat IE, intmat E @code{)}
@*@code{polytopeViaNormals(} intmat IE, intmat E, int flags @code{)}
@item @strong{Type:}
cone
@item @strong{Purpose:}
cone consisting of all points x, such that IE*x >= 0 in each component
and (if stated) E*x = 0;
flags may range between 0,..,3 defining an upper and lower bit
(0=0*2+0, 1=0*2+1, 2=1*2+0, 3=1*2+1),
if higher bit is 1, then program assumes each inequality yields a facet,
if lower bit is 1, then program assumes the kernel of E is the span of the cone,
if either bit is 0, then program computes the information itself. 
@item @strong{Example:}
@smallexample
@c example
intmat IE[2][3]=
1,0,0,
0,1,0;
intmat E[1][3]=
0,0,1;
polytope p=polytopeViaNormals(IE,E);
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------
@node polytope related functions,,,polytope
@subsection polytope related functions
@cindex polytope related functions

See also @ref{getAmbientDimension},
@ref{getCodimension}, 
@ref{getDimension},
@ref{getEquations},
@ref{getFacetNormals},
@ref{getInequalities},
@ref{getLinearForms},
@ref{getMultiplicity},
@ref{setLinearForms},
@ref{setMultiplicity}.

@menu
* getVertices::
@end menu

@c --------------------------------------------------------------------
@node getVertices,,,polytope related functions
@subsubsection getVertices
@cindex getVertices

@table @code
@item @strong{Syntax:}
@code{getVertices(} polytope p @code{)}
@item @strong{Type:}
intmat
@item @strong{Purpose:}
vertices of p 
@item @strong{Example:}
@smallexample
@c computed example getCone cones.doc:818
intmat M[4][3]=
1,0,0,
1,2,0,
1,0,2,
1,2,2,
1,1,1;
polytope p=polytopeViaPoints(M);
print(getVertices(p));
@c end example getCone cones.doc:818
@end smallexample
@end table
