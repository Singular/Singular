@comment -*-texinfo-*-
@comment this file contains the cone/fan definitions

@c -------------------------------------------------------------------
@node cone, fan, User defined types, Data types
@section cone
@cindex cone

In order to use convex objects in Singular, Singular has to be build from sources
together with gfanlib, a C++ library for convex geometry by Anders N. Jensen.
Please check the readme file for installation instructions.

In the finite dimensional real vector space R^n, a convex rational polyhedral
cone, in short ``cone'', is the convex set generated by finitely many half-lines,
which in turn are generated by rational, and hence integer, points. It may or may not
contain whole subspace of R^n (e.g. entire lines). The biggest subspace contained in
a cone is called ``lineality space''. Modulo its lineality space, each cone is
generated by a distinct minimal set of half lines, which are referred to as
``rays''. Alternatively, a cone can be represented as a set of points satisfying
a system homogeneous rational, and hence integer, linear inequalities and equations.
These two characterizations of cones are the two main ways of defining cones in
Singular (@pxref{coneViaPoints}, @pxref{coneViaInequalities}).

@smallexample
  cone c;                             // ambient dim 0, no equations,
                                      // no inequalities
  cone c = 17;                        // ambient dim 17, no equations,
                                      // no inequalities
@end smallexample

@menu
* coneViaPoints::
* coneViaInequalities::
* cone related functions::
@end menu
@c --------------------------------------------------------------------------------
@node coneViaPoints,coneViaInequalities,,cone
@subsection coneViaPoints
@cindex coneViaPoints
@table @code
@item @strong{Syntax:}
@code{coneViaPoints(} intmat HL @code{)}
@*@code{coneViaPoints(} intmat HL, intmat L @code{)}
@*@code{coneViaPoints(} intmat HL, intmat L, int flags @code{)}
@item @strong{Type:}
cone
@item @strong{Purpose:}
cone generated by half lines generated by the row vectors of HL
and (if stated) by lines generated by the row vectors of L;
flags may range between 0,..,3 defining an upper and lower bit
(0=0*2+0, 1=0*2+1, 2=1*2+0, 3=1*2+1),
if upper bit is 1, then program assumes that each row vector in HL
generates a ray of the cone,
if lower bit is 1, then program assumes that the span of the row
vectors of L is the lineality space of the cone,
if either bit is 0, then program computes the information itself.
@item @strong{Example:}
@smallexample
@c example
// Let's define a cone in R^3 generated by the following half lines:
intmat HL[5][3]=
 1,0, 0,
-1,0, 0,
 0,1, 1,
 0,1,-1,
 0,0, 1;
cone c=coneViaPoints(HL);
c;
kill HL,c;
// Note that (1,0,0) and (-1,0,0) form a line, hence also possible:
intmat HL[3][3]=
0,1, 1,
0,1,-1,
0,0, 1;
intmat L[1][3]=
1,0,0;
cone c=coneViaPoints(HL,L);
c;
kill HL,L,c;
// lineality space is exactly Lin(1,0,0)
intmat HL[3][3]=
0,1, 1,
0,1,-1,
0,0, 1;
intmat L[1][3]=
1,0,0;
cone c=coneViaPoints(HL,L,1);
c;
kill HL,L,c;
// and that (0,1,-1), (0,1,1) generate rays
intmat HL[3][3]=
0,1, 1,
0,1,-1;
intmat L[1][3]=
1,0,0;
cone c=coneViaPoints(HL,L,3);
c;
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------------------
@node coneViaInequalities,cone related functions,coneViaPoints,cone
@subsection coneViaInequalities
@cindex coneViaInequalities
@table @code
@item @strong{Syntax:}
@code{coneViaInequalities(} intmat IE @code{)}
@*@code{coneViaInequalities(} intmat IE, intmat E @code{)}
@*@code{coneViaInequalities(} intmat IE, intmat E, int flags @code{)}
@item @strong{Type:}
cone
@item @strong{Purpose:}
cone consisting of all points x, such that IE*x >= 0 in each component
and (if stated) E*x = 0;
inequalities and (if stated) equations will be transformed, getting rid of
redundancies;
flags may range between 0,..,3 defining an upper and lower bit
(0=0*2+0, 1=0*2+1, 2=1*2+0, 3=1*2+1),
if higher bit is 1, then program assumes each inequality yields a facet,
if lower bit is 1, then program assumes the kernel of E is the span of the cone,
if either bit is 0, then program computes the information itself.
@item @strong{Example:}
@smallexample
@c example
// Let's define a cone in R^3 given by the following inequalities:
intmat IE[6][3]=
1,3,5,
1,5,3,
0,1,-1,
0,1,1,
1,0,0,
-1,0,0;
cone c=coneViaInequalities(IE);
c;
// Note that the last two inequalities yield x1 = 0, hence also possible:
intmat IE[4][3]=
0,1,-1,
0,1,1;
intmat E[1][3]=
1,0,0;
cone c=coneViaInequalities(IE,E);
c;
// each inequalities gives rise to a facet
intmat IE[2][3]=
0,1,-1,
0,1,1;
intmat E[1][3]=
1,0,0;
cone c=coneViaInequalities(IE,E,1);
c;
// and the kernel of E is the span of the cone
intmat IE[2][3]=
0,1,-1,
0,1,1;
intmat E[1][3]=
1,0,0;
cone c=coneViaInequalities(IE,E,3);
c;
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------------------
@node cone related functions,,coneViaInequalities,cone
@subsection cone related functions
@cindex cone related functions

@menu
* ambientDimension::
* canonicalizeCone::
* codimension::
* coneLink::
* containsAsFace::
* containsInSupport::
* containsPositiveVector::
* containsRelatively::
* convexHull::
* convexIntersection::
* dimension::
* dualCone::
* equations::
* facets::
* generatorsOfLinealitySpace::
* generatorsOfSpan::
* getLinearForms::
* getMultiplicity::
* inequalities::
* isFullSpace::
* isOrigin::
* isSimplicial::
* linealityDimension::
* linealitySpace::
* negatedCone::
* quotientLatticeBasis::
* randomPoint::
* rays::
* relativeInteriorPoint::
* semigroupGenerator::
* setLinearForms::
* setMultiplicity::
* span::
* uniquePoint::
@end menu

@c --------------------------------------
@node ambientDimension,canonicalizeCone,,cone related functions
@subsubsection ambientDimension
@cindex ambientDimension

@table @code
@item @strong{Syntax:}
@code{ambientDimension(} cone c @code{)}
@*@code{ambientDimension(} fan f @code{)}
@*@code{ambientDimension(} polytope p @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
ambient dimension of the cone;
@item @strong{Example:}
@smallexample
@c example
intmat M1[2][2]=
1,0,
0,1;
cone c1=coneViaPoints(M1);
ambientDimension(c1);
intmat M2[2][3]=
1,0,0,
0,1,0;
cone c2=coneViaPoints(M2);
ambientDimension(c2);
@c example
@end smallexample
@end table
@c --------------------------------------
@node canonicalizeCone,codimension,ambientDimension,cone related functions
@subsubsection canonicalizeCone
@cindex canonicalizeCone

@table @code
@item @strong{Syntax:}
@code{canonicalizeCone(} cone c, intvec point @code{)}
@item @strong{Type:}
cone
@item @strong{Purpose:}
canonicalized version of the cone, no more redundant inequalities and equations
@item @strong{Example:}
@smallexample
@c example
intmat M[11][3]=
0,-1,1,
-1,1,0,
-1,0,1,
-1,-1,2,
-2,2,0,
-2,1,1,
-2,0,2,
-2,-1,3,
-3,2,1,
-3,1,2,
-3,0,3;
cone c=coneViaInequalities(M);
c;
canonicalizeCone(c);
@c example
@end smallexample
@end table
@c --------------------------------------
@node codimension,coneLink,canonicalizeCone,cone related functions
@subsubsection codimension
@cindex codimension

@table @code
@item @strong{Syntax:}
@code{codimension(} cone c @code{)}
@code{codimension(} fan f @code{)}
@code{codimension(} polytope c @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
codimension of the cone;
@item @strong{Example:}
@smallexample
@c example
intmat M1[1][2]=
1,0;
cone c1=coneViaPoints(M1);
codimension(c1);
intmat M2[1][2]=
0,0;
cone c2=coneViaPoints(M2);
codimension(c2);
@c example
@end smallexample
@end table
@c --------------------------------------
@node coneLink,containsAsFace,codimension,cone related functions
@subsubsection coneLink
@cindex coneLink

@table @code
@item @strong{Syntax:}
@code{coneLink(} cone c @code{)}
@item @strong{Type:}
cone
@item @strong{Purpose:}
local version of the given cone around the given point of the cone
@item @strong{Example:}
@smallexample
@c example
intmat M[3][3]=
1,0,0,
0,1,0,
0,0,1;
cone c=coneViaPoints(M);
intvec v=1,0,0;
cone cc=coneLink(c,v);
cc;
print(rays(cc));
intvec w=1,1,1;
cone cd=coneLink(c,w);
cd;
print(rays(cd));
@c example
@end smallexample
@end table
@c --------------------------------------
@node containsAsFace,containsInSupport,coneLink,cone related functions
@subsubsection containsAsFace
@cindex containsAsFace

@table @code
@item @strong{Syntax:}
@code{containsAsFace(} cone c1, cone c2 @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
1 iff c1 contains c2 as a face; 0 otherwise
@item @strong{Example:}
@smallexample
@c example
intmat M[2][2]=
1,0,
0,1;
cone c=coneViaPoints(M);
intmat N1[1][2]=
1,1;
cone d1=coneViaPoints(N1);
containsAsFace(c,d1);
intmat N2[1][2]=
0,1;
cone d2=coneViaPoints(N2);
containsAsFace(c,d2);
@c example
@end smallexample
@end table
@c --------------------------------------
@node containsInSupport,containsPositiveVector,containsAsFace,cone related functions
@subsubsection containsInSupport
@cindex containsInSupport

@table @code
@item @strong{Syntax:}
@code{containsInSupport(} cone c1, cone c2 @code{)}
@*@code{containsInSupport(} cone c, intvec point @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
1 iff c1 entirely contains c2 resp. iff c contains the given point, possibly on one of its facets; 0 otherwise
@item @strong{Example:}
@smallexample
@c example
intmat M[2][2]=
1,0,
0,1;
cone c=coneViaPoints(M);
containsInSupport(c,c);
intmat N1[2][2]=
1,1,
0,1;
cone d1=coneViaPoints(N1);
containsInSupport(c,d1);
intmat N2[2][2]=
1,1,
1,-1;
cone d2=coneViaPoints(N2);
containsInSupport(c,d2);
intvec v1=0,1;
containsInSupport(c,v1);
intvec v2=1,-1;
containsInSupport(c,v2);
@c example
@end smallexample
@end table
@c --------------------------------------
@node containsPositiveVector,containsRelatively,containsInSupport,cone related functions
@subsubsection containsPositiveVector
@cindex containsPositiveVector

@table @code
@item @strong{Syntax:}
@code{containsPositiveVector(} cone c @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
1 iff the cone contains a point with positive coordinates in its relative interior; 0 otherwise
@item @strong{Example:}
@smallexample
@c example
intmat M1[2][2]=
1,1,
1,-1;
cone c1=coneViaPoints(M1);
containsPositiveVector(c1);
intmat M2[2][2]=
0,1,
-1,0;
cone c2=coneViaPoints(M2);
containsPositiveVector(c2);
@c example
@end smallexample
@end table
@c --------------------------------------
@node containsRelatively,convexHull,containsPositiveVector,cone related functions
@subsubsection containsRelatively
@cindex containsRelatively

@table @code
@item @strong{Syntax:}
@code{containsRelatively(} cone c, intvec point @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
1 iff the given cone contains the given point in its relative interior; 0 otherwise
@item @strong{Example:}
@smallexample
@c example
intmat M[2][2]=
1,0,
0,1;
cone c=coneViaPoints(M);
intvec p1=1,1;
containsRelatively(c,p1);
intvec p2=0,1;
containsRelatively(c,p2);
@c example
@end smallexample
@end table
@c --------------------------------------
@node convexHull,convexIntersection,containsRelatively,cone related functions
@subsubsection convexHull
@cindex convexHull

@table @code
@item @strong{Syntax:}
@code{convexHull(} cone c1, cone c2 @code{)}
@*@code{convexHull(} cone c1, polytope p1 @code{)}
@*@code{convexHull(} polytope p1, cone c1 @code{)}
@*@code{convexHull(} polytope p1, polytope p2 @code{)}
@item @strong{Type:}
cone if both input arguments are cones, else polytope
@item @strong{Purpose:}
the hull of the two objects
@item @strong{Example:}
@smallexample
@c example
intmat M1[2][2]=
1,0,
0,1;
cone c1=coneViaPoints(M1);
intmat M2[2][2]=
1,1,
1,-1;
cone c2=coneViaPoints(M2);
intmat M3[2][2]=
1,0,
0,-1;
cone c3=coneViaPoints(M3);
cone c12=convexHull(c1,c2);
c12;
print(rays(c12));
cone c23=convexHull(c2,c3);
c23;
print(rays(c23));
cone c13=convexHull(c1,c3);
c13;
print(rays(c13));
@c example
@end smallexample
@end table
@c --------------------------------------
@node convexIntersection,dimension,convexHull,cone related functions
@subsubsection convexIntersection
@cindex convexIntersection

@table @code
@item @strong{Syntax:}
@code{convexIntersection(} cone c1, cone c2 @code{)}
@*@code{convexIntersection(} cone c1, polytope p1 @code{)}
@*@code{convexIntersection(} polytope p1, cone c1 @code{)}
@*@code{convexIntersection(} polytope p1, polytope p2 @code{)}
@item @strong{Type:}
cone if both input arguments are cones, else polytope
@item @strong{Purpose:}
the intersection of the two objects
@item @strong{Example:}
@smallexample
@c example
intmat M1[2][2]=
1,0,
0,1;
cone c1=coneViaPoints(M1);
intmat M2[2][2]=
1,1,
1,-1;
cone c2=coneViaPoints(M2);
intmat M3[2][2]=
1,0,
0,-1;
cone c3=coneViaPoints(M3);
cone c12=convexIntersection(c1,c2);
c12;
print(rays(c12));
cone c23=convexIntersection(c2,c3);
c23;
print(rays(c23));
cone c13=convexIntersection(c1,c3);
c13;
print(rays(c13));
@c example
@end smallexample
@end table
@c --------------------------------------
@node dimension,dualCone,convexIntersection,cone related functions
@subsubsection dimension
@cindex dimension

@table @code
@item @strong{Syntax:}
@code{dimension(} cone c @code{)}
@code{dimension(} fan f @code{)}
@code{dimension(} polytope p @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
dimension of the cone
@item @strong{Example:}
@smallexample
@c example
intmat M1[1][2]=
1,0;
cone c1=coneViaPoints(M1);
dimension(c1);
intmat M2[1][2]=
0,0;
cone c2=coneViaPoints(M2);
dimension(c2);
@c example
@end smallexample
@end table
@c --------------------------------------
@node dualCone,equations,dimension,cone related functions
@subsubsection dualCone
@cindex dualCone

@table @code
@item @strong{Syntax:}
@code{dualCone(} cone c @code{)}
@item @strong{Type:}
cone
@item @strong{Purpose:}
the dual of the cone
@item @strong{Example:}
@smallexample
@c example
intmat M1[2][2]=
1,0,
0,1;
cone c1=coneViaPoints(M1);
cone d1=dualCone(c1);
d1;
print(rays(d1));
intmat M2[2][2]=
1,1,
0,1;
cone c2=coneViaPoints(M2);
cone d2=dualCone(c2);
d2;
print(rays(d2));
@c example
@end smallexample
@end table
@c --------------------------------------
@node equations,facets,dualCone,cone related functions
@subsubsection equations
@cindex equations

@table @code
@item @strong{Syntax:}
@code{equations(} cone c @code{)}
@*@code{equations(} polytope p @code{)}
@item @strong{Type:}
bigintmat
@item @strong{Purpose:}
equations given by the cone or polytope
@item @strong{Example:}
@smallexample
@c example
intmat M1[2][2]=
1,0,
0,1;
cone c1=coneViaPoints(M1);
bigintmat E1=equations(c1);
print(E1);
intmat M2[1][2]=
1,0;
cone c2=coneViaPoints(M2);
bigintmat E2=equations(c2);
print(E2);
// polytope generated by the unit vectors in dimension 3
bigintmat N[3][4]=
1,1,0,0,
1,0,1,0,
1,0,0,1;
polytope p=polytopeViaPoints(N);
bigintmat F=equations(p);
print(F);
@c example
@end smallexample
@end table
@c --------------------------------------
@node facets,generatorsOfLinealitySpace,equations,cone related functions
@subsubsection facets
@cindex facets

@table @code
@item @strong{Syntax:}
@code{facets(} cone c @code{)}
@*@code{facets(} polytope p @code{)}
@item @strong{Type:}
bigintmat
@item @strong{Purpose:}
inner normal vectors of the facets of the cone or polytopes
@item @strong{Example:}
@smallexample
@c example
intmat M1[2][2]=
1,0,
0,1;
cone c1=coneViaPoints(M1);
bigintmat F1=facets(c1);
print(F1);
intmat M2[2][2]=
1,1,
0,-1;
cone c2=coneViaPoints(M2);
bigintmat F2=facets(c2);
print(F2);
@c example
@end smallexample
@end table
@c --------------------------------------
@node generatorsOfLinealitySpace,generatorsOfSpan,facets,cone related functions
@subsubsection generatorsOfLinealitySpace
@cindex generatorsOfLinealitySpace

@table @code
@item @strong{Syntax:}
@code{generatorsOfLinealitySpace(} cone c @code{)}
@item @strong{Type:}
bigintmat
@item @strong{Purpose:}
generating vectors of the lineality space of the cone
@item @strong{Example:}
@smallexample
@c example
intmat M[5][3]=
1,0,0,
0,1,0,
0,0,1,
-1,0,0,
0,-1,0;
cone c=coneViaPoints(M);
bigintmat L=generatorsOfLinealitySpace(c);
print(L);
@c example
@end smallexample
@end table
@c --------------------------------------
@node generatorsOfSpan,getLinearForms,generatorsOfLinealitySpace,cone related functions
@subsubsection generatorsOfSpan
@cindex generatorsOfSpan

@table @code
@item @strong{Syntax:}
@code{generatorsOfSpan(} cone c @code{)}
@item @strong{Type:}
bigintmat
@item @strong{Purpose:}
generating vectors of the span of the cone
@item @strong{Example:}
@smallexample
@c example
intmat M[3][5]=
1,0,0,0,0,
0,1,0,0,0,
0,0,1,0,0;
cone c=coneViaPoints(M);
bigintmat S=generatorsOfSpan(c);
print(S);
@c example
@end smallexample
@end table
@c --------------------------------------
@node getLinearForms,getMultiplicity,generatorsOfSpan,cone related functions
@subsubsection getLinearForms
@cindex getLinearForms

@table @code
@item @strong{Syntax:}
@code{getLinearForms(} cone c @code{)}
@*@code{getLinearForms(} polytope p @code{)}
@item @strong{Type:}
intvec
@item @strong{Purpose:}
linear forms of the cone (can be set by setLinearForms); returns empty intmat if not set
@item @strong{Example:}
@smallexample
@c example
intmat M[2][3]=
-1,0,0,
0,-1,0;
cone c=coneViaPoints(M);
getLinearForms(c);
intvec v=1,1,1;
setLinearForms(c,v);
getLinearForms(c);
@c example
@end smallexample
@end table
@c --------------------------------------
@node getMultiplicity,inequalities,getLinearForms,cone related functions
@subsubsection getMultiplicity
@cindex getMultiplicity

@table @code
@item @strong{Syntax:}
@code{getMultiplicity(} cone c @code{)}
@*@code{getMultiplicity(} polytope p @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
getMultiplicity of the cone (can be set by setMultiplicity); returns 1 if not set
@item @strong{Example:}
@smallexample
@c example
intmat M[2][3]=
-1,0,0,
0,-1,0;
cone c=coneViaPoints(M);
getMultiplicity(c);
setMultiplicity(c,3);
getMultiplicity(c);
@c example
@end smallexample
@end table
@c --------------------------------------
@node inequalities,isFullSpace,getMultiplicity,cone related functions
@subsubsection inequalities
@cindex inequalities

@table @code
@item @strong{Syntax:}
@code{inequalities(} cone c @code{)}
@*@code{inequalities(} polytope p @code{)}
@item @strong{Type:}
bigintmat
@item @strong{Purpose:}
inequalities given by the cone or polytope
@item @strong{Example:}
@smallexample
@c example
intmat M1[2][2]=
1,0,
0,1;
cone c1=coneViaPoints(M1);
bigintmat I1=inequalities(c1);
print(I);
intmat M2[1][2]=
1,0;
cone c2=coneViaPoints(M2);
bigintmat I2=inequalities(c2);
print(I2);
// simplex in dimension 2
bigintmat N[3][3] = 1,0,0, 1,1,0, 1,0,1;
polytope p = polytopeViaPoints(N);
inequalities(p);
@c example
@end smallexample
@end table
@c --------------------------------------
@node isFullSpace,isOrigin,inequalities,cone related functions
@subsubsection isFullSpace
@cindex isFullSpace

@table @code
@item @strong{Syntax:}
@code{isFullSpace(} cone c @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
1 iff the cone is the entire ambient space; 0 otherwise
@item @strong{Example:}
@smallexample
@c example
cone c1;
isFullSpace(c1);
intmat M2[2][2]=
1,0,
0,1;
cone c2=coneViaPoints(M2);
isFullSpace(c2);
intmat M3[4][2]=
1,0,
0,1,
-1,0,
0,-1;
cone c3=coneViaPoints(M3);
isFullSpace(c3);
@c example
@end smallexample
@end table
@c --------------------------------------
@node isOrigin,isSimplicial,isFullSpace,cone related functions
@subsubsection isOrigin
@cindex isOrigin

@table @code
@item @strong{Syntax:}
@code{isOrigin(} cone c @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
1 iff the cone is just the origin of the ambient space; 0 otherwise
@item @strong{Example:}
@smallexample
@c example
cone c1; // full cone in zero-dimensional ambient space
isOrigin(c1);
intmat M2[2][2]=
1,0,
0,1;
cone c2=coneViaPoints(M2);
isOrigin(c2);
intmat M3[4][2]=
1,0,
0,1,
-1,0,
0,-1;
cone c3=coneViaPoints(M3);
isOrigin(c3);
@c example
@end smallexample
@end table
@c --------------------------------------
@node isSimplicial,linealityDimension,isOrigin,cone related functions
@subsubsection isSimplicial
@cindex isSimplicial

@table @code
@item @strong{Syntax:}
@code{isSimplicial(} cone c @code{)}
@*@code{isSimplicial(} fan f @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
1 iff the cone resp. fan is simplicial; 0 otherwise
@item @strong{Example:}
@smallexample
@c example
intmat M1[3][3]=
1,0,0,
0,1,0,
0,0,1;
cone c1=coneViaPoints(M1);
isSimplicial(c1);
intmat M2[4][3]=
1,0,0,
0,1,0,
0,0,1,
1,1,-1;
cone c2=coneViaPoints(M2);
isSimplicial(c2);
/***********************/
fan f=emptyFan(3);
isSimplicial(f);
intmat N1[3][3]=
1,0,0,
0,1,0,
0,0,1;
cone d1=coneViaPoints(N1);
insertCone(f,d1);
isSimplicial(f);
intmat N2[4][3]=
1,0,0,
0,1,0,
1,0,-1,
0,1,-1;
cone d2=coneViaPoints(N2);
insertCone(f,d2);
isSimplicial(f);
@c example
@end smallexample
@end table
@c --------------------------------------
@node linealityDimension,linealitySpace,isSimplicial,cone related functions
@subsubsection linealityDimension
@cindex linealityDimension

@table @code
@item @strong{Syntax:}
@code{linealityDimension(} cone c @code{)}
@code{linealityDimension(} fan c @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
dimension of the lineality space of the cone
@item @strong{Example:}
@smallexample
@c example
intmat M1[3][3]=
1,0,0,
0,1,0,
0,0,1;
cone c1=coneViaPoints(M1);
linealityDimension(c1);
intmat M2[4][3]=
1,0,0,
0,1,0,
0,0,1,
-1,0,0;
cone c2=coneViaPoints(M2);
linealityDimension(c2);
@c example
@end smallexample
@end table
@c --------------------------------------
@node linealitySpace,negatedCone,linealityDimension,cone related functions
@subsubsection linealitySpace
@cindex linealitySpace

@table @code
@item @strong{Syntax:}
@code{linealitySpace(} cone c @code{)}
@item @strong{Type:}
cone
@item @strong{Purpose:}
the lineality space of the cone as a new cone
@item @strong{Example:}
@smallexample
@c example
intmat M1[3][3]=
1,0,0,
0,1,0,
0,0,1;
cone c1=coneViaPoints(M1);
cone l1=linealitySpace(c1);
l1;
intmat M2[4][3]=
1,0,0,
0,1,0,
0,0,1,
-1,0,0;
cone c2=coneViaPoints(M2);
cone l2=linealitySpace(c2);
l2;
@c example
@end smallexample
@end table
@c --------------------------------------
@node negatedCone,quotientLatticeBasis,linealitySpace,cone related functions
@subsubsection negatedCone
@cindex negatedCone

@table @code
@item @strong{Syntax:}
@code{negatedCone(} cone c @code{)}
@item @strong{Type:}
cone
@item @strong{Purpose:}
the negated (or negative) of the cone
@item @strong{Example:}
@smallexample
@c example
intmat M[2][2]=
1,0,
0,1;
cone c=coneViaPoints(M);
cone cn=negatedCone(c);
cn;
print(rays(cn));
@c example
@end smallexample
@end table
@c --------------------------------------
@node quotientLatticeBasis,randomPoint,negatedCone,cone related functions
@subsubsection quotientLatticeBasis
@cindex quotientLatticeBasis

@table @code
@item @strong{Syntax:}
@code{quotientLatticeBasis(} cone c @code{)}
@item @strong{Type:}
bigintmat
@item @strong{Purpose:}
quotient of Z^n intersected with the span of the cone with Z^n intersected with its lineality space
@item @strong{Example:}
@smallexample
@c example
intmat M[3][2]=
1,0,
0,1,
-1,0;
cone c=coneViaPoints(M);
bigintmat Q=quotientLatticeBasis(c);
print(Q);
@c example
@end smallexample
@end table
@c --------------------------------------
@node randomPoint,rays,quotientLatticeBasis,cone related functions
@subsubsection randomPoint
@cindex randomPoint

@table @code
@item @strong{Syntax:}
@code{randomPoint(} cone c @code{)}
@item @strong{Type:}
bigintmat
@item @strong{Purpose:}
random point in the relative interior in c
@item @strong{Example:}
@smallexample
@c example
intmat M[3][2]=
1,0,
0,1,
-1,0;
cone c=coneViaPoints(M);
bigintmat Q=randomPoint(c);
print(Q);
@c example
@end smallexample
@end table
@c --------------------------------------
@node rays,relativeInteriorPoint,randomPoint,cone related functions
@subsubsection rays
@cindex rays

@table @code
@item @strong{Syntax:}
@code{rays(} cone c @code{)}
@item @strong{Type:}
bigintmat
@item @strong{Purpose:}
rays of the cone outside the lineality space, rays inside the lineality space will be ignored
@item @strong{Example:}
@smallexample
@c example
intmat M1[2][2]=
1,0,
0,1;
cone c1=coneViaPoints(M1);
bigintmat R1=rays(c1);
print(R1);
intmat M2[3][2]=
1,0,
0,1,
-1,0;
cone c2=coneViaPoints(M2);
bigintmat R2=rays(c2);
print(R2);
@c example
@end smallexample
@end table
@c --------------------------------------
@node relativeInteriorPoint,semigroupGenerator,rays,cone related functions
@subsubsection relativeInteriorPoint
@cindex relativeInteriorPoint

@table @code
@item @strong{Syntax:}
@code{relativeInteriorPoint(} cone c @code{)}
@item @strong{Type:}
intvec
@item @strong{Purpose:}
point in the relative interior of the cone
@item @strong{Example:}
@smallexample
@c example
intmat M1[2][2]=
1,0,
0,1;
cone c1=coneViaPoints(M1);
relativeInteriorPoint(c1);
intmat M2[2][2]=
1,0,
1,1;
cone c2=coneViaPoints(M2);
relativeInteriorPoint(c2);
@c example
@end smallexample
@end table
@c --------------------------------------
@node semigroupGenerator,setLinearForms,relativeInteriorPoint,cone related functions
@subsubsection semigroupGenerator
@cindex semigroupGenerator

@table @code
@item @strong{Syntax:}
@code{semigroupGenerator(} cone c @code{)}
@item @strong{Type:}
intvec
@item @strong{Purpose:}
if dimension(c)=linealityDimension(c)+1, then the quotient lattice of Z^n intersected with the span and Z^n intersected with the lineality space is Z^1 and the class of the cone is a semigroup. returns a generator of that semigroup. (like quotientLatticeBasis(cone c), but as intvec)
@item @strong{Example:}
@smallexample
@c example
intmat M[3][2]=
1,0,
0,1,
-1,0;
cone c=coneViaPoints(M);
semigroupGenerator(c);
@c example
@end smallexample
@end table
@c --------------------------------------
@node setLinearForms,setMultiplicity,semigroupGenerator,cone related functions
@subsubsection setLinearForms
@cindex setLinearForms

@table @code
@item @strong{Syntax:}
@code{setLinearForms(} cone c, intvec linearform @code{)}
@*@code{setLinearForms(} polytope c, intvec linearform @code{)}
@item @strong{Type:}
@item @strong{Purpose:}
adds a linear form to the cone or polytope
@item @strong{Example:}
@smallexample
@c example
intmat M[2][3]=
-1,0,0,
0,-1,0;
cone c=coneViaPoints(M);
getLinearForms(c);
intvec v=1,1,1;
setLinearForms(c,v);
getLinearForms(c);
@c example
@end smallexample
@end table
@c --------------------------------------
@node setMultiplicity,span,setLinearForms,cone related functions
@subsubsection setMultiplicity
@cindex setMultiplicity

@table @code
@item @strong{Syntax:}
@code{setMultiplicity(} cone c, int multiplicity @code{)}
@*@code{setMultiplicity(} polytope c, int multiplicity @code{)}
@item @strong{Type:}
@item @strong{Purpose:}
adds a multiplicity to the cone or polytope
@item @strong{Example:}
@smallexample
@c example
intmat M[2][3]=
-1,0,0,
0,-1,0;
cone c=coneViaPoints(M);
getMultiplicity(c);
setMultiplicity(c,3);
getMultiplicity(c);
@c example
@end smallexample
@end table
@c --------------------------------------
@node span,uniquePoint,setMultiplicity,cone related functions
@subsubsection span
@cindex span

@table @code
@item @strong{Syntax:}
@code{span(} cone c @code{)}
@*@code{span(} polytope p @code{)}
@item @strong{Type:}
bigintmat
@item @strong{Purpose:}
basis of the orthogonal complement of the span of the cone or polytope
@item @strong{Example:}
@smallexample
@c example
intmat M[3][5]=
1,0,0,0,0,
0,1,0,0,0,
0,0,1,0,0;
cone c=coneViaPoints(M);
bigintmat I=span(c);
print(I);
@c example
@end smallexample
@end table
@c --------------------------------------
@node uniquePoint,,span,cone related functions
@subsubsection uniquePoint
@cindex uniquePoint

@table @code
@item @strong{Syntax:}
@code{uniquePoint(} cone c @code{)}
@item @strong{Type:}
intvec
@item @strong{Purpose:}
special-purpose interior point which supports recognition of symmetries among non-intersecting cones (used in implementation of fans)
@item @strong{Example:}
@smallexample
@c example
intmat M1[2][2]=
1,0,
0,1;
cone c1=coneViaPoints(M1);
uniquePoint(c1);
intmat M2[2][2]=
1,0,
1,1;
cone c2=coneViaPoints(M2);
uniquePoint(c2);
@c example
@end smallexample
@end table
@c ---------------------------------------
@node fan, polytope, cone, Data types
@section fan
@cindex fan

In order to use convex objects in Singular, Singular has to be build from sources
together with gfanlib, a C++ library for convex geometry by Anders N. Jensen.
Please check the readme file for installation instructions.

A polyhedral fan is a collection of cones closed under taking intersections and
faces.

@smallexample
  fan f;                              // ambient dim 0, no cones, lineality
                                      // space = ambient space
  fan f = emptyFan(int n);            // ambient dim = n, no cones,
                                      // symmetry subgroup = <e>
  fan f = n;                          // synonymous convenience method for
                                      // 'fan f = emptyFan(n)'
  fan f = emptyFan(
                 optional intmat G);  // symmetry group generated by rows of
                                      // G; ambient dim = number of columns
                                      // of G
            // Here a row r = r_1, ...r_n represents the permutation
            // which takes i to r_i. SINGULAR will check for the validity
            // of the provided rows, i.e. whether @{r_1,...,r_n@} = @{1,...,n@}
  fan f = fullFan(int n);             // ambient dim = n, the fan consists of
                                      // one cone which equals the ambient
                                      // space, symmetry subgroup = <e>
  fan f = fullFan(
                 optional intmat G);  // symmetry group generated by rows of
                                      // G; ambient dim = number of columns
                                      // of G; the fan consists of one cone
                                      // which equals the ambient space
@end smallexample

@menu
* fan related functions::
@end menu
@c --------------------------------------------------------------------
@node fan related functions,,,fan
@subsection fan related functions
@cindex fan related functions

See also @ref{ambientDimension},
@ref{codimension},
@ref{linealityDimension},
@ref{isSimplicial}.

@menu
* containsInCollection::
* emptyFan::
* fanViaCones::
* fullFan::
* fVector::
* getCone::
* insertCone::
* isCompatible::
@c * isComplete::
* isPure::
* nmaxcones::
* ncones::
* numberOfConesOfDimension::
* removeCone::
@end menu

@c --------------------------------------------------------------------
@node containsInCollection,emptyFan,,fan related functions
@subsubsection containsInCollection
@cindex containsInCollection

@table @code
@item @strong{Syntax:}
@code{containsInCollection(} fan f, cone c @code{)}
@item @strong{Type:}
cone
@item @strong{Purpose:}
1 iff c is contained in the collection of cones that is f; 0 otherwise
@item @strong{Example:}
@smallexample
@c example
fan f=emptyFan(2);
intmat M[2][2]=
1,0,
0,1;
cone c=coneViaPoints(M);
containsInCollection(f,c);
insertCone(f,c);
containsInCollection(f,c);
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------
@node emptyFan,fanViaCones,containsInCollection,fan related functions
@subsubsection emptyFan
@cindex emptyFan

@table @code
@item @strong{Syntax:}
@code{emptyFan(} int d @code{)}
@item @strong{Type:}
fan
@item @strong{Purpose:}
empty fan in ambient dimension d
@item @strong{Example:}
@smallexample
@c example
fan f=emptyFan(2);
f;
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------
@node fanViaCones,fullFan,emptyFan,fan related functions
@subsubsection fanViaCones
@cindex fanViaCones

@table @code
@item @strong{Syntax:}
@code{fanViaCones(} list Cones @code{)}
@*@code{fanViaCones(} cone c_1,...,cone c_n @code{)}
@item @strong{Type:}
fan
@item @strong{Purpose:}
fan generated by the cones supplied, either via a list or via single arguments
@item @strong{Example:}
@smallexample
@c example
intmat M[2][2]=1,0,0,1;
cone c=coneViaPoints(M);
intmat N[2][2]=1,0,0,-1;
cone d=coneViaPoints(N);
fan f=fanViaCones(c,d);
f;
list L=c,d;
fan g=fanViaCones(L);
g;
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------
@node fullFan,fVector,fanViaCones,fan related functions
@subsubsection fullFan
@cindex fullFan

@table @code
@item @strong{Syntax:}
@code{fullFan(} int d @code{)}
@item @strong{Type:}
fan
@item @strong{Purpose:}
full fan in ambient dimension d
@item @strong{Example:}
@smallexample
@c example
fan f=fullFan(2);
f;
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------
@node fVector,getCone,fullFan,fan related functions
@subsubsection fullFan
@cindex fVector

@table @code
@item @strong{Syntax:}
@code{fVector(} fan f @code{)}
@item @strong{Type:}
intvec
@item @strong{Purpose:}
F-Vector of the fan
@item @strong{Example:}
@smallexample
@c example
fan f=emptyFan(2);
fVector(f);
intmat M[2][2]=1,0,0,1;
cone c=coneViaPoints(M);
insertCone(f,c);
fVector(f);
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------
@node getCone,insertCone,fVector,fan related functions
@subsubsection getCone
@cindex getCone

@table @code
@item @strong{Syntax:}
@code{getCone(} fan f, int dimension, int index @code{)}
@*@code{getCone(} fan f, int dimension, int index, int orbit @code{)}
@*@code{getCone(} fan f, int dimension, int index, int orbit, int maximal @code{)}
@item @strong{Type:}
cone
@item @strong{Purpose:}
cone (orbit=0) or orbit (orbit=1) of a certain index (ranges from 1 to numberOfConesOfDimension(f,*,*,*)) in a given dimension; if maximal=0, all cones and orbits are considered, if maximal=1, only maximal cones and orbits are considered; the default flags for orbit and maximal is 0.
@item @strong{Example:}
@smallexample
@c example
intmat M[3][3]=
1,0,0,
0,1,0,
0,0,1;
cone c=coneViaPoints(M);
fan f=emptyFan(3);
insertCone(f,c);
getCone(f,2,1,0,0);
getCone(f,2,2,0,0);
getCone(f,2,3,0,0);
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------
@node insertCone,isCompatible,getCone,fan related functions
@subsubsection insertCone
@cindex insertCone

@table @code
@item @strong{Syntax:}
@code{insertCone(} fan f, cone c @code{)}
@*@code{insertCone(} fan f, cone c, int check @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
inserts the cone into the fan; checks for compatibility beforehand unless check is passed and equal 0
@item @strong{Example:}
@smallexample
@c example
fan f=emptyFan(3);
f;
intmat M[3][3]=
1,0,0,
0,1,0,
0,0,1;
cone c=coneViaPoints(M);
insertCone(f,c);
f;
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------
@node isCompatible,isPure,insertCone,fan related functions
@c @node isCompatible,isComplete,insertCone,fan related functions
@subsubsection isCompatible
@cindex isCompatible

@table @code
@item @strong{Syntax:}
@code{isCompatible(} fan f, cone c @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
1 iff cone is compatible with the fan; 0 otherwise
@item @strong{Example:}
@smallexample
@c example
fan f=emptyFan(3);
intmat M1[3][3]=
1,0,0,
0,1,0,
0,0,1;
cone c1=coneViaPoints(M1);
isCompatible(f,c1);
insertCone(f,c1);
intmat M2[3][3]=
1,1,1,
1,0,0,
0,1,0;
cone c2=coneViaPoints(M2);
isCompatible(f,c2);
intmat M3[3][3]=
1,0,0,
0,1,0,
0,0,-1;
cone c3=coneViaPoints(M3);
isCompatible(f,c3);
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------
@c @node isComplete,isPure,isCompatible,fan related functions
@c @subsubsection isComplete
@c @cindex isComplete

@c @table @code
@c @item @strong{Syntax:}
@c @code{isComplete(} fan f @code{)}
@c @item @strong{Type:}
@c int
@c @item @strong{Purpose:}
@c 1 iff the fan is complete; 0 otherwise
@c @item @strong{Example:}
@c @smallexample
@c @c example
@c fan f=fullFan(2);
@c isComplete(f);
@c fan g=emptyFan(2);
@c intmat M1[2][2]=
@c 1,0,
@c 0,1;
@c cone c1=coneViaPoints(M1);
@c insertCone(g,c1);
@c isComplete(g);
@c intmat M2[2][2]=
@c 1,0,
@c -1,-1;
@c cone c2=coneViaPoints(M2);
@c insertCone(g,c2);
@c isComplete(g,c2);
@c intmat M3[2][2]=
@c -1,-1,
@c 0,1;
@c cone c3=coneViaPoints(M3);
@c insertCone(g,c3);
@c isComplete(g,c3);
@c @c example
@c @end smallexample
@c @end table
@c --------------------------------------------------------------------
@node isPure,nmaxcones,isCompatible,fan related functions
@c @node isPure,nmaxcones,isComplete,fan related functions
@subsubsection isPure
@cindex isPure

@table @code
@item @strong{Syntax:}
@code{isPure(} fan f@code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
1 iff the fan is pure; 0 otherwise
@item @strong{Example:}
@smallexample
@c example
fan f=fullFan(2);
isPure(f);
fan g=emptyFan(2);
intmat M1[2][2]=
1,0,
0,1;
cone c1=coneViaPoints(M1);
insertCone(g,c1);
isPure(g);
intmat M2[1][2]=
0,-1;
cone c2=coneViaPoints(M2);
insertCone(g,c2);
isPure(g,c2);
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------
@node nmaxcones,ncones,isPure,fan related functions
@subsubsection nmaxcones
@cindex nmaxcones

@table @code
@item @strong{Syntax:}
@code{nmaxcones(} fan f @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
number of maximal cones in f
@item @strong{Example:}
@smallexample
@c example
fan f=emptyFan(3);
nmaxcones(f);
intmat M1[3][3]=
1,0,0,
0,1,0,
0,0,1;
cone c1=coneViaPoints(M1);
insertCone(f,c1);
nmaxcones(f);
intmat M2[2][3]=
1,0,0,
0,-1,0;
cone c2=coneViaPoints(M2);
insertCone(f,c2);
nmaxcones(f);
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------
@node ncones,numberOfConesOfDimension,nmaxcones,fan related functions
@subsubsection ncones
@cindex ncones

@table @code
@item @strong{Syntax:}
@code{ncones(} fan f @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
number of cones in f
@item @strong{Example:}
@smallexample
@c example
fan f=emptyFan(3);
ncones(f);
intmat M1[3][3]=
1,0,0,
0,1,0,
0,0,1;
cone c1=coneViaPoints(M1);
insertCone(f,c1);
ncones(f);
intmat M2[2][3]=
1,0,0,
0,-1,0;
cone c2=coneViaPoints(M2);
insertCone(f,c2);
ncones(f);
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------
@node numberOfConesOfDimension,removeCone,ncones,fan related functions
@subsubsection numberOfConesOfDimension
@cindex numberOfConesOfDimension

@table @code
@item @strong{Syntax:}
@code{numberOfConesOfDimension(} fan f, int dimension, int orbit, int maximal @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
number of cones (orbit=0) or orbits (orbit=1) of a given dimension; if maximal=0, then all cones are considered, if maximal=1, only maximal cones are considered
@item @strong{Example:}
@smallexample
@c example
fan f=emptyFan(3);
ncones(f);
intmat M[3][3]=
1,0,0,
0,1,0,
0,0,1;
cone c=coneViaPoints(M);
insertCone(f,c);
numberOfConesOfDimension(f,0,0,0);
numberOfConesOfDimension(f,0,0,1);
numberOfConesOfDimension(f,1,0,0);
numberOfConesOfDimension(f,0,0,1);
numberOfConesOfDimension(f,2,0,0);
numberOfConesOfDimension(f,2,0,1);
numberOfConesOfDimension(f,3,0,0);
numberOfConesOfDimension(f,3,0,1);
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------
@node removeCone,,numberOfConesOfDimension,fan related functions
@subsubsection removeCone
@cindex removeCone

@table @code
@item @strong{Syntax:}
@code{removeCone(} fan f, cone c @code{)}
@*@code{removeCone(} fan f, cone c, int check @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
removes the cone from the fan; checks for compatibility beforehand unless check is passed and equal 0
@item @strong{Example:}
@smallexample
@c example
intmat M[2][2]=1,0,0,1;
intmat N[2][2]=1,0,1,-1;
cone c=coneViaPoints(M);
cone d=coneViaPoints(N);
fan f=emptyFan(2);
insertCone(f,c);
insertCone(f,d);
f;
removeCone(f,c);
f;
@c example
@end smallexample
@end table
@c ---------------------------------------
@node polytope, pyobject, fan, Data types
@section polytope
@cindex polytope

In order to use convex objects in Singular, Singular has to be build from sources
together with gfanlib, a C++ library for convex geometry by Anders N. Jensen.
Please check the readme file for installation instructions.

In R^n, a rational convex polytope (in short ``polytope'') is a set of points
satisfying a system rational, and hence integer, linear inequalities and equations.
It is internally realised as a cone in R^(n+1) intersected with the hyperplane,
in which the first coordinate equals 1.

@menu
* polytopeViaPoints::
* polytopeViaInequalities::
* polytope related functions::
@end menu
@c --------------------------------------------------------------------------------
@node polytopeViaPoints,polytopeViaInequalities,,polytope
@subsection polytopeViaPoints
@cindex polytopeViaPoints
@table @code
@item @strong{Syntax:}
@code{polytopeViaPoints(} intmat V @code{)}
@*@code{polytopeViaPoints(} intmat V, int flags @code{)}
@item @strong{Type:}
polytope
@item @strong{Purpose:}
polytope which is the intersection of the cone generated by the row vectors of V
with the hyperplane, in which the first coordinate equals 1;
flags may be 0 or 1,
if flags is 1, then program assumes that each row vector of M generates a ray in the cone,
if flags is 0, then program computes that information itself.
@item @strong{Example:}
@smallexample
@c example
// This is a polytope in R^2 generated by (0,0), (1,0), (0,1), (0,0);
intmat V[4][3]=
1,0,0,
1,1,0,
1,0,1,
1,1,1;
polytope p=polytopeViaPoints(V);
p;
// This is a polytope in R^2 generated by (1/2,2/3), (3/4,4/5), (5/6,6/7):
intmat V[3][3]=
6,3,4,
20,15,16,
42,35,36;
polytope p=polytopeViaPoints(V);
p;
// This polytope is the positive orthant in R^2:
// (0,1,0) and (0,0,1) imply that the polytope is unbounded in that direction
intmat V[3][3]=
1,0,0,
0,1,0,
0,0,1;
polytope p=polytopeViaPoints(V);
p;
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------------------
@node polytopeViaInequalities,polytope related functions,polytopeViaPoints,polytope
@subsection polytopeViaInequalities
@cindex polytopeViaInequalities
@table @code
@item @strong{Syntax:}
@code{polytopeViaInequalities(} intmat IE @code{)}
@*@code{polytopeViaInequalities(} intmat IE, intmat E @code{)}
@*@code{polytopeViaInequalities(} intmat IE, intmat E, int flags @code{)}
@item @strong{Type:}
cone
@item @strong{Purpose:}
cone consisting of all points x, such that IE*x >= 0 in each component
and (if stated) E*x = 0;
flags may range between 0,..,3 defining an upper and lower bit
(0=0*2+0, 1=0*2+1, 2=1*2+0, 3=1*2+1),
if higher bit is 1, then program assumes each inequality yields a facet,
if lower bit is 1, then program assumes the kernel of E is the span of the cone,
if either bit is 0, then program computes the information itself.
@item @strong{Example:}
@smallexample
@c example
intmat IE[2][3]=
1,0,0,
0,1,0;
intmat E[1][3]=
0,0,1;
polytope p=polytopeViaInequalities(IE,E);
p;
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------
@node polytope related functions,,polytopeViaInequalities,polytope
@subsection polytope related functions
@cindex polytope related functions

See also @ref{ambientDimension},
@ref{codimension},
@ref{dimension},
@ref{equations},
@ref{facets},
@ref{inequalities},
@ref{getLinearForms},
@ref{getMultiplicity},
@ref{setLinearForms},
@ref{setMultiplicity}.

@menu
* dualPolytope::
* newtonPolytope::
* vertices::
@end menu

@c --------------------------------------------------------------------
@node dualPolytope,newtonPolytope,,polytope related functions
@subsubsection dualPolytope
@cindex dualPolytope

@table @code
@item @strong{Syntax:}
@code{dualPolytope(} polytope p @code{)}
@item @strong{Type:}
polytope
@item @strong{Purpose:}
Newton polytope of f
@item @strong{Example:}
@smallexample
@c example
intmat M[4][2]=
0,0,
1,0,
0,1,
1,1;
polytope p=polytopeViaPoints(M);
dualPolytope(p);
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------
@node newtonPolytope,vertices,dualPolytope,polytope related functions
@subsubsection newtonPolytope
@cindex newtonPolytope

@table @code
@item @strong{Syntax:}
@code{newtonpolytope(} poly f @code{)}
@item @strong{Type:}
polytope
@item @strong{Purpose:}
Newton polytope of f
@item @strong{Example:}
@smallexample
@c example
ring r;
poly f=x+y+z;
polytope p=newtonPolytope(f);
p;
@c example
@end smallexample
@end table
@c --------------------------------------------------------------------
@node vertices,,newtonPolytope,polytope related functions
@subsubsection vertices
@cindex vertices

@table @code
@item @strong{Syntax:}
@code{vertices(} polytope p @code{)}
@item @strong{Type:}
intmat
@item @strong{Purpose:}
vertices of p
@item @strong{Example:}
@smallexample
@c example
intmat M[4][3]=
1,0,0,
1,2,0,
1,0,2,
1,2,2,
1,1,1;
polytope p=polytopeViaPoints(M);
vertices(p);
@c example
@end smallexample
@end table
