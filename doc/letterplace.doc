@comment -*-texinfo-*-
@comment this file contains the mathematical background of Singular:Letterplace

@c The following directives are necessary for proper compilation
@c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
@c is wrapped in `@ignore' and `@end ignore' it does not harm `tex' or
@c `makeinfo' but is a great help in editing this file (emacs
@c ignores the `@ignore').
@ignore
%**start
@end ignore

@node LETTERPLACE, , ,Non-commutative subsystem
@section LETTERPLACE
@cindex LETTERPLACE
@cindex Letterplace

@ifhtml
@html
<CENTER>
<A HREF="https://www.singular.uni-kl.de">
<IMG SRC="letterplace.jpg" ALT="Singular:Letterplace logo"></A><br>
</CENTER>
<h3> A Subsystem for Non-commutative Finitely Presented Algebras </h3>
<p></p>
@end html
@end ifhtml

This section describes mathematical notions and definitions used in
the @sc{Letterplace} subsystem of @sc{Singular}.

All algebras are assumed to be associative @math{K}-algebras for some field @math{K}.

@table @strong
@item @strong{What is and what does @sc{Letterplace}?}

What is @sc{Letterplace}? It is a subsystem of @sc{Singular}, providing the
manipulations and computations within free associative algebras 
over rings 
@math{R} @math{<x_1},@dots{},@math{x_n >},
where the coefficient domain @math{R} is either a ring @math{Z} or 
a field, supported by @sc{Singular}.
@sc{Letterplace} can perform computations
also in the factor-algebras of the above by two-sided ideals.

Free algebras are internally represented in @sc{Singular} as so-called Letterplace rings.
Each such ring is constructed from a commutative ring @math{R}[ @math{x_1},@dots{},@math{x_n} ]
and a @strong{degree (length) bound} @math{d}.

This encodes a sub-@math{K}-vector space (also called a filtered part) of @math{K} @math{<x_1},@dots{},@math{x_n >},
spanned by all monomials of @strong{length} at most @math{d}. Analogously for free @math{R}-submodules of a free 
@math{R}-module.

Within such a construction we offer the computations of Groebner (also known as Groebner-Shirshov) bases, 
normal forms, syzygies and many more.
We address both ideals and submodules of the free bimodule of the fixed rank.

A variety of monomial and module orderings is supported, including elimination orderings for both
variables and bimodule components. A monomial ordering has to be a well-ordering.

@sc{Letterplace} works with every field, supported by @sc{Singular}, and with the coefficient ring @math{Z}.
Note, that the elements of the coefficient field (or a ring) mutually commute with all variables.
@end table

@menu
* Examples of use of Letterplace::
* Functionality and release notes of Letterplace::
* References and history of Letterplace::
@end menu

@c ---------------------------------------------------------------------------
@node Examples of use of Letterplace
@subsection Examples of use of @sc{Letterplace}
@cindex Examples of use of Letterplace

First, define a commutative ring @math{K[X]} in @sc{Singular}, equipped with a monomial well-ordering
and call it, say, @code{r}.

Then, decide what should be the degree (length) bound @math{d},
that is how long may the words (monomials in the free algebra) become
and run the procedure @code{freeAlgebra(r, d)}.

This procedure creates a commutative Letterplace ring with an ordering,
corresponding to the one in the original commutative ring @math{K[X]}, see @ref{Monomial orderings on free algebras}.

In this @math{K}-algebra, define an ideal @code{I} as a list of polynomials in the
free algebra (@code{x*y} and @code{y*x} are different) and run, for example, @code{twostd (letterplace)}.
The answer is a two-sided Groebner bases of the two-sided ideal @math{I}.
Then, we want to compute the two-sided normal form of @code{xyzy} with respect to @code{J} with the
function @code{reduce}.

We illustrate the approach with the following example:

@smallexample
@c example
LIB "freegb.lib";
ring r = 0,(x,y,z),dp; // the ordering on the free algebra will be degree right lex
ring R = freeAlgebra(r, 4);  // 4 the is degree (length) bound; 
ideal I = x*y + y*z, x*x + x*y - z; // define a non-graded ideal
ideal J = twostd(I);
J;
poly p = reduce(x*y*z*y,J);
p; // since p!=0, x*y*z*y is not contained in J

// Now, we introduce a factor algebra @math{K<x,y,z>/J} of type @code{qring},
// and demonstrate @code{reduce} and @code{rightstd} functions:

qring Q = J; // J is a Groebner basis
poly p = reduce(x*x, twostd(0)); // the canonical representative of x*x in Q
p;
rightstd(ideal(p)); // right Groebner basis of the right ideal, generated by p in Q
@c example
@end smallexample

See @ref{Functions (letterplace)} for the list of all available kernel functions.

There are various conversion routines in the library @code{freegb_lib} (see @ref{freegb_lib}).
Many algebras are predefined in the library @code{fpalgebras_lib} (see @ref{fpalgebras_lib}).
Important ring-theoretic properties can be established with the help of the library @code{fpaprops_lib} (see @ref{fpaprops_lib}),
while K-dimension and monomial bases and Hilbert data - with the help of the library @code{fpadim_lib} (see @ref{fpadim_lib}).
We work further on implementing more algorithms for non-commutative ideals and modules over free associative algebra.

@c ---------------------------------------------------------------------------
@node Functionality and release notes of Letterplace
@subsection Functionality and release notes of @sc{Letterplace}
@cindex Functionality and release notes of Letterplace

With the present functionality it is possible to compute two-sided Groebner basis
of an arbitrary two-sided ideal in a free associative algebra up to a given degree.
The weights of variables are determined by the current monomial ordering.

Restrictions/conventions of the @sc{Letterplace} subsystem:
@itemize
@item Since free algebra is not Noetherian, one has to define an explicit degree (length) bound,
up to which a partial Groebner basis will be computed. Note, that @code{freeAlgebra (letterplace)} call stores the bound
in the structure of the ring it creates. Thus running @code{twostd (letterplace)} or @code{rightstd (letterplace)} in such a
ring does not require or allow the degree bound in its argument.
@item The options @code{redSB, redTail} are effective for computations involving Groebner bases,
@item The options @code{prot, mem} are effective for the whole @sc{Letterplace} subsystem.
@end itemize

Operations for polynomials in Letterplace rings are @code{+} (addition),
@code{-} (subtraction), @code{*} (multiplication) and @code{^} (power).

@c Functions for objects from Letterplace rings are: @ref{twostd (letterplace)}, @ref{rightstd (letterplace)}, @ref{reduce (letterplace)}.
 
The functions @ref{bracket}, @ref{maxideal} and @ref{std} (an alias for @ref{twostd (letterplace)}) also work within letterplace rings:

@smallexample
@c example
LIB "freegb.lib";
ring r = 0,(x,y,z),dp; // the ordering will be degree right lex
ring R = freeAlgebra(r, 5);  // degree (length) bound is 5
// maxideal in a letterplace ring:
print(matrix(maxideal(2))); // all monomials of length 2
// bracket in a letterplace ring:
bracket(x,y);
poly f = x*x + x*y - z;
bracket(f,x);
bracket(f,x,2);
@c example
@end smallexample

Further functionality is provided in the libraries for the @sc{Letterpace} subsystem: see @ref{LETTERPLACE libraries}
for details.

In the @ref{freegb_lib} one finds e.g. Letterplace arithmetics procedures, conversion tools,
procedures for creating some common ideals of relations as well as the normal form
procedure, providing effective ideal membership test.

The @ref{fpadim_lib} contains procedures for computations with vector space basis
of a factor algebra including finiteness check and dimension computation.

The @ref{fpaprops_lib} contains procedures for determining important ring-theoretic properties
including Gelfand-Kirillov dimension.

The @ref{fpalgebras_lib} contains procedures for the generation of various algebras, including group algebras of finitely presented groups in the Letterplace ring.

The @ref{ncfactor_lib} contains the procedure @code{ncfactor} for factorizing polynomials in the Letterplace ring.

@c ref
See
@ref{bracket};
@ref{maxideal};
@ref{reduce (letterplace)};
@ref{rightstd (letterplace)};
@ref{std (letterplace)};
@ref{twostd (letterplace)}.
@c ref

@c ---------------------------------------------------------------------------
@node References and history of Letterplace
@subsection References and history of @sc{Letterplace}
@cindex References and history of Letterplace

@sc{Letterplace} has undergone several stages of development.

The first one, the pure Letterplace implementation for homogeneous
ideals, was created by V. Levandovskyy and H. Schoenemann in 2007-2009.

Later in 2010-2014, experiments with advanced
(among other, with shift-invariant) data structures were performed by
V. Levandovskyy, B. Schnitzler and G. Studzinski, and new libraries
for @math{K}-dimension, @math{K}-bases, and Ufnarovskij graph were written.

The next stage started in 2017, when K. Abou Zeid joined the team of
H. Schoenemann and V. Levandovskyy. Those recent activities led to the change
of interface to the one, usual in the free algebra. The Letterplace data structure
is still at heart of the implementation, though not explicitly visible by default.
It has been generalized to support @math{Z} as coefficient ring, to support
bimodules and compute syzygies and lifts, to name a few.
L. Schmitz and T. Metzlaff (RWTH Aachen) contributed to the development.

References:

[LL09]:  Roberto La Scala and Viktor Levandovskyy, "Letterplace ideals and non-commutative Groebner bases", Journal of Symbolic Computation, Volume 44, Issue 10, October 2009, Pages 1374-1393, see @url{http://dx.doi.org/10.1016/j.jsc.2009.03.002}.

[LL13]: Roberto La Scala and Viktor Levandovskyy, "Skew polynomial rings, Groebner bases and the letterplace embedding of the free associative algebra", Journal of Symbolic Computation, Volume 48, Issue 1, January 2013, Pages 1374-1393, see @url{http://dx.doi.org/10.1016/j.jsc.2012.05.003} and also @url{http://arxiv.org/abs/1009.4152}.

[LSS13]: Viktor Levandovskyy, Grischa Studzinski and Benjamin Schnitzler , "Enhanced Computations of Groebner Bases in Free Algebras as a New Application of the Letterplace Paradigm", Proc. ISSAC 2013, ACM Press, 259-266, see @url{https://doi.org/10.1145/2465506.2465948}.

[L14]: Roberto La Scala, "Extended letterplace correspondence for nongraded noncommutative ideals and related algorithms", International Journal of Algebra and Computation, Volume 24, Number 08, Pages 1157-1182, 2014, see also @url{https://doi.org/10.1142/S0218196714500519}.

@c ---------------------------------------------------------------------------

@node Functions BR_LETTERPLACE_BR 
@section Functions BR_LETTERPLACE_BR
@cindex Functions BR_LETTERPLACE_BR
@cindex commands BR_LETTERPLACE_BR

This chapter gives a complete reference of all functions and commands of the @sc{Letterplace} kernel, i.e. all built-in commands
(for the numerous @sc{Letterplace} libraries see @ref{LETTERPLACE libraries}).

The general syntax of a function is
@format
                   [target =] function_name (<arguments>);
@end format


Note, that both @strong{Control structures} and @strong{System variables} of
@sc{Letterplace} are the same as of @sc{Singular} (see @ref{Control structures}, @ref{System variables}).

@menu
* freeAlgebra BR_LETTERPLACE_BR::
* ncgen ::
* lift BR_LETTERPLACE_BR:: 
* liftstd BR_LETTERPLACE_BR:: 
* reduce BR_LETTERPLACE_BR::
* rightstd BR_LETTERPLACE_BR::
* std BR_LETTERPLACE_BR::
* syz BR_LETTERPLACE_BR::
* twostd BR_LETTERPLACE_BR::
@end menu

@c ------------------------------
@node freeAlgebra BR_LETTERPLACE_BR, ncgen, Functions BR_LETTERPLACE_BR, Non-commutative subsystem
@subsection freeAlgebra BR_LETTERPLACE_BR
@cindex freeAlgebra BR_LETTERPLACE_BR

@table @code
@item @strong{Syntax:}
@*@code{freeAlgebra(} ring_expression r, int_expression d @code{)}
@item @strong{Type:}
ring
@item @strong{Purpose:}
Creates a free (letterplace) ring with the variables of the ring @code{r} up to
the degree (length) bound @code{d}, with the monomial ordering, determined
by those on the ring @code{r}.
@item @strong{Note:}
A letterplace ring has an attribute called @code{isLetterplaceRing}, which is zero
for non-letterplace rings and contains the number of variables of the free algebra
it encodes, otherwise.
@item @strong{Example:}
@smallexample
@c example
LIB "freegb.lib";
ring r = 0,(x,y,z),dp;
ring R = freeAlgebra(r, 7); // this ordering is degree right lex
R;
attrib(R,"isLetterplaceRing");
ring r2 = 0,(x,y,z),lp;
ring R2 = freeAlgebra(r2, 5); // note, that this ordering is NOT left or right lex
R2;
attrib(R2,"isLetterplaceRing");
@c example
@end smallexample
@end table
@c ref
See @ref{Monomial orderings on free algebras}.
@c ref

@c ----------------------------------------
@node ncgen, lift BR_LETTERPLACE_BR, freeAlgebra BR_LETTERPLACE_BR, Functions BR_LETTERPLACE_BR
@subsection ncgen
@cindex ncgen

@table @code
@item @strong{Syntax:}
@code{ncgen (} int_expression @code{)}
@item @strong{Type:}
poly
@item @strong{Purpose:}
returns the i-th free non-commutative generator of a free bimodule.
@item @strong{Note:}
@code{ncgen} in bimodules is used together with the commutative @code{gen},
which encodes the component or the position in a vector. 
@item @strong{Example:}
@smallexample
@c example
  ring r= 0,(x,y),dp;
  ring R = freeAlgebra(r,4,3); // R supports free bimodule up to rank 3
  typeof(ncgen(2));
  vector v = [ncgen(1)*x, x*ncgen(2), y*ncgen(3)*x];
  v;
  print(v*x);
  print(x*v);
@c example
@end smallexample
@end table
@c ref
See
@ref{freeAlgebra};
@ref{module};
@ref{vector}.

@c -------------------------------------------------
@node lift BR_LETTERPLACE_BR, liftstd BR_LETTERPLACE_BR, ncgen, Functions BR_LETTERPLACE_BR
@subsection lift  BR_LETTERPLACE_BR
@cindex lift  BR_LETTERPLACE_BR
@table @code
@item @strong{Syntax:}
@code{lift (} ideal_expression@code{,} subideal_expression @code{)}
@*@code{lift (} module_expression@code{,} submodule_expression @code{)}
@item @strong{Type:}
matrix
@item @strong{Purpose:}
computes the transformation matrix which expresses the generators of a
subbimodule in terms of the generators of a bimodule.
@* More precisely, if @code{m} is the
module (or ideal), @code{sm} the submodule (or ideal),
and @code{T} the transformation matrix returned by
lift, then the substitution of each @code{ncgen(i)} in 
@code{T} by the @code{m[i]} delivers a matrix, say @code{N}.
The @code{i}-th generator of @code{sm} is equal to the sum of
elements in the @code{i}-th column of @code{N}.
@item @strong{Note:}
Gives a warning if @code{sm} is not a submodule.
@item @strong{Note:}
The procedure @ref{testLift} can be used for testing the result.
@item @strong{Example:}
@smallexample
@c example
LIB "freegb.lib";
ring r = 0,(x,y),(c,Dp);
ring R = freeAlgebra(r, 7, 2);
ideal I = std(x*y*x + 1); 
print(matrix(I));
ideal SI = x*I[1]*y + y*x*I[2], I[1]*y*x + I[2]*y;
matrix T = lift(I, SI); 
print(T);
print(matrix(SI)); // the original generators
print(matrix(testLift(I,T))); // test for the result of lift
@c example
@end smallexample
@end table
@c ref
See
@ref{ideal};
@ref{module};
@ref{twostd (letterplace)};
@ref{syz (letterplace)};
@ref{liftstd (letterplace)}.
@c ref
@c -----------------------------------------
@node liftstd BR_LETTERPLACE_BR, reduce BR_LETTERPLACE_BR, lift BR_LETTERPLACE_BR, Functions BR_LETTERPLACE_BR
@subsection liftstd BR_LETTERPLACE_BR
@cindex liftstd BR_LETTERPLACE_BR
@table @code
@item @strong{Syntax:}
@code{liftstd (} ideal_expression@code{,} matrix_name @code{)}
@*@code{liftstd (} module_expression@code{,} matrix_name @code{)}
@*@code{liftstd (} ideal_expression@code{,} matrix_name@code{,} module_name @code{)}
@*@code{liftstd (} module_expression@code{,} matrix_name@code{,} module_name @code{)}
@item @strong{Type:}
ideal or module
@item @strong{Purpose:}
returns a Groebner basis of a two-sided ideal or a bimodule and 
the transformation matrix from the given ideal, resp.@: module, to the 
Groebner basis from the output.
@*That is, if  @code{m} is the
module (or ideal), @code{sm} the submodule (or ideal),
and @code{T} the transformation matrix returned by
lift, then the substitution of each @code{ncgen(i)} in 
@code{T} by the @code{m[i]} delivers a matrix, say @code{N}.
The @code{i}-th generator of @code{sm} is equal to the sum of
elements in the @code{i}-th column of @code{N}.
@*In an optional third argument the syzygy bimodule will be returned.
@item @strong{Example:}
@smallexample
@c example
LIB "freegb.lib";
ring r = 0,(x,y),(c,Dp);
ring R = freeAlgebra(r, 7, 2);
ideal I = x*y*x + 1; 
matrix T; module S;
ideal SI = liftstd(I,T,S); 
print(matrix(SI)); 
print(matrix(testLift(I,T))); // test for the result of lift
S; // the bisyzygy module of I
testSyz(I,S); 
@end smallexample
@end table
@c ref
See
@ref{ideal};
@ref{twostd (letterplace)};
@ref{syz (letterplace)};
@ref{lift (letterplace)}.

@c ------------------------------
@node reduce BR_LETTERPLACE_BR, rightstd BR_LETTERPLACE_BR, liftstd BR_LETTERPLACE_BR, Functions BR_LETTERPLACE_BR
@subsection reduce BR_LETTERPLACE_BR
@cindex reduce BR_LETTERPLACE_BR
@cindex NF BR_LETTERPLACE_BR
@table @code
@item @strong{Syntax:}
@code{reduce (} poly_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} poly_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} vector_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} vector_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} vector_expression@code{,} module_expression@code{,} int_expression @code{)}
@*@code{reduce (} ideal_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} ideal_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@item @strong{Type:}
the type of the first argument
@item @strong{Purpose:}
reduces a polynomial, vector, or ideal (the first argument) to its @strong{two-sided} normal form with
respect to the second argument, meant to be an ideal, represented by its two-sided Groebner basis
(otherwise, the result may have no meaning).
@*returns 0 if and only if the polynomial (resp.@: vector, ideal)
is an element (resp.@: subideal) of the ideal.
@*The third (optional) argument of type int modifies the behavior:
@itemize
@item 0
default
@item 1
consider only the leading term and do no tail reduction.
@item 2
tail reduction:n the local/mixed ordering case: reduce also with bad ecart
@item 4
reduce without division, return possibly a non-zero constant multiple of the remainder
@end itemize
@item @strong{Note:}
The commands @code{reduce} and @code{NF} are synonymous.
@item @strong{Note:}
A two-sided Groebner presentation of a polynomial with respect to a two-sided ideal
can be computed by the procedure @ref{lpDivision} from @ref{freegb_lib}.
@item @strong{Example:}
@smallexample
@c example
LIB "freegb.lib";
ring r = 0,(x,y),dp;
ring R = freeAlgebra(r,5);
ideal I = x*x + y*y - 1; // 2D sphere
ideal J = twostd(I); // computes a two-sided Groebner basis
J; // it is finite and nice
poly g = x*y*y - y*y*x;
reduce(g,J); // 0, hence g belongs to J
poly h = x*y*y*x - y*x*x;
reduce(h,J); // the rest of two-sided division of h by J
qring Q = J; // swith to K<x,y>/J
reduce(x*y*y - y*y*x,twostd(0)); //image of g above
reduce(x*y*y*x - y*x*x,std(0)); //image of h above
@c example
@end smallexample
@end table

@c ref
See also
@ref{twostd BR_LETTERPLACE_BR}.
@c ref

@c ------------------------------
@node rightstd BR_LETTERPLACE_BR, std BR_LETTERPLACE_BR, reduce BR_LETTERPLACE_BR, Functions BR_LETTERPLACE_BR
@subsection rightstd BR_LETTERPLACE_BR
@cindex rightstd BR_LETTERPLACE_BR
@table @code
@item @strong{Syntax:}
  @code{rightstd(} ideal_expression@code{)};
@item @strong{Type:}
ideal
@item @strong{Purpose:}
Compute a right Groebner basis of the set of generators of the input ideal.
It is also effective in factor rings.
@smallexample
@c example
LIB "freegb.lib";
ring r = 0,(x,z),dp;
ring R = freeAlgebra(r,7);
ideal I = z, x*z, x*x*z;
rightstd(I); // a right GB of I in K<x,z>
qring Q = twostd(x*z); // now we change to the factor algebra modulo x*z
ideal I = imap(R,I);
rightstd(I); // a right GB in a factor algebra
reduce(I,twostd(0)); // an explanation for the latter
@c example
@end smallexample
@end table


@c ------------------------------
@node std BR_LETTERPLACE_BR, syz BR_LETTERPLACE_BR, rightstd BR_LETTERPLACE_BR, Functions BR_LETTERPLACE_BR
@subsection std BR_LETTERPLACE_BR
@cindex std BR_LETTERPLACE_BR
@table @code
@item @strong{Syntax:}
  @code{std(} ideal_expression@code{)};
@item @strong{Type:}
ideal
@item @strong{Purpose:}
Alias to @ref{twostd BR_LETTERPLACE_BR}.
@end table

@c -------------------------------------------------
@node syz BR_LETTERPLACE_BR, twostd BR_LETTERPLACE_BR, std BR_LETTERPLACE_BR, Functions BR_LETTERPLACE_BR
@subsection syz BR_LETTERPLACE_BR
@cindex syz BR_LETTERPLACE_BR
@table @code
@item @strong{Syntax:}
@code{syz (} ideal_expression @code{)}
@*@code{syz (} module_expression @code{)}
@item @strong{Type:}
module
@item @strong{Purpose:}
computes the first syzygy (i.e., the module of relations of the given
generators) bimodile of the ideal, resp.@: module.
@*If @code{option(returnSB)} is set, a Groebner basis is returned, otherwise a generating set.
@item @strong{Example:}
@smallexample
@c example
  LIB "freegb.lib";
  ring r = 0,(x,y),(c,Dp);
  ring R = freeAlgebra(r, 7, 2);
  ideal I = twostd(x*y*x + 1); 
  I;
  module S = syz(I);
  print(S);
  testSyz(I,S);
@end smallexample
@end table
@c ref
See
@ref{ideal};
@ref{module};
@ref{option};
@ref{lift (letterplace)};
@ref{liftstd (letterplace)}.

@c ------------------------------
@node twostd BR_LETTERPLACE_BR, Mathematical background BR_LETTERPLACE_BR, std BR_LETTERPLACE_BR, Functions BR_LETTERPLACE_BR
@subsection twostd BR_LETTERPLACE_BR
@cindex twostd BR_LETTERPLACE_BR

@table @code
@item @strong{Syntax:}
  @code{twostd(} ideal_expression@code{)};
@item @strong{Type:}
ideal
@item @strong{Purpose:}
returns a two-sided Groebner basis of the two-sided ideal,
generated by the input, which is treated as a set of two-sided generators.
@item @strong{Example:}
@smallexample
@c example
LIB "freegb.lib";
ring r = 3,(x,d),dp; // notice: we work over Z/3Z
ring R = freeAlgebra(r,5); 
ideal I = x^4, d^3, d*x - x*d - 1;
twostd(I); // a proper ideal, note x^3 as a generator
ideal J = x^2, d^3, d*x - x*d - 1;
twostd(J); // the whole ring
ideal T = twostd(ideal(d*x - x*d - 1));
T;
qring Q = T; // thus Q is the Weyl algebra over Z/3z
ideal I = x^4, d^3;
twostd(I);
ideal J = x^2, d^3;
twostd(J);
@c example
@end smallexample
@end table


@c ---------------------------------------------------------------------------
@node Mathematical background BR_LETTERPLACE_BR
@section Mathematical background BR_LETTERPLACE_BR
@cindex Mathematical background BR_LETTERPLACE_BR

@menu
* Free associative algebras::
* Monomial orderings on free algebras::
* Groebner bases for two-sided ideals in free associative algebras::
* Letterplace correspondence::
* Bimodules and syzygies and lifts::
@end menu

@c ---------------------------------------------------------------------------
@node Free associative algebras, Monomial orderings on free algebras, Mathematical background BR_LETTERPLACE_BR, Mathematical background BR_LETTERPLACE_BR
@subsection Free associative algebras
@cindex Free associative algebras
@cindex free associative algebra, tensor algebra

Let @math{V} be a @math{K}-vector space, spanned by the symbols @math{x_1},@dots{},@math{x_n}.
A free associative algebra in @math{x_1},@dots{},@math{x_n} over @math{K}, denoted by @math{K} @math{< x_1},@dots{},@math{x_n >}
is also known as the tensor algebra @math{T(V)} of @math{V};
it is also the monoid @math{K}-algebra of the free monoid @math{< x_1},@dots{},@math{x_n >}.
The elements of this free monoid constitute an infinite @math{K}-basis of @math{K} @math{< x_1},@dots{},@math{x_n >},
where the identity element (the empty word) of the free monoid is identified with the @math{1} in @math{K}.
Yet in other words, the monomials of @math{K} @math{< x_1},@dots{},@math{x_n >} are the words
of finite length in the finite alphabet @{ @math{x_1},@dots{},@math{x_n} @}.

The algebra @math{K} @math{< x_1},@dots{},@math{x_n >} is an integral domain, which is not (left, right, weak or two-sided) Noetherian for @math{n>1}; hence, a Groebner basis of a finitely generated ideal might be infinite.
Therefore, a general computation takes place @strong{up to an explicit degree (length) bound}, provided by the user.
The free associative algebra can be regarded as a graded algebra in a natural way.

@strong{Definition}. An associative algebra @math{A} is called @strong{finitely presented (f.p.)}, if it is isomorphic to
@math{K} @math{< x_1},@dots{},@math{x_n > /I},
@c @tex{K <x_1, \ldots, x_n > / I}.
where @math{I} is a two-sided ideal.
@math{A} is called @strong{standard finitely presented (s.f.p.)}, if there exists a monomial ordering,
such that @math{I} is given via its @strong{finite} Groebner basis @math{G}.

@cindex finitely presented algebra, standard finitely presented algebra

@c ---------------------------------------------------------------------------
@node Monomial orderings on free algebras, Groebner bases for two-sided ideals in free associative algebras, Free associative algebras, LETTERPLACE 
@subsection Monomial orderings on free algebras
@cindex Monomial orderings on free algebras

@c Leo's code
Monomial orderings are of crucial importance when dealing with Groebner bases.
Especially in the non-commutative Groebner theory up to a degree (length) bound it might be vital
to have many choices for orderings since it is not guaranteed that there exists a finite Groebner
bases with respect to the given ordering.

Let @math{X} = @{@math{x_1},@dots{},@math{x_n}@} be a set of symbols. A total ordering < on the free monoid @math{< X >} with @math{1} as the neutral element is called a @strong{monomial ordering} if
@itemize
@item it is a well-ordering, i.e., every non empty subset has a least element with respect to <, and
@item it respects multiplication, that is @math{u < v} implies @math{aub < avb} for all @math{u}, @math{v}, @math{a} and @math{b} in @math{<X>}.
@end itemize
Note that the latter implies @math{1 <= m} for all @math{m} in @math{<X>}.

The @strong{left lexicographical ordering} on @math{<X>} with @math{x_1> x_2 > }@dots{}@math{ > x_n} is defined as follows:
For arbitrary @math{a}, @math{b} in @math{<X>} we say that @math{a<b}, if
@itemize
@item
@tex
$\exists u\in \langle X\rangle\setminus\{1\}:\;au=b$ or
@end tex
@ifinfo
there exists @math{u} in < @math{X} > with @math{u} != @math{1\}, @math{au=b} or
@end ifinfo

@item
@tex
$\exists u,\,v,\,w\in \langle X\rangle\;\exists x_i,\,x_j\in X: a=ux_iv,\;b=ux_jw$ and $i>j$ holds.
@end tex

@ifinfo
there exists @math{u}, @math{v}, @math{w} in @math{<X>} and there exists @math{x_i}, @math{x_j} in @math{X} such that @math{a=ux_i v}, @math{b=ux_j w} and @math{i>j} holds.
@end ifinfo

@end itemize

@strong{Note}: left lex is @strong{not} a monomial ordering, though it is a natural choice to break ties in further definitions.

In a similar manner one can define the @strong{right lexicographical ordering}.

On the monoid
@tex
$(N_0,+)$
@end tex
@ifinfo
@math{(N_0,+)}
@end ifinfo
define the @strong{weight} homomorphism
@tex
$w: \langle X\rangle\rightarrow N_0$
@end tex
@ifinfo
@math{w:<X>->N_0}
@end ifinfo
, uniquely determined by @math{w(x_i)=w_i} in
@tex
$N_0$
@end tex
@ifinfo
@math{N_0}
@end ifinfo
for @math{1 <= i <= n}. As a special case, define the @strong{length}
@tex
len:$ \langle X\rangle\rightarrow N_0$
@end tex
@ifinfo
@math{len:<X>->N_0}
@end ifinfo
 by @math{len(x_i)=1} for @math{1 <= i <= n}. For any ordering << on @math{<X>} and any weight
@tex
$w: \langle X\rangle\rightarrow N_0$
@end tex
@ifinfo
@math{w:<X>->N_0}
@end ifinfo
 define an ordering <, the @math{w}-@strong{weight extension of} << as follows: For arbitrary @math{a}, @math{b} in @math{<X>} we say that @math{a<b} if
@itemize
@item @math{w(a)<w(b)} or
@item @math{w(a)=w(b)} and @math{a}<<@math{b} holds.
@end itemize
An ordering < on @math{<X>} @strong{eliminates} a certain subset
@tex
$\emptyset\not=Y\subset X$ if for all $f\in K\langle X\rangle\setminus\{0\}$ one has $ lm(f)\in  K\langle X\setminus Y\rangle\Rightarrow f\in K\langle X\setminus Y\rangle\subseteq K\langle X\rangle$.
@end tex
@ifinfo
@{@}!=@math{Y}!=@math{X} of @math{X} if for all @math{f}!=@math{0} in @math{K<X>} the condition @math{lm(f)} in @math{K<X-Y>} implies @math{f} in @math{K<X-Y>}.
@end ifinfo

In a ring declaration, @sc{Letterplace} supports the following monomial orderings.
We illustrate each of the available choices by an example on the free monoid @math{<x_1},@math{x_2},@math{x_3>},
where we order the monomials
@math{x_1 x_1 x_1}, @math{x_3 x_2 x_1}, @math{x_1 x_2 x_3}, @math{x_3 x_3 x_3}, @math{x_3 x_1}, @math{x_2 x_2}, @math{x_1 x_3}, @math{x_2 x_3}, @math{x_1}, @math{x_2} and @math{x_3} correspondingly.
@table @samp
@item @code{dp}
The @strong{degree right lexicographical ordering} is the length-weight extension of the right lexicographical ordering.

With respect to the ordering @samp{dp}, the test monomials are ordered as follows:
@math{x_1 x_1 x_1 > x_3 x_2 x_1 > x_1 x_2 x_3 > x_3 x_3 x_3 > x_3 x_1 > x_2 x_2 > x_1 x_3 > x_2 x_3 > x_1 > x_2 > x_3}
@item @code{Dp}
The @strong{degree left lexicographical ordering} is the length-weight extension of the left lexicographical ordering.

With respect to the ordering @samp{Dp}, the test monomials are ordered as follows:
@math{x_1 x_1 x_1 > x_1 x_2 x_3 > x_3 x_2 x_1 > x_3 x_3 x_3 > x_1 x_3 > x_2 x_2 > x_2 x_3 > x_3 x_1 > x_1 > x_2 > x_3}
@item @code{Wp(w)} for intvec w
The @strong{weighted degree left lexicographical ordering} is the @math{w}-weight extension of the left lexicographical ordering with weight
@tex
$w: \langle X\rangle\rightarrow N_0$
@end tex
@ifinfo
@math{w:<X>->N_0}
@end ifinfo
 uniquely determined by strict positive @math{w(x_i)=w_i>0}.

With respect to the ordering @samp{Wp(1, 2, 1)}, the test monomials are ordered as follows:
@math{x_1 x_2 x_3 > x_2 x_2 > x_3 x_2 x_1 > x_1 x_1 x_1 > x_2 x_3 > x_3 x_3 x_3 > x_1 x_3 > x_2 > x_3 x_1 > x_1 > x_3}

@c what about <_{i+1}? As it is now, this might be wrong ...
@item @code{lp}
@tex
Let $w^{(i)}$ be weights uniquely determined by $w^{(i)}(x_j)=\delta_{i,j}$ for $1\leq i,j\leq n$ where $\delta$ denotes the Kronecker delta. Let $<_n$ be the $w^{(n)}$-weight extension of the left lexicographical ordering on $\langle X\rangle$ and inductively $<_i$ be the $w^{(i)}$-weight extension of $<_{i+1}$ for all $1\leq i<n$.
The monomial ordering lp corresponds to $<_1$ and eliminates $x_1,...,x_j$ for all $1\leq j<n$.
@end tex
@ifinfo
Let @math{w^i} be weights uniquely determined by @math{w^i(x_j)=\d^i_j}$ for @math{1}<=@math{i},@math{j}<=@math{n} where @math{d} denotes the Kronecker delta. Let @math{<_n} be the @math{w^n}-weight extension of the left lexicographical ordering on @math{<X>} and inductively @math{<_i} be the @math{w^i}-weight extension of @math{<_i+1} for all @math{1<= i< n}.
@end ifinfo

The monomial ordering @samp{lp} corresponds to @math{<_1} and eliminates @{@math{x_1},@dots{},@math{x_j}@} for all @math{1}<=@math{j}<@math{n}.

With respect to the ordering @samp{lp}, the test monomials are ordered as follows:
@math{x_1 x_1 x_1 > x_1 x_2 x_3 > x_3 x_2 x_1 > x_1 x_3 > x_3 x_1 > x_1 > x_2 x_2 > x_2 x_3 > x_2 > x_3 x_3 x_3 > x_3}
@item @code{rp}
@tex
Let $w^{(i)}$ be weights uniquely determined by $w^{(i)}(x_j)=\delta_{i,j}$ for $1\leq i,j\leq n$ where $\delta$ denotes the Kronecker delta. Let $<_1$ be the $w^{(1)}$-weight extension of the left lexicographical ordering on $\langle X\rangle$ and inductively $<_i$ be the $w^{(i)}$-weight extension of $<_{i-1}$ for all $1<i\leq n$.
The monomial ordering \texttt{rp} corresponds to $<_n$ and eliminates $\{x_j,\ldots,x_n\}$ for all $1<j\leq n$.
@end tex
@ifinfo
Let @math{w^i} be weights uniquely determined by @math{w^i(x_j)=\d^i_j}$ for @math{1}<=@math{i},@math{j}<=@math{n} where @math{d} denotes the Kronecker delta. Let @math{<_1} be the @math{w^n}-weight extension of the left lexicographical ordering on <@math{X}> and inductively @math{<_i} be the @math{w^i}-weight extension of @math{<_i-1} for all @math{1}<@math{i}<=@math{n}.
@end ifinfo

The monomial ordering @samp{rp} corresponds to @math{<_n} and eliminates @{@math{x_j},@dots{},@math{x_n}@} for all @math{1 < j <= n}.

With respect to the ordering @samp{rp}, the test monomials are ordered as follows:
@math{x_3 x_3 x_3 > x_1 x_2 x_3 > x_3 x_2 x_1 > x_2 x_3 > x_1 x_3 > x_3 x_1 > x_3 > x_2 x_2 > x_2 > x_1 x_1 x_1 > x_1}

@item @code{(a(v), ordering)} for intvec v
@tex
For weight $v:\langle X\rangle\rightarrow N_0$ determined by $v(x_i)=v_i\in N_0$ with $1\leq i\leq n$ and monomial ordering $\prec$ on $\langle X\rangle$, the $v$\emph{-weight extension} of $\prec$ corresponds to \texttt{(a(v), o)}. As a choice for $\prec$ there are currently two options implemented, which are \texttt{dp} and \texttt{Dp}. Notice that this ordering eliminates $\{x_i\in X\mid v(x_i)\not=0\}$.
@end tex
@ifinfo
For weight @math{v:<X>->N_0} determined by @math{v(x_i)=v_i} in @math{N_0} with @math{1}<=@math{i}<=@math{n} and monomial ordering << on <@math{X}>, the @math{v}-weight extension of << corresponds to @samp{(a(v), o)}. As a choice for << there are currently two options implemented, which are @samp{dp} and @samp{Dp}. Notice that this ordering eliminates @{@math{x_i}:@math{v(x_i)}!=@math{0}@}.
@end ifinfo

With respect to the ordering @samp{( a(1, 0, 0), Dp)}, the test monomials are ordered as follows:
@math{x_1 x_1 x_1 > x_1 x_2 x_3 > x_3 x_2 x_1 > x_1 x_3 > x_3 x_1 > x_1 > x_3 x_3 x_3 > x_2 x_2 > x_2 x_3 > x_2 > x_3}
With ordering @samp{( a(1, 1, 0), Dp)} one obtains:
@math{x_1 x_1 x_1 > x_1 x_2 x_3 > x_3 x_2 x_1 > x_2 x_2 > x_1 x_3 > x_2 x_3 > x_3 x_1 > x_1 > x_2 > x_3 x_3 x_3 > x_3}
@end table

The examples are generated by the following code but with customized orderings denoted above.
@smallexample
@c example
LIB "freegb.lib";
ring r = 0, (x1,x2,x3),Dp; // variate ordering here
ring R = freeAlgebra(r, 4);
poly wr = x1*x1*x1+x3*x3*x3+x1*x2*x3+x3*x2*x1+x2*x2+x2*x3+x1*x3+x3*x1+x1+x2+x3;
wr;
@c example
@end smallexample

@c ---------------------------------------------------------------------------
@node Groebner bases for two-sided ideals in free associative algebras, Letterplace correspondence, Monomial orderings on free algebras, LETTERPLACE 
@subsection Groebner bases for two-sided ideals in free associative algebras
@cindex Groebner bases for two-sided ideals in free associative algebras
@cindex Groebner bases in free associative algebras
@cindex Groebner-Shirshov bases in free associative algebras
@cindex Groebner-Shirshov bases 

@c Hence the notions like a leading monomial and a leading coefficient transfer to this situation.

We say that a monomial @math{v} divides (two-sided or bilaterally) a monomial @math{w}, if there exist monomials
@tex
$p,s \in X$, such that $w = p \cdot v \cdot s$,
@end tex
@ifinfo
@math{p,s} in @math{X}, such that @math{w = p} .  @math{v} .  @math{s},
@end ifinfo
 in other words @math{v} is a subword of @math{w}.

@tex
For a subset $G \subset K\langle x_1,\dots,x_n \rangle =: T$,
define the \textbf{leading ideal} of $G$ to be the two-sided ideal
$LM(G) \; = \; {}_{T} \langle$ $\; \{lm(g) \;|\; g \in G\setminus\{0\} \}$ $\; \rangle_{T} \subseteq T$.

Let $<$ be a fixed monomial ordering on $T$.
We say that a subset $G \subset I$ is a \textbf{(two-sided) Groebner basis} for the ideal $I$ with respect to $<$, if $LM(G) = LM(I)$. That is $\forall f\in I\setminus\{0\}$ there exists $g\in G$, such that
$lm(g)$ divides $lm(f)$.
@end tex

The notion of @strong{Groebner-Shirshov} basis applies to more general algebraic structures,
but means the same as Groebner basis for associative algebras.

@ifinfo
For a subset @math{G} in @math{K< x_1},@dots{},@math{x_n > =: T},
define a @strong{leading ideal} of @math{G} to be the two-sided ideal
@math{LM(G)  =}  @{ @math{lm(g) | g} in @math{G}\@{0@} @} in @math{T}.

Let @math{<} be a fixed monomial ordering on @math{T}.
We say that a subset @math{G} of @math{I} is a @strong{(two-sided) Groebner basis} for the ideal @math{I} with respect to @math{<}, if @math{LM(G) = LM(I)}. That is for all @math{f} from @math{I}\@{0@} there exists @math{g} in @math{G}, such that @math{lm(g)} divides @math{lm(f)}.
@end ifinfo

Suppose, that the weights of the ring variables are strictly positive.
We can interprete these weights as defining a non-standard grading on the ring.
If the set of input polynomials is weighted homogeneous with respect to the given
weights of the ring variables, then computing up to a weighted degree (and thus, also length) bound @math{d}
results in the @strong{truncated Groebner basis} @math{G(d)}. In other words, by trimming elements
of degree exceeding @math{d} from the complete Groebner basis @math{G}, one obtains precisely @math{G(d)}.

In general, given a set @math{G(d)}, which is the result of Groebner basis computation
up to weighted degree bound @math{d}, then
it is the complete finite Groebner basis, if and only if @math{G(2d-1)=G(d)} holds.


@c ---------------------------------------------------------------------------
@node Letterplace correspondence, LETTERPLACE libraries, Groebner bases for two-sided ideals in free associative algebras, LETTERPLACE 
@subsection Letterplace correspondence
@cindex Letterplace correspondence

The name letteplace has been inspired by the work of Rota and, independently, Feynman.

@tex
Already Feynman and Rota encoded
the monomials (words) of the free algebra
$x_{i_1} x_{i_2} \dots x_{i_m} \in K\langle x_1,\ldots,x_n \rangle$
via the double-indexed letterplace
(that is encoding the letter (= variable) and its place in the word) monomials
$x(i_1 | 1) x(i_2 | 2) \dots x(i_m | m) \in K[X\times N]$, where $X=\{x_1,\ldots,x_n\}$
and $N$ is the semigroup of natural numbers, starting with 1 as the first possible place.
Note, that the letterplace algebra $K[X \times N]$ is an infinitely generated commutative polynomial $K$-algebra.
Since $K\langle x_1,\ldots,x_n \rangle$ is not Noetherian, it is common to perform the computations with
its ideals and modules up to a given degree bound.
@end tex
@ifinfo
Already Feynman and Rota encoded
the monomials (words) of the free algebra
@math{x_(i_1) x_(i_2)} @dots{} @math{x_(i_m)} in @math{K< x_1},@dots{},@math{x_n >}
via the double-indexed letterplace
(that is encoding the letter (= variable) and its place in the word) monomials
@math{x(i_1 | 1) x(i_2 | 2)} @dots{} @math{x(i_m | m)} in @math{K[X x N]}, where @math{X=} @{ @math{x_1},@dots{},@math{x_n} @}
and @math{N} is the semigroup of natural numbers, starting with 1 as the first possible place.
Note, that the letterplace algebra @math{K[X \times N]} is an infinitely generated commutative polynomial @math{K}-algebra.
Since @math{K<} @math{x_1},@dots{},@math{x_n} @math{>} is not Noetherian, it is common to perform the computations with
its ideals and modules up to a given degree bound.
@end ifinfo

@tex
Subject to the given degree (length) bound $d$, the truncated letterplace algebra
$K[X\times (1, ..., d)]$ is finitely generated commutative polynomial $K$-algebra.
@end tex
@ifinfo
Subject to the given degree (length) bound @math{d}, the truncated letterplace algebra
@math{K[X x (1, ..., d) ]} is finitely generated commutative polynomial @math{K}-algebra.
@end ifinfo

In [LL09] a natural shifting on letterplace polynomials was introduced and used.
Indeed, there is 1-to-1 correspondence between two-sided ideals
of a free algebra and so-called letterplace ideals in the letterplace algebra,
see [LL09], [LL13], [LSS13] and [L14] for details.
Note, that first this correspondence was established for graded ideals, but holds more
generally for arbitrary ideals and subbimodules of a free bimodule of a finite rank.
All the computations internally take place in the Letterplace algebra.

A letterplace monomial of length @math{m} is a monomial of a letterplace algebra,
such that its @math{m} places are exactly 1,2,@dots{},@math{m}.
In particular, such monomials are multilinear with respect to places (i.e.
no place, smaller than the length is omitted or filled more than with one letter).
A letterplace polynomial is an element of the @math{K}-vector space,
spanned by letterplace monomials. A letterplace ideal is generated by letterplace
polynomials subject to two kind of operations:

the
@tex
$K$-algebra operations of the letterplace algebra \textbf{and} simultaneous shifting of places by any natural number $n$.
@end tex
@ifinfo
@math{K}-algebra operations of the letterplace algebra @strong{and} simultaneous shifting of places by any natural number @math{n}.
@end ifinfo


@c ---------------------------------------------------------------------------
@node Bimodules and syzygies and lifts, LETTERPLACE libraries, Letterplace correspondence, LETTERPLACE 
@section Bimodules and syzygies and lifts
@cindex Bimodules
@cindex Syzygy bimodule
@cindex Bisyzygy

@c Bimodules, (bi-)syzygies and lifts

Let @math{A = K} @math{<x_1},@dots{},@math{x_n >} be the free algebra.
A free bimodule of rank @math{r} over @math{A} is
@tex 
$A e_1 A \oplus \ldots \oplus A e_r A$,
@end tex
@ifinfo
@math{A e_1 A} + @dots{} + @math{A e_r A},
@end ifinfo
where @math{e_i} are the generators of the free bimodule.
NOTE: these @math{e_i} are freely non-commutative with respect to
elements of @math{A} except constants from the ground field @math{K}. 

The free bimodule of rank 1 @math{AeA} surjects onto the algebra @math{A} itself.
A two-sided ideal of the algebra @math{A} can be converted to a subbimodule of 
@math{AeA}.

The @strong{syzygy bimodule} or even @strong{module of bisyzygies} 
of the given finitely generated subbimodule 
@tex
$N = \langle g_1,\ldots,g_m \rangle \subset \bigoplus_{i=1}^r A e_i A$
@end tex
@ifinfo
@math{N = < g_1},@dots{},@math{g_m > \subset \bigoplus_{i=1}^r A e_i A} 
@end ifinfo
is the kernel of the natural homomorphism of @math{A}-bimodules
@tex 
\[
\bigoplus_{j=1}^m A \epsilon_j A \Longrightarrow \bigoplus_{i=1}^r A e_i A,
\;
\epsilon_j  \mapsto \sum_k \ell_{jk} g_j r_{jk}
\sum_{j=1}^m \sum_k  \ell_{jk} \epsilon_j r_{jk} 
\mapsto \sum_{j=1}^m \sum_k \ell_{jk} g_j r_{jk}.
\]
@end tex
@ifinfo
@display
\bigoplus_{j=1}^m A \epsilon_j A \Longrightarrow \bigoplus_{i=1}^r A e_i A,
\;
\sum_{j=1}^m \sum_k  \ell_{jk} \epsilon_j r_{jk} 
\mapsto \sum_{j=1}^m \sum_k \ell_{jk} g_j r_{jk}. 
@end display
@end ifinfo

The syzygy bimodule is in general not finitely generated. Therefore as a
bimodule, both the set of generators of the syzygy bimodule and 
its Groebner basis are computed up to a specified length bound.


@c ---------------------------------------------------------------------------
@node LETTERPLACE libraries,  , Letterplace correspondence, LETTERPLACE 
@section LETTERPLACE libraries
@cindex LETTERPLACE libraries
@cindex Letterplace libraries

@menu
* fpadim_lib::  Vector space dimension, basis and Hilbert series for finitely presented algebras (Letterplace)
* fpalgebras_lib:: Numerous algebras predefined for the Letterplace case
* fpaprops_lib:: Algorithms for properties of quotient algebras in the Letterplace case
* freegb_lib::  Two-sided Groebner bases in free algebras via Letterplace
* ncHilb_lib:: Hilbert functions for non-commutative algebras via Letterplace
* ncrat_lib::  Handling non-commutative rational functions
@end menu

@c ----------------------------------------------------------
@node fpadim_lib
@subsection fpadim_lib
@c lib fpadim.lib
@c ----------------------------------------------------------
@node fpalgebras_lib
@subsection fpalgebras_lib
@c lib fpalgebras.lib
@c ----------------------------------------------------------
@node fpaprops_lib
@subsection fpaprops_lib
@c lib fpaprops.lib
@c ----------------------------------------------------------
@node freegb_lib
@subsection freegb_lib
@c lib freegb.lib
@c ----------------------------------------------------------
@node ncHilb_lib
@subsection ncHilb_lib
@c lib ncHilb.lib
@c ----------------------------------------------------------
@node ncrat_lib
@subsection ncrat_lib
Status: experimental
@c lib ncrat.lib
