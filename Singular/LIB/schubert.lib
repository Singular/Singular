////////////////////////////////////////////////////////////////////////////////
version="version schubert.lib 4.2.0.1 Jan_2021 "; // $Id$
category="Algebraic Geometry";
info="
LIBRARY:    schubert.lib    Proceduces for Intersection Theory

AUTHOR:     Hiep Dang,          email: hiep@mathematik.uni-kl.de

OVERVIEW:

    We implement new classes (variety, sheaf, stack, graph) and methods for
    computing with them. An abstract variety is represented by a nonnegative
    integer which is its dimension and a graded ring which is its Chow ring.
    An abstract sheaf is represented by a variety and a polynomial which is its
    Chern character. In particular, we implement the concrete varieties such as
    projective spaces, Grassmannians, and projective bundles.

    An important task of this library is related to the computation of
    Gromov-Witten invariants. In particular, we implement new tools for the
    computation in equivariant intersection theory. These tools are based on the
    localization of moduli spaces of stable maps and Bott's formula. They are
    useful for the computation of Gromov-Witten invariants. In order to do this,
    we have to deal with moduli spaces of stable maps, which were introduced by
    Kontsevich, and the graphs corresponding to the fixed point components of a
    torus action on the moduli spaces of stable maps.

    As an insightful example, the numbers of rational curves on general complete
    intersection Calabi-Yau threefolds in projective spaces are computed up to
    degree 6. The results are all in agreement with predictions made from mirror
    symmetry computations.

REFERENCES:

    Hiep Dang,  Intersection theory with applications to the computation of
                Gromov-Witten invariants, Ph.D thesis, TU Kaiserslautern, 2013.

    Sheldon Katz and Stein A. Stromme, Schubert-A Maple package for intersection
                theory and enumerative geometry, 1992.

    Daniel R. Grayson, Michael E. Stillman, Stein A. Stromme, David Eisenbud and
    Charley Crissman, Schubert2-A Macaulay2 package for computation in
                intersection theory, 2010.

    Maxim Kontsevich, Enumeration of rational curves via torus actions, 1995.

PROCEDURES:
    makeVariety(int,ideal)              create a variety
    printVariety(variety)               print procedure for a variety
    productVariety(variety,variety)     make the product of two varieties
    ChowRing(variety)                   create the Chow ring of a variety
    Grassmannian(int,int)               create a Grassmannian as a variety
    projectiveSpace(int)                create a projective space as a variety
    projectiveBundle(sheaf)             create a projective bundle as a variety
    integral(variety,poly)              degree of a 0-cycle on a variety
    makeSheaf(variety,poly)             create a sheaf
    printSheaf(sheaf)                   print procedure for sheaves
    rankSheaf(sheaf)                    return the rank of a sheaf
    totalChernClass(sheaf)              compute the total Chern class of a sheaf
    ChernClass(sheaf,int)               compute the k-th Chern class of a sheaf
    topChernClass(sheaf)                compute the top Chern class of a sheaf
    totalSegreClass(sheaf)              compute the total Segre class of a sheaf
    dualSheaf(sheaf)                    make the dual of a sheaf
    tensorSheaf(sheaf,sheaf)            make the tensor of two sheaves
    symmetricPowerSheaf(sheaf,int)      make the k-th symmetric power of a sheaf
    quotSheaf(sheaf,sheaf)              make the quotient of two sheaves
    addSheaf(sheaf,sheaf)               make the direct sum of two sheaves
    makeGraphVE(list,list)              create a graph from a list of vertices
                                        and a list of edges
    printGraphG(graph)                   print procedure for graphs
    moduliSpace(variety,int)            create a moduli space of stable maps as
                                        an algebraic stack
    printStack(stack)                   print procedure for stacks
    dimStack(stack)                     compute the dimension of a stack
    fixedPoints(stack)                  compute the list of graphs corresponding
                                        the fixed point components of a torus
                                        action on the stack
    contributionBundle(stack,graph)     compute the contribution bundle on a
                                        stack at a graph
    normalBundle(stack,graph)           compute the normal bundle on a stack at
                                        a graph
    multipleCover(int)                  compute the contribution of multiple
                                        covers of a smooth rational curve as a
                                        Gromov-Witten invariant
    linesHypersurface(int)              compute the number of lines on a general
                                        hypersurface
    rationalCurve(int,list)             compute the Gromov-Witten invariant
                                        corresponding the number of rational
                                        curves on a general Calabi-Yau threefold
    sumofquotients(stack,list)          prepare a command for parallel
                                        computation
    homog_part(poly,int)                compute a homogeneous component of a
                                        polynomial.
    homog_parts(poly,int,int)           compute the sum of homogeneous
                                        components of a polynomial
    logg(poly,int)                      compute Chern characters from total
                                        Chern classes.
    expp(poly,int)                      compute total Chern classes from Chern
                                        characters
    SchubertClass(list)                 compute the Schubert classes on a
                                        Grassmannian
    dualPartition(list)                 compute the dual of a partition

KEYWORDS:       Intersection theory; Enumerative geometry; Schubert calculus;
                Bott's formula; Gromov-Witten invariants.

";

////////////////////////////////////////////////////////////////////////////////

LIB "general.lib";
LIB "homolog.lib";
LIB "parallel.lib";
LIB "ring.lib";

////////////////////////////////////////////////////////////////////////////////
/////////// create new objects in this library  ////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

static proc mod_init()
{
    newstruct("variety","int dimension, ring baseRing, ideal relations");
    newstruct("sheaf","variety currentVariety, poly ChernCharacter");
    newstruct("graph","list vertices, list edges");
    newstruct("stack","variety currentVariety, int degreeCurve");

    system("install","variety","print",printVariety,1);
    system("install","variety","*",productVariety,2);
    system("install","sheaf","print",printSheaf,1);
    system("install","sheaf","*",tensorSheaf,2);
    system("install","sheaf","+",addSheaf,2);
    system("install","sheaf","-",quotSheaf,2);
    system("install","sheaf","^",symmetricPowerSheaf,2);
    system("install","graph","print",printGraphG,1);
    system("install","stack","print",printStack,1);
}

////////////////////////////////////////////////////////////////////////////////
//////// Procedures concerned with moduli spaces of stable maps ////////////////
////////////////////////////////////////////////////////////////////////////////

proc printStack(stack M)
"USAGE:     printStack(M); M stack
ASSUME:     M is a moduli space of stable maps.
THEORY:     This is the print function used by Singular to print a stack.
KEYWORDS:   stack, moduli space of stable maps
EXAMPLE:    example printStack; shows an example
"
{
    "A moduli space of dimension", dimStack(M);
}
example
{
    "EXAMPLE:"; echo=2;
    ring r = 0,(x),dp;
    variety P = projectiveSpace(4);
    stack M = moduliSpace(P,2);
    M;
}

proc moduliSpace(variety V, int d)
"USAGE:     moduliSpace(V,d); V variety, d int
ASSUME:     V is a projective space and d is a positive integer.
THEORY:     This is the function used by Singular to create a moduli space of
            stable maps from a genus zero curve to a projective space.
KEYWORDS:   stack, moduli space of stable maps, rational curves
EXAMPLE:    example moduliSpace; shows an example
"
{
    stack M;
    M.currentVariety = V;
    M.degreeCurve = d;
    return(M);
}
example
{
    "EXAMPLE:"; echo=2;
    ring r = 0,(x),dp;
    variety P = projectiveSpace(4);
    stack M = moduliSpace(P,2);
    M;
}

proc dimStack(stack M)
"USAGE:     dimStack(M); M stack
RETURN:     int
INPUT:      M is a moduli space of stable maps.
OUTPUT:     the dimension of moduli space of stable maps.
KEYWORDS:   dimension, moduli space of stable maps, rational curves
EXAMPLE:    example dimStack; shows an example
"
{
    variety V = M.currentVariety;
    int n = V.dimension;
    int d = M.degreeCurve;
    return (n*d+n+d-3);
}
example
{
    "EXAMPLE:"; echo=2;
    ring r = 0,(x),dp;
    variety P = projectiveSpace(4);
    stack M = moduliSpace(P,2);
    dimStack(M);
}

proc fixedPoints(stack M)
"USAGE:     fixedPoints(M); M stack
RETURN:     list
INPUT:      M is a moduli space of stable maps.
OUTPUT:     a list of graphs corresponding the fixed point components of a torus
            action on a moduli space of stable maps.
KEYWORDS:   fixed points, moduli space of stable maps, graph
EXAMPLE:    example fixedPoints; shows an example
"
{
    int i,j,k,h,m,n,p,q;
    list l;
    int d = M.degreeCurve;
    variety V = M.currentVariety;
    int r = V.dimension;
    for (i=0;i<=r;i++)
    {
        for (j=0;j<=r;j++)
        {
            if (i <> j)
            {
                l[size(l)+1] = list(graph1(d,i,j),2*d);
            }
        }
    }
    if (d == 2)
    {
        for (i=0;i<=r;i++)
        {
            for (j=0;j<=r;j++)
            {
                for (k=0;k<=r;k++)
                {
                    if (i <> j and j <> k)
                    {
                        l[size(l)+1] = list(graph2(list(1,1),i,j,k),2);
                    }
                }
            }
        }
    }
    if (d == 3)
    {
        for (i=0;i<=r;i++)
        {
            for (j=0;j<=r;j++)
            {
                for (k=0;k<=r;k++)
                {
                    if (i <> j and j <> k)
                    {
                        l[size(l)+1] = list(graph2(list(2,1),i,j,k),2);
                        for (h=0;h<=r;h++)
                        {
                            if (h <> k)
                            {
                                l[size(l)+1] = list(graph31(list(1,1,1),i,j,k,h),2);
                            }
                            if (h <> j)
                            {
                                l[size(l)+1] = list(graph32(list(1,1,1),i,j,k,h),6);
                            }
                        }
                    }
                }
            }
        }
    }
    if (d == 4)
    {
        for (i=0;i<=r;i++)
        {
            for (j=0;j<=r;j++)
            {
                for (k=0;k<=r;k++)
                {
                    if (i <> j and j <> k)
                    {
                        l[size(l)+1] = list(graph2(list(3,1),i,j,k),3);
                        l[size(l)+1] = list(graph2(list(2,2),i,j,k),8);
                        for (h=0;h<=r;h++)
                        {
                            if (h <> k)
                            {
                                l[size(l)+1] = list(graph31(list(2,1,1),i,j,k,h),2);
                                l[size(l)+1] = list(graph31(list(1,2,1),i,j,k,h),4);
                            }
                            if (h <> j)
                            {
                                l[size(l)+1] = list(graph32(list(2,1,1),i,j,k,h),4);
                            }
                            for (m=0;m<=r;m++)
                            {
                                if (k <> h and m <> h)
                                {
                                    l[size(l)+1] = list(graph41(list(1,1,1,1),i,j,k,h,m),2);
                                }
                                if (k <> h and m <> k)
                                {
                                    l[size(l)+1] = list(graph42(list(1,1,1,1),i,j,k,h,m),2);
                                }
                                if (h <> j and m <> j)
                                {
                                    l[size(l)+1] = list(graph43(list(1,1,1,1),i,j,k,h,m),24);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    if (d == 5)
    {
        for (i=0;i<=r;i++)
        {
            for (j=0;j<=r;j++)
            {
                for (k=0;k<=r;k++)
                {
                    if (i <> j and j <> k)
                    {
                        l[size(l)+1] = list(graph2(list(4,1),i,j,k),4);
                        l[size(l)+1] = list(graph2(list(3,2),i,j,k),6);
                        for (h=0;h<=r;h++)
                        {
                            if (k <> h)
                            {
                                l[size(l)+1] = list(graph31(list(3,1,1),i,j,k,h),3);
                                l[size(l)+1] = list(graph31(list(1,3,1),i,j,k,h),6);
                                l[size(l)+1] = list(graph31(list(2,2,1),i,j,k,h),4);
                                l[size(l)+1] = list(graph31(list(2,1,2),i,j,k,h),8);
                            }
                            if (j <> h)
                            {
                                l[size(l)+1] = list(graph32(list(3,1,1),i,j,k,h),6);
                                l[size(l)+1] = list(graph32(list(2,2,1),i,j,k,h),8);
                            }
                            for (m=0;m<=r;m++)
                            {
                                if (k <> h and h <> m)
                                {
                                    l[size(l)+1] = list(graph41(list(2,1,1,1),i,j,k,h,m),2);
                                    l[size(l)+1] = list(graph41(list(1,2,1,1),i,j,k,h,m),2);
                                }
                                if (k <> h and k <> m)
                                {
                                    l[size(l)+1] = list(graph42(list(2,1,1,1),i,j,k,h,m),4);
                                    l[size(l)+1] = list(graph42(list(1,2,1,1),i,j,k,h,m),4);
                                    l[size(l)+1] = list(graph42(list(1,1,2,1),i,j,k,h,m),2);
                                }
                                if (j <> h and j <> m)
                                {
                                    l[size(l)+1] = list(graph43(list(2,1,1,1),i,j,k,h,m),12);
                                }
                                for (n=0;n<=r;n++)
                                {
                                    if (k <> h and h <> m and m <> n)
                                    {
                                        l[size(l)+1] = list(graph51(list(1,1,1,1,1),i,j,k,h,m,n),2);
                                    }
                                    if (k <> h and h <> m and h <> n)
                                    {
                                        l[size(l)+1] = list(graph52(list(1,1,1,1,1),i,j,k,h,m,n),2);
                                    }
                                    if (k <> h and k <> m and k <> n)
                                    {
                                        l[size(l)+1] = list(graph53(list(1,1,1,1,1),i,j,k,h,m,n),6);
                                    }
                                    if (j <> h and h <> m and h <> n)
                                    {
                                        l[size(l)+1] = list(graph54(list(1,1,1,1,1),i,j,k,h,m,n),8);
                                    }
                                    if (k <> h and k <> m and h <> n)
                                    {
                                        l[size(l)+1] = list(graph55(list(1,1,1,1,1),i,j,k,h,m,n),2);
                                    }
                                    if (j <> h and j <> m and j <> n)
                                    {
                                        l[size(l)+1] = list(graph56(list(1,1,1,1,1),i,j,k,h,m,n),120);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    if (d == 6)
    {
        for (i=0;i<=r;i++)
        {
            for (j=0;j<=r;j++)
            {
                for (k=0;k<=r;k++)
                {
                    if (i <> j and j <> k)
                    {
                        l[size(l)+1] = list(graph2(list(5,1),i,j,k),5);
                        l[size(l)+1] = list(graph2(list(4,2),i,j,k),8);
                        l[size(l)+1] = list(graph2(list(3,3),i,j,k),18);
                        for (h=0;h<=r;h++)
                        {
                            if (k <> h)
                            {
                                l[size(l)+1] = list(graph31(list(4,1,1),i,j,k,h),4);
                                l[size(l)+1] = list(graph31(list(1,4,1),i,j,k,h),8);
                                l[size(l)+1] = list(graph31(list(3,2,1),i,j,k,h),6);
                                l[size(l)+1] = list(graph31(list(3,1,2),i,j,k,h),6);
                                l[size(l)+1] = list(graph31(list(1,3,2),i,j,k,h),6);
                                l[size(l)+1] = list(graph31(list(2,2,2),i,j,k,h),16);
                            }
                            if (j <> h)
                            {
                                l[size(l)+1] = list(graph32(list(4,1,1),i,j,k,h),8);
                                l[size(l)+1] = list(graph32(list(3,2,1),i,j,k,h),6);
                                l[size(l)+1] = list(graph32(list(2,2,2),i,j,k,h),48);
                            }
                            for (m=0;m<=r;m++)
                            {
                                if (k <> h and h <> m)
                                {
                                    l[size(l)+1] = list(graph41(list(3,1,1,1),i,j,k,h,m),3);
                                    l[size(l)+1] = list(graph41(list(1,3,1,1),i,j,k,h,m),3);
                                    l[size(l)+1] = list(graph41(list(2,2,1,1),i,j,k,h,m),4);
                                    l[size(l)+1] = list(graph41(list(2,1,2,1),i,j,k,h,m),4);
                                    l[size(l)+1] = list(graph41(list(2,1,1,2),i,j,k,h,m),8);
                                    l[size(l)+1] = list(graph41(list(1,2,2,1),i,j,k,h,m),8);
                                }
                                if (k <> h and k <> m)
                                {
                                    l[size(l)+1] = list(graph42(list(3,1,1,1),i,j,k,h,m),6);
                                    l[size(l)+1] = list(graph42(list(1,3,1,1),i,j,k,h,m),6);
                                    l[size(l)+1] = list(graph42(list(1,1,3,1),i,j,k,h,m),3);
                                    l[size(l)+1] = list(graph42(list(2,2,1,1),i,j,k,h,m),8);
                                    l[size(l)+1] = list(graph42(list(1,1,2,2),i,j,k,h,m),8);
                                    l[size(l)+1] = list(graph42(list(2,1,2,1),i,j,k,h,m),4);
                                    l[size(l)+1] = list(graph42(list(1,2,2,1),i,j,k,h,m),4);
                                }
                                if (j <> h and j <> m)
                                {
                                    l[size(l)+1] = list(graph43(list(3,1,1,1),i,j,k,h,m),18);
                                    l[size(l)+1] = list(graph43(list(2,2,1,1),i,j,k,h,m),16);
                                }
                                for (n=0;n<=r;n++)
                                {
                                    if (k <> h and h <> m and m <> n)
                                    {
                                        l[size(l)+1] = list(graph51(list(2,1,1,1,1),i,j,k,h,m,n),2);
                                        l[size(l)+1] = list(graph51(list(1,2,1,1,1),i,j,k,h,m,n),2);
                                        l[size(l)+1] = list(graph51(list(1,1,2,1,1),i,j,k,h,m,n),4);
                                    }
                                    if (k <> h and h <> m and h <> n)
                                    {
                                        l[size(l)+1] = list(graph52(list(2,1,1,1,1),i,j,k,h,m,n),4);
                                        l[size(l)+1] = list(graph52(list(1,2,1,1,1),i,j,k,h,m,n),4);
                                        l[size(l)+1] = list(graph52(list(1,1,2,1,1),i,j,k,h,m,n),4);
                                        l[size(l)+1] = list(graph52(list(1,1,1,2,1),i,j,k,h,m,n),2);
                                    }
                                    if (k <> h and k <> m and k <> n)
                                    {
                                        l[size(l)+1] = list(graph53(list(2,1,1,1,1),i,j,k,h,m,n),12);
                                        l[size(l)+1] = list(graph53(list(1,2,1,1,1),i,j,k,h,m,n),12);
                                        l[size(l)+1] = list(graph53(list(1,1,2,1,1),i,j,k,h,m,n),4);
                                    }
                                    if (j <> h and h <> m and h <> n)
                                    {
                                        l[size(l)+1] = list(graph54(list(2,1,1,1,1),i,j,k,h,m,n),4);
                                        l[size(l)+1] = list(graph54(list(1,1,2,1,1),i,j,k,h,m,n),16);
                                    }
                                    if (k <> h and k <> m and h <> n)
                                    {
                                        l[size(l)+1] = list(graph55(list(2,1,1,1,1),i,j,k,h,m,n),2);
                                        l[size(l)+1] = list(graph55(list(1,2,1,1,1),i,j,k,h,m,n),2);
                                        l[size(l)+1] = list(graph55(list(1,1,1,2,1),i,j,k,h,m,n),4);
                                    }
                                    if (j <> h and j <> m and j <> n)
                                    {
                                        l[size(l)+1] = list(graph56(list(2,1,1,1,1),i,j,k,h,m,n),48);
                                    }
                                    for (p=0;p<=r;p++)
                                    {
                                        if (k <> h and h <> m and m <> n and n <> p)
                                        {
                                            l[size(l)+1] = list(graph61(list(1,1,1,1,1,1),i,j,k,h,m,n,p),2);
                                        }
                                        if (k <> h and h <> m and m <> n and m <> p)
                                        {
                                            l[size(l)+1] = list(graph62(list(1,1,1,1,1,1),i,j,k,h,m,n,p),2);
                                        }
                                        if (k <> h and h <> m and h <> n and n <> p)
                                        {
                                            l[size(l)+1] = list(graph63(list(1,1,1,1,1,1),i,j,k,h,m,n,p),1);
                                        }
                                        if (k <> h and h <> m and h <> n and h <> p)
                                        {
                                            l[size(l)+1] = list(graph64(list(1,1,1,1,1,1),i,j,k,h,m,n,p),6);
                                        }
                                        if (k <> h and k <> m and k <> n and n <> p)
                                        {
                                            l[size(l)+1] = list(graph65(list(1,1,1,1,1,1),i,j,k,h,m,n,p),4);
                                        }
                                        if (k <> h and k <> m and m <> p and h <> n)
                                        {
                                            l[size(l)+1] = list(graph66(list(1,1,1,1,1,1),i,j,k,h,m,n,p),6);
                                        }
                                        if (j <> h and h <> m and m <> n and m <> p)
                                        {
                                            l[size(l)+1] = list(graph67(list(1,1,1,1,1,1),i,j,k,h,m,n,p),8);
                                        }
                                        if (j <> h and h <> m and h <> n and h <> p)
                                        {
                                            l[size(l)+1] = list(graph68(list(1,1,1,1,1,1),i,j,k,h,m,n,p),12);
                                        }
                                        if (j <> h and h <> m and h <> n and n <> p)
                                        {
                                            l[size(l)+1] = list(graph69(list(1,1,1,1,1,1),i,j,k,h,m,n,p),2);
                                        }
                                        if (k <> h and k <> m and k <> n and k <> p)
                                        {
                                            l[size(l)+1] = list(graph610(list(1,1,1,1,1,1),i,j,k,h,m,n,p),24);
                                        }
                                        if (j <> h and j <> m and j <> n and j <> p)
                                        {
                                            l[size(l)+1] = list(graph611(list(1,1,1,1,1,1),i,j,k,h,m,n,p),720);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return (l);
}
example
{
    "EXAMPLE:"; echo=2;
    ring r = 0,x,dp;
    variety P = projectiveSpace(4);
    stack M = moduliSpace(P,2);
    def F = fixedPoints(M);
    size(F);
    typeof(F[1]) == "list";
    typeof(F[1][1]) == "graph";
    typeof(F[1][2]) == "int";
}

static proc torusList(variety P)
"USAGE:     torusList(P); P variety
RETURN:     list
INPUT:      P is a projective space
OUTPUT:     a list of numbers
THEORY:     This is a procedure concerning the enumeration of rational curves.
KEYWORDS:   torus action
EXAMPLE:    example torusList; shows an example
"
{
    int i;
    int n = P.dimension;
    list l;
    for (i=0;i<=n;i++)
    {
        l = insert(l,number(10^i),size(l));
    }
    return (l);
}
example
{
    "EXAMPLE:"; echo=2;
    ring r = 0,x,dp;
    variety P = projectiveSpace(4);
    def L = torusList(P);
    L;
}

proc contributionBundle(stack M, graph G, list #)
"USAGE:     contributionBundle(M,G,#); M stack, G graph, # list
RETURN:     number
INPUT:      M is a moduli space of stable maps, G is a graph, # is a list.
OUTPUT:     a number corresponding to the contribution bundle on a moduli space
            of stable maps at a fixed point component (graph)
KEYWORDS:   contribution bundle, graph, multiple cover, rational curve,
SEE ALSO:   normalBundle
EXAMPLE:    example contributionBundle; shows an example
"
{
    def R = basering;
    setring R;
    int i,j,a;
    variety P = M.currentVariety;
    def L = torusList(P);
    int r = P.dimension;
    int d;
    if (size(#)==0) {d = 2*r - 3;}
    else
    {
        if (typeof(#[1]) == "int") {d = #[1];}
        else {Error("invalid optional argument");}
    }
    list e = G.edges;
    list v = G.vertices;
    number E = 1;
    number V = 1;
    if (r == 1)
    {
        for (i=1;i<=size(v);i++)
        {
            V = V*(-L[v[i][1]+1])^(v[i][2]-1);
        }
        for (j=1;j<=size(e);j++)
        {
            number f = 1;
            if (e[j][3]<>1)
            {
                for (a=1;a<e[j][3];a++)
                {
                    f=f*(-a*L[e[j][1]+1]-(e[j][3]-a)*L[e[j][2]+1])/e[j][3];
                }
            }
            E = E*f;
            kill f;
        }
        return ((E*V)^2);
    }
    else
    {
        for (i=1;i<=size(v);i++)
        {
            V = V*((d*L[v[i][1]+1])^(v[i][2]-1));
        }
        for (j=1;j<=size(e);j++)
        {
            number f = 1;
            for (a=0;a<=d*e[j][3];a++)
            {
                f = f*((a*L[e[j][1]+1]+(d*e[j][3]-a)*L[e[j][2]+1])/e[j][3]);
            }
            E = E*f;
            kill f;
        }
        return (E/V);
    }
}
example
{
    "EXAMPLE:"; echo=2;
    ring r = 0,x,dp;
    variety P = projectiveSpace(4);
    stack M = moduliSpace(P,2);
    def F = fixedPoints(M);
    graph G = F[1][1];
    number f = contributionBundle(M,G);
    number g = contributionBundle(M,G,5);
    f == g;
}

proc normalBundle(stack M, graph G)
"USAGE:     normalBundle(M,G); M stack, G graph
RETURN:     number
INPUT:      M is a moduli space of stable maps, G is a graph
OUTPUT:     a number corresponding to the normal bundle on a moduli space of
            stable maps at a graph
KEYWORDS:   normal bundle, graph, rational curves, multiple covers, lines on
            hypersurfaces
SEE ALSO:   contributionBundle
EXAMPLE:    example normalBundle; shows an example
{
    def R = basering;
    setring R;
    variety P = M.currentVariety;
    def L = torusList(P);
    int n = P.dimension;
    list e = G.edges;
    list v = G.vertices;
    int i,j,k,h,b,m,a;
    number N = 1;
    for (j=1;j<=size(e);j++)
    {
        int d = e[j][3];
        number c = (-1)^d*factorial(d)^2;
        number y = c*(L[e[j][1]+1]-L[e[j][2]+1])^(2*d)/(number(d)^(2*d));
        for (k=0;k<=n;k++)
        {
            if (k <> e[j][1] and k <> e[j][2])
            {
                for (a=0;a<=d;a++)
                {
                    y=y*((a*L[e[j][1]+1]+(d-a)*L[e[j][2]+1])/d - L[k+1]);
                }
            }
        }
        N = N*y;
        kill y,d,c;
    }
    for (i=1;i<=size(v);i++)
    {
        number F = 1;
        for (h=3;h<=size(v[i]);h++)
        {
            F = F*(L[v[i][h][1]+1]-L[v[i][h][2]+1])/v[i][h][3];
        }
        if (v[i][2] == 1)
        {
            N = N/F;
            kill F;
        }
        else
        {
            number z = 1;
            for (m=0;m<=n;m++)
            {
                if (m<>v[i][1])
                {
                    z = z*(L[v[i][1]+1]-L[m+1]);
                }
            }
            if (v[i][2] == 3)
            {
                N = N*F/z^2;
                kill F,z;
            }
            else
            {
                number g = 0;
                for (b=3;b<=size(v[i]);b++)
                {
                    g = g + v[i][b][3]/(L[v[i][b][1]+1]-L[v[i][b][2]+1]);
                }
                N = N*F*g^(3-v[i][2])/(z^(v[i][2]-1));
                kill g,F,z;
            }
        }
    }
    return (N);
}
example
{
    "EXAMPLE:"; echo=2;
    ring r = 0,x,dp;
    variety P = projectiveSpace(4);
    stack M = moduliSpace(P,2);
    def F = fixedPoints(M);
    graph G = F[1][1];
    number f = normalBundle(M,G);
    f <> 0;
}

proc multipleCover(int d)
"USAGE:     multipleCover(d); d int
RETURN:     number
THEORY:     This is the contribution of degree d multiple covers of a smooth
            rational curve as a Gromov-Witten invariant.
KEYWORDS:   Gromov-Witten invariants, multiple covers
SEE ALSO:   rationalCurve, linesHypersurface
EXAMPLE:    example multipleCover; shows an example
"
{
    def R = basering;
    setring R;
    variety P = projectiveSpace(1);
    stack M = moduliSpace(P,d);
    def F = fixedPoints(M);
    int i;
    number r = 0;
    for (i=1;i<=size(F);i++)
    {
        graph G = F[i][1];
        number s = contributionBundle(M,G);
        number t = F[i][2]*normalBundle(M,G);
        r = r + s/t;
        kill s,t,G;
    }
    return (r);
}
example
{
    "EXAMPLE:"; echo=2;
    ring r = 0,x,dp;
    multipleCover(1);
    multipleCover(2);
    multipleCover(3);
    multipleCover(4);
    multipleCover(5);
    multipleCover(6);
}

proc linesHypersurface(int n)
"USAGE:     linesHypersurface(n); n int
RETURN:     number
THEORY:     This is the number of lines on a general hypersurface of degree
            d = 2n-3 in an n-dimensional projective space.
KEYWORDS:   Gromov-Witten invariants, lines on hypersurfaces
SEE ALSO:   linesHypersurface, multipleCover
EXAMPLE:    example linesHypersurface; shows an example
"
{
    def R = basering;
    setring R;
    variety P = projectiveSpace(n);
    stack M = moduliSpace(P,1);
    def F = fixedPoints(M);
    int i;
    number r = 0;
    for (i=1;i<=size(F);i++)
    {
        graph G = F[i][1];
        number s = contributionBundle(M,G);
        number t = F[i][2]*normalBundle(M,G);
        r = r + s/t;
        kill s,t,G;
    }
    return (r);
}
example
{
    "EXAMPLE:"; echo=2;
    ring r = 0,x,dp;
    linesHypersurface(2);
    linesHypersurface(3);
    linesHypersurface(4);
    linesHypersurface(5);
    linesHypersurface(6);
    linesHypersurface(7);
    linesHypersurface(8);
    linesHypersurface(9);
    linesHypersurface(10);
}

proc sumofquotients(stack M, list F, list #)
"USAGE:     sumofquotient(M,F,#); M stack, F list, # list
RETURN:     number
THEORY:     This is useful for the parallel computation of rationalCurve.
KEYWORDS:   Gromov-Witten invariants, rational curves on Calabi-Yau threefolds
EXAMPLE:    example sumofquotients; shows an example
"
{
    if (size(#) == 0) {list l = 5;}
    else {list l = #;}
    number sum = 0;
    number s, t;
    int i,j;
    for (i = size(F); i > 0; i--)
    {
        s = 1;
        for (j=1;j<=size(l);j++)
        {
            s = s*contributionBundle(M,F[i][1],list(l[j]));
        }
        t = F[i][2]*normalBundle(M,F[i][1]);
        sum = sum + s/t;
    }
    return(sum);
}
example
{
    "EXAMPLE:"; echo=2;
    ring r = 0,x,dp;
    variety P = projectiveSpace(4);
    stack M = moduliSpace(P,2);
    list F = fixedPoints(M);
    sumofquotients(M,F);
    sumofquotients(M,F,list(5));
}

proc rationalCurve(int d, list #)
"USAGE:     rationalCurve(d,#); d int, # list
RETURN:     number
THEORY:     This is the Gromov-Witten invariant corresponding the number of
            rational curves on a general Calabi-Yau threefold.
KEYWORDS:   Gromov-Witten invariants, rational curves on Calabi-Yau threefolds
SEE ALSO:   linesHypersurface, multipleCover
EXAMPLE:    example rationalCurve; shows an example
"
{
    def R = basering;
    setring R;
    int n,i;
    if (size(#) == 0) {n = 4; list l = 5;}
    else {n = size(#)+3; list l = #;}
    variety P = projectiveSpace(n);
    stack M = moduliSpace(P,d);
    def F = fixedPoints(M);
    int ncpus = system("--cpus");
    int sizeF = size(F);
    list args;
    int from = 1;
    int to;
    if (ncpus>sizeF) { ncpus=sizeF; }
    for (i = 1; i <= ncpus; i++)
    {
        to = (sizeF*i) div ncpus;
        args[i] = list(M, list(F[from..to]), l);
        from = to+1;
    }
    list results = parallelWaitAll("sumofquotients", args);
    number r = 0;
    for (i = 1; i <= ncpus; i++)
    {
        r = r + results[i];
    }
    return (r);
}
example
{
    "EXAMPLE:"; echo=2;
    ring r = 0,x,dp;
    rationalCurve(1);
    /*
    rationalCurve(2);
    rationalCurve(3);
    rationalCurve(4);
    rationalCurve(1,list(4,2));
    rationalCurve(1,list(3,3));
    rationalCurve(1,list(3,2,2));
    rationalCurve(1,list(2,2,2,2));
    rationalCurve(2,list(4,2));
    rationalCurve(2,list(3,3));
    rationalCurve(2,list(3,2,2));
    rationalCurve(2,list(2,2,2,2));
    rationalCurve(3,list(4,2));
    rationalCurve(3,list(3,3));
    rationalCurve(3,list(3,2,2));
    rationalCurve(3,list(2,2,2,2));
    rationalCurve(4,list(4,2));
    rationalCurve(4,list(3,3));
    rationalCurve(4,list(3,2,2));
    rationalCurve(4,list(2,2,2,2));
    */
}

////////////////////////////////////////////////////////////////////////////////
/////////// Procedures concerned with graphs ///////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

proc printGraphG(graph G)
"USAGE:     printGraphG(G); G graph
ASSUME:     G is a graph.
THEORY:     This is the print function used by Singular to print a graph.
KEYWORDS:   graph
EXAMPLE:    example printGraphG; shows an example
"
{
    "A graph with", size(G.vertices), "vertices and", size(G.edges), "edges";
}
example
{
    "EXAMPLE:"; echo=2;
    ring r = 0,x,dp;
    graph G = makeGraphVE(list(list(0,1,list(0,1,2)),list(1,1,list(1,0,2))),
    list(list(0,1,2)));
    G;
}

proc makeGraphVE(list v, list e)
"USAGE:     makeGraphVE(v,e); v list, e list
ASSUME:     v is a list of vertices, e is a list of edges.
RETURN:     graph with vertices v and edges e.
THEORY:     Creates a graph from a list of vertices and edges.
KEYWORDS:   graph
EXAMPLE:    example makeGraphVE; shows an example
{
    graph G;
    G.vertices = v;
    G.edges = e;
    return(G);
}
example
{
    "EXAMPLE:"; echo=2;
    ring r = 0,x,dp;
    graph G = makeGraphVE(list(list(0,1,list(0,1,2)),list(1,1,list(1,0,2))),
    list(list(0,1,2)));
    G;
}

static proc graph1(int d, int i, int j)
{
    graph G;
    list f1 = i,j,d;
    list f2 = j,i,d;
    list v1 = i,1,f1;
    list v2 = j,1,f2;
    G.vertices = v1,v2;
    G.edges = list(f1);
    return (G);
}

static proc graph2(list d, int i, int j, int k)
{
    graph G;
    list f1 = i,j,d[1];
    list f2 = j,i,d[1];
    list f3 = j,k,d[2];
    list f4 = k,j,d[2];
    list v1 = i,1,f1;
    list v2 = j,2,f2,f3;
    list v3 = k,1,f4;
    G.vertices = v1,v2,v3;
    G.edges = f1,f3;
    return (G);
}

static proc graph31(list d, int i, int j, int k, int h)
{
    graph G;
    list f1 = i,j,d[1];
    list f2 = j,i,d[1];
    list f3 = j,k,d[2];
    list f4 = k,j,d[2];
    list f5 = k,h,d[3];
    list f6 = h,k,d[3];
    list v1 = i,1,f1;
    list v2 = j,2,f2,f3;
    list v3 = k,2,f4,f5;
    list v4 = h,1,f6;
    G.vertices = v1,v2,v3,v4;
    G.edges = f1,f3,f5;
    return (G);
}

static proc graph32(list d, int i, int j, int k, int h)
{
    graph G;
    list f1 = i,j,d[1];
    list f2 = j,i,d[1];
    list f3 = j,k,d[2];
    list f4 = j,h,d[3];
    list f5 = k,j,d[2];
    list f6 = h,j,d[3];
    list v1 = i,1,f1;
    list v2 = j,3,f2,f3,f4;
    list v3 = k,1,f5;
    list v4 = h,1,f6;
    G.vertices = v1,v2,v3,v4;
    G.edges = f1,f3,f4;
    return (G);
}

static proc graph41(list d, int i, int j, int k, int h, int l)
{
    graph G;
    list f1 = i,j,d[1];
    list f2 = j,i,d[1];
    list f3 = j,k,d[2];
    list f4 = k,j,d[2];
    list f5 = k,h,d[3];
    list f6 = h,k,d[3];
    list f7 = h,l,d[4];
    list f8 = l,h,d[4];
    list v1 = i,1,f1;
    list v2 = j,2,f2,f3;
    list v3 = k,2,f4,f5;
    list v4 = h,2,f6,f7;
    list v5 = l,1,f8;
    G.vertices = v1,v2,v3,v4,v5;
    G.edges = f1,f3,f5,f7;
    return (G);
}

static proc graph42(list d, int i, int j, int k, int h, int l)
{
    graph G;
    list f1 = i,j,d[1];
    list f2 = j,i,d[1];
    list f3 = j,k,d[2];
    list f4 = k,j,d[2];
    list f5 = k,h,d[3];
    list f6 = k,l,d[4];
    list f7 = h,k,d[3];
    list f8 = l,k,d[4];
    list v1 = i,1,f1;
    list v2 = j,2,f2,f3;
    list v3 = k,3,f4,f5,f6;
    list v4 = h,1,f7;
    list v5 = l,1,f8;
    G.vertices = v1,v2,v3,v4,v5;
    G.edges = f1,f3,f5,f6;
    return (G);
}

static proc graph43(list d, int i, int j, int k, int h, int l)
{
    graph G;
    list f1 = i,j,d[1];
    list f2 = j,i,d[1];
    list f3 = j,k,d[2];
    list f4 = j,h,d[3];
    list f5 = j,l,d[4];
    list f6 = k,j,d[2];
    list f7 = h,j,d[3];
    list f8 = l,j,d[4];
    list v1 = i,1,f1;
    list v2 = j,4,f2,f3,f4,f5;
    list v3 = k,1,f6;
    list v4 = h,1,f7;
    list v5 = l,1,f8;
    G.vertices = v1,v2,v3,v4,v5;
    G.edges = f1,f3,f4,f5;
    return (G);
}

static proc graph51(list d, int i, int j, int k, int h, int m, int n)
{
    graph G;
    list f1 = i,j,d[1];
    list f2 = j,i,d[1];
    list f3 = j,k,d[2];
    list f4 = k,j,d[2];
    list f5 = k,h,d[3];
    list f6 = h,k,d[3];
    list f7 = h,m,d[4];
    list f8 = m,h,d[4];
    list f9 = m,n,d[5];
    list f10 = n,m,d[5];
    list v1 = i,1,f1;
    list v2 = j,2,f2,f3;
    list v3 = k,2,f4,f5;
    list v4 = h,2,f6,f7;
    list v5 = m,2,f8,f9;
    list v6 = n,1,f10;
    G.vertices = v1,v2,v3,v4,v5,v6;
    G.edges = f1,f3,f5,f7,f9;
    return (G);
}

static proc graph52(list d, int i, int j, int k, int h, int m, int n)
{
    graph G;
    list f1 = i,j,d[1];
    list f2 = j,i,d[1];
    list f3 = j,k,d[2];
    list f4 = k,j,d[2];
    list f5 = k,h,d[3];
    list f6 = h,k,d[3];
    list f7 = h,m,d[4];
    list f8 = m,h,d[4];
    list f9 = h,n,d[5];
    list f10 = n,h,d[5];
    list v1 = i,1,f1;
    list v2 = j,2,f2,f3;
    list v3 = k,2,f4,f5;
    list v4 = h,3,f6,f7,f9;
    list v5 = m,1,f8;
    list v6 = n,1,f10;
    G.vertices = v1,v2,v3,v4,v5,v6;
    G.edges = f1,f3,f5,f7,f9;
    return (G);
}

static proc graph53(list d, int i, int j, int k, int h, int m, int n)
{
    graph G;
    list f1 = i,j,d[1];
    list f2 = j,i,d[1];
    list f3 = j,k,d[2];
    list f4 = k,j,d[2];
    list f5 = k,h,d[3];
    list f6 = h,k,d[3];
    list f7 = k,m,d[4];
    list f8 = m,k,d[4];
    list f9 = k,n,d[5];
    list f10 = n,k,d[5];
    list v1 = i,1,f1;
    list v2 = j,2,f2,f3;
    list v3 = k,4,f4,f5,f7,f9;
    list v4 = h,1,f6;
    list v5 = m,1,f8;
    list v6 = n,1,f10;
    G.vertices = v1,v2,v3,v4,v5,v6;
    G.edges = f1,f3,f5,f7,f9;
    return (G);
}

static proc graph54(list d, int i, int j, int k, int h, int m, int n)
{
    graph G;
    list f1 = i,j,d[1];
    list f2 = j,i,d[1];
    list f3 = j,k,d[2];
    list f4 = k,j,d[2];
    list f5 = j,h,d[3];
    list f6 = h,j,d[3];
    list f7 = h,m,d[4];
    list f8 = m,h,d[4];
    list f9 = h,n,d[5];
    list f10 = n,h,d[5];
    list v1 = i,1,f1;
    list v2 = j,3,f2,f3,f5;
    list v3 = k,1,f4;
    list v4 = h,3,f6,f7,f9;
    list v5 = m,1,f8;
    list v6 = n,1,f10;
    G.vertices = v1,v2,v3,v4,v5,v6;
    G.edges = f1,f3,f5,f7,f9;
    return (G);
}

static proc graph55(list d, int i, int j, int k, int h, int m, int n)
{
    graph G;
    list f1 = i,j,d[1];
    list f2 = j,i,d[1];
    list f3 = j,k,d[2];
    list f4 = k,j,d[2];
    list f5 = k,h,d[3];
    list f6 = h,k,d[3];
    list f7 = k,m,d[4];
    list f8 = m,k,d[4];
    list f9 = h,n,d[5];
    list f10 = n,h,d[5];
    list v1 = i,1,f1;
    list v2 = j,2,f2,f3;
    list v3 = k,3,f4,f5,f7;
    list v4 = h,2,f6,f9;
    list v5 = m,1,f8;
    list v6 = n,1,f10;
    G.vertices = v1,v2,v3,v4,v5,v6;
    G.edges = f1,f3,f5,f7,f9;
    return (G);
}

static proc graph56(list d, int i, int j, int k, int h, int m, int n)
{
    graph G;
    list f1 = i,j,d[1];
    list f2 = j,i,d[1];
    list f3 = j,k,d[2];
    list f4 = k,j,d[2];
    list f5 = j,h,d[3];
    list f6 = h,j,d[3];
    list f7 = j,m,d[4];
    list f8 = m,j,d[4];
    list f9 = j,n,d[5];
    list f10 = n,j,d[5];
    list v1 = i,1,f1;
    list v2 = j,5,f2,f3,f5,f7,f9;
    list v3 = k,1,f4;
    list v4 = h,1,f6;
    list v5 = m,1,f8;
    list v6 = n,1,f10;
    G.vertices = v1,v2,v3,v4,v5,v6;
    G.edges = f1,f3,f5,f7,f9;
    return (G);
}

static proc graph61(list d, int i, int j, int k, int h, int m, int n, int p)
{
    graph G;
    list f1 = i,j,d[1];
    list f2 = j,i,d[1];
    list f3 = j,k,d[2];
    list f4 = k,j,d[2];
    list f5 = k,h,d[3];
    list f6 = h,k,d[3];
    list f7 = h,m,d[4];
    list f8 = m,h,d[4];
    list f9 = m,n,d[5];
    list f10 = n,m,d[5];
    list f11 = n,p,d[6];
    list f12 = p,n,d[6];
    list v1 = i,1,f1;
    list v2 = j,2,f2,f3;
    list v3 = k,2,f4,f5;
    list v4 = h,2,f6,f7;
    list v5 = m,2,f8,f9;
    list v6 = n,2,f10,f11;
    list v7 = p,1,f12;
    G.vertices = v1,v2,v3,v4,v5,v6,v7;
    G.edges = f1,f3,f5,f7,f9,f11;
    return (G);
}

static proc graph62(list d, int i, int j, int k, int h, int m, int n, int p)
{
    graph G;
    list f1 = i,j,d[1];
    list f2 = j,i,d[1];
    list f3 = j,k,d[2];
    list f4 = k,j,d[2];
    list f5 = k,h,d[3];
    list f6 = h,k,d[3];
    list f7 = h,m,d[4];
    list f8 = m,h,d[4];
    list f9 = m,n,d[5];
    list f10 = n,m,d[5];
    list f11 = m,p,d[6];
    list f12 = p,m,d[6];
    list v1 = i,1,f1;
    list v2 = j,2,f2,f3;
    list v3 = k,2,f4,f5;
    list v4 = h,2,f6,f7;
    list v5 = m,3,f8,f9,f11;
    list v6 = n,1,f10;
    list v7 = p,1,f12;
    G.vertices = v1,v2,v3,v4,v5,v6,v7;
    G.edges = f1,f3,f5,f7,f9,f11;
    return (G);
}

static proc graph63(list d, int i, int j, int k, int h, int m, int n, int p)
{
    graph G;
    list f1 = i,j,d[1];
    list f2 = j,i,d[1];
    list f3 = j,k,d[2];
    list f4 = k,j,d[2];
    list f5 = k,h,d[3];
    list f6 = h,k,d[3];
    list f7 = h,m,d[4];
    list f8 = m,h,d[4];
    list f9 = h,n,d[5];
    list f10 = n,h,d[5];
    list f11 = n,p,d[6];
    list f12 = p,n,d[6];
    list v1 = i,1,f1;
    list v2 = j,2,f2,f3;
    list v3 = k,2,f4,f5;
    list v4 = h,3,f6,f7,f9;
    list v5 = m,1,f8;
    list v6 = n,2,f10,f11;
    list v7 = p,1,f12;
    G.vertices = v1,v2,v3,v4,v5,v6,v7;
    G.edges = f1,f3,f5,f7,f9,f11;
    return (G);
}

static proc graph64(list d, int i, int j, int k, int h, int m, int n, int p)
{
    graph G;
    list f1 = i,j,d[1];
    list f2 = j,i,d[1];
    list f3 = j,k,d[2];
    list f4 = k,j,d[2];
    list f5 = k,h,d[3];
    list f6 = h,k,d[3];
    list f7 = h,m,d[4];
    list f8 = m,h,d[4];
    list f9 = h,n,d[5];
    list f10 = n,h,d[5];
    list f11 = h,p,d[6];
    list f12 = p,h,d[6];
    list v1 = i,1,f1;
    list v2 = j,2,f2,f3;
    list v3 = k,2,f4,f5;
    list v4 = h,4,f6,f7,f9,f11;
    list v5 = m,1,f8;
    list v6 = n,1,f10;
    list v7 = p,1,f12;
    G.vertices = v1,v2,v3,v4,v5,v6,v7;
    G.edges = f1,f3,f5,f7,f9,f11;
    return (G);
}

static proc graph65(list d, int i, int j, int k, int h, int m, int n, int p)
{
    graph G;
    list f1 = i,j,d[1];
    list f2 = j,i,d[1];
    list f3 = j,k,d[2];
    list f4 = k,j,d[2];
    list f5 = k,h,d[3];
    list f6 = h,k,d[3];
    list f7 = k,m,d[4];
    list f8 = m,k,d[4];
    list f9 = k,n,d[5];
    list f10 = n,k,d[5];
    list f11 = n,p,d[6];
    list f12 = p,n,d[6];
    list v1 = i,1,f1;
    list v2 = j,2,f2,f3;
    list v3 = k,4,f4,f5,f7,f9;
    list v4 = h,1,f6;
    list v5 = m,1,f8;
    list v6 = n,2,f10,f11;
    list v7 = p,1,f12;
    G.vertices = v1,v2,v3,v4,v5,v6,v7;
    G.edges = f1,f3,f5,f7,f9,f11;
    return (G);
}

static proc graph66(list d, int i, int j, int k, int h, int m, int n, int p)
{
    graph G;
    list f1 = i,j,d[1];
    list f2 = j,i,d[1];
    list f3 = j,k,d[2];
    list f4 = k,j,d[2];
    list f5 = k,h,d[3];
    list f6 = h,k,d[3];
    list f7 = k,m,d[4];
    list f8 = m,k,d[4];
    list f9 = h,n,d[5];
    list f10 = n,h,d[5];
    list f11 = m,p,d[6];
    list f12 = p,m,d[6];
    list v1 = i,1,f1;
    list v2 = j,2,f2,f3;
    list v3 = k,3,f4,f5,f7;
    list v4 = h,2,f6,f9;
    list v5 = m,2,f8,f11;
    list v6 = n,1,f10;
    list v7 = p,1,f12;
    G.vertices = v1,v2,v3,v4,v5,v6,v7;
    G.edges = f1,f3,f5,f7,f9,f11;
    return (G);
}

static proc graph67(list d, int i, int j, int k, int h, int m, int n, int p)
{
    graph G;
    list f1 = i,j,d[1];
    list f2 = j,i,d[1];
    list f3 = j,k,d[2];
    list f4 = k,j,d[2];
    list f5 = j,h,d[3];
    list f6 = h,j,d[3];
    list f7 = h,m,d[4];
    list f8 = m,h,d[4];
    list f9 = m,n,d[5];
    list f10 = n,m,d[5];
    list f11 = m,p,d[6];
    list f12 = p,m,d[6];
    list v1 = i,1,f1;
    list v2 = j,3,f2,f3,f5;
    list v3 = k,1,f4;
    list v4 = h,2,f6,f7;
    list v5 = m,3,f8,f9,f11;
    list v6 = n,1,f10;
    list v7 = p,1,f12;
    G.vertices = v1,v2,v3,v4,v5,v6,v7;
    G.edges = f1,f3,f5,f7,f9,f11;
    return (G);
}

static proc graph68(list d, int i, int j, int k, int h, int m, int n, int p)
{
    graph G;
    list f1 = i,j,d[1];
    list f2 = j,i,d[1];
    list f3 = j,k,d[2];
    list f4 = k,j,d[2];
    list f5 = j,h,d[3];
    list f6 = h,j,d[3];
    list f7 = h,m,d[4];
    list f8 = m,h,d[4];
    list f9 = h,n,d[5];
    list f10 = n,h,d[5];
    list f11 = h,p,d[6];
    list f12 = p,h,d[6];
    list v1 = i,1,f1;
    list v2 = j,3,f2,f3,f5;
    list v3 = k,1,f4;
    list v4 = h,4,f6,f7,f9,f11;
    list v5 = m,1,f8;
    list v6 = n,1,f10;
    list v7 = p,1,f12;
    G.vertices = v1,v2,v3,v4,v5,v6,v7;
    G.edges = f1,f3,f5,f7,f9,f11;
    return (G);
}

static proc graph69(list d, int i, int j, int k, int h, int m, int n, int p)
{
    graph G;
    list f1 = i,j,d[1];
    list f2 = j,i,d[1];
    list f3 = j,k,d[2];
    list f4 = k,j,d[2];
    list f5 = j,h,d[3];
    list f6 = h,j,d[3];
    list f7 = h,m,d[4];
    list f8 = m,h,d[4];
    list f9 = h,n,d[5];
    list f10 = n,h,d[5];
    list f11 = n,p,d[6];
    list f12 = p,n,d[6];
    list v1 = i,1,f1;
    list v2 = j,3,f2,f3,f5;
    list v3 = k,1,f4;
    list v4 = h,3,f6,f7,f9;
    list v5 = m,1,f8;
    list v6 = n,2,f10,f11;
    list v7 = p,1,f12;
    G.vertices = v1,v2,v3,v4,v5,v6,v7;
    G.edges = f1,f3,f5,f7,f9,f11;
    return (G);
}

static proc graph610(list d, int i, int j, int k, int h, int m, int n, int p)
{
    graph G;
    list f1 = i,j,d[1];
    list f2 = j,i,d[1];
    list f3 = j,k,d[2];
    list f4 = k,j,d[2];
    list f5 = k,h,d[3];
    list f6 = h,k,d[3];
    list f7 = k,m,d[4];
    list f8 = m,k,d[4];
    list f9 = k,n,d[5];
    list f10 = n,k,d[5];
    list f11 = k,p,d[6];
    list f12 = p,k,d[6];
    list v1 = i,1,f1;
    list v2 = j,2,f2,f3;
    list v3 = k,5,f4,f5,f7,f9,f11;
    list v4 = h,1,f6;
    list v5 = m,1,f8;
    list v6 = n,1,f10;
    list v7 = p,1,f12;
    G.vertices = v1,v2,v3,v4,v5,v6,v7;
    G.edges = f1,f3,f5,f7,f9,f11;
    return (G);
}

static proc graph611(list d, int i, int j, int k, int h, int m, int n, int p)
{
    graph G;
    list f1 = i,j,d[1];
    list f2 = j,i,d[1];
    list f3 = j,k,d[2];
    list f4 = k,j,d[2];
    list f5 = j,h,d[3];
    list f6 = h,j,d[3];
    list f7 = j,m,d[4];
    list f8 = m,j,d[4];
    list f9 = j,n,d[5];
    list f10 = n,j,d[5];
    list f11 = j,p,d[6];
    list f12 = p,j,d[6];
    list v1 = i,1,f1;
    list v2 = j,6,f2,f3,f5,f7,f9,f11;
    list v3 = k,1,f4;
    list v4 = h,1,f6;
    list v5 = m,1,f8;
    list v6 = n,1,f10;
    list v7 = p,1,f12;
    G.vertices = v1,v2,v3,v4,v5,v6,v7;
    G.edges = f1,f3,f5,f7,f9,f11;
    return (G);
}

proc homog_part(poly f, int n)
"USAGE:     homog_part(f,n); f poly, n int
RETURN:     poly
PURPOSE:    computing the homogeneous component of a polynomial.
EXAMPLE:    example homog_part; shows examples
"
{
    int i;
    poly p;
    for (i=1;i<=size(f);i++)
    {
        if (deg(f[i])==n) {p=p+f[i];}
    }
    return (p);
}
example
{
    "EXAMPLE:"; echo=2;
    ring r = 0,(x,y,z),wp(1,2,3);
    poly f = 1+x+x2+x3+x4+y+y2+y3+z+z2+xy+xz+yz+xyz;
    homog_part(f,0);
    homog_part(f,1);
    homog_part(f,2);
    homog_part(f,3);
    homog_part(f,4);
    homog_part(f,5);
    homog_part(f,6);
}

proc homog_parts(poly f, int i, int j)
"USAGE:     homog_parts(f,i,j); f poly, i int, j int
RETURN:     poly
THEORY:     computing a polynomial which is the sum of the homogeneous
            components of a polynomial.
EXAMPLE:    example homog_parts; shows examples
"
{
    int k;
    poly p;
    for (k=i;k<=j;k++)
    {
        p=p+homog_part(f,k);
    }
    return (p);
}
example
{
    "EXAMPLE:"; echo=2;
    ring r = 0,(x,y,z),wp(1,2,3);
    poly f = 1+x+x2+x3+x4+y+y2+y3+z+z2+xy+xz+yz+xyz;
    homog_parts(f,2,4);
}

proc logg(poly f, int n)
"USAGE:     logg(f,n); f poly, n int
RETURN:     poly
THEORY:     computing Chern characters from total Chern classes.
EXAMPLE:    example logg; shows examples
"
{
    poly p;
    int i,j,k,m;
    if (n==0) {p=0;}
    if (n==1) {p=homog_part(f,1);}
    else
    {
        list l=-homog_part(f,1);
        for (j=2;j<=n;j++)
        {
            poly q;
            for (k=1;k<j;k++)
            {
                q=q+homog_part(f,k)*l[j-k];
            }
            q=-j*homog_part(f,j)-q;
            l=insert(l,q,size(l));
            kill q;
        }
        for (m=1;m<=n;m++)
        {
            p=p+1/factorial(m)*(-1)^m*l[m];
        }
    }
    return (p);
}
example
{
    "EXAMPLE:"; echo=2;
    ring r = 0,(x,y),wp(1,2);
    poly f = 1+x+y;
    logg(f,4);
}

proc expp(poly f, int n)
"USAGE:     expp(f,n); f poly, n int
RETURN:     poly
PURPOSE:    computing total Chern classes from Chern characters.
EXAMPLE:    example expp; shows examples
"
{
    poly p;
    int i,j,k;
    if (deg(f)==0) {p=1;}
    else
    {
        list l=1;
        for (i=1;i<=n;i++)
        {
            poly q;
            for (j=1;j<=i;j++)
            {
                q=q+factorial(j)*(-1)^(j-1)*l[i-j+1]*homog_part(f,j)/i;
            }
            l=insert(l,q,size(l));
            kill q;
        }
        for (k=1;k<=size(l);k++)
        {
            p=p+l[k];
        }
    }
    return (p);
}
example
{
    "EXAMPLE:"; echo=2;
    ring r = 0,x,dp;
    poly f = 3+x;
    expp(f,3);
}

static proc adams(poly f, int n)
{
    poly p;
    int i;
    for (i=0;i<=deg(f);i++)
    {
        p=p+n^i*homog_part(f,i);
    }
    return (p);
}

static proc wedges(int n, poly f, int d)
{
    int i,j;
    list l;
    if (n==0) {l=1;}
    if (n==1) {l=1,f;}
    else
    {
        l=1,f;
        for (i=2;i<=n;i++)
        {
            poly q;
            for (j=1;j<=i;j++)
            {
                q=q+((-1)^(i-j))*homog_parts(l[j]*adams(f,i-j+1),0,d)/i;
            }
            l=insert(l,q,size(l));
            kill q;
        }
    }
    return (l);
}

static proc schur(list p, poly f)
{
    int i,j;
    int n = size(p);
    matrix M[n][n];
    for (i=1;i<=n;i++)
    {
        for (j=1;j<=n;j++)
        {
            M[i,j] = homog_part(f,p[i]+j-i);
        }
    }
    return (det(M));
}

////////////////////////////////////////////////////////////////////////////////
//////// Procedures concerned with abstract varieties //////////////////////////
////////////////////////////////////////////////////////////////////////////////

proc printVariety(variety V)
"USAGE:     printVariety(V); V variety
ASSUME:     V is an abstract variety
THEORY:     This is the print function used by Singular to print an abstract
            variety.
KEYWORDS:   abstract variety, projective space, Grassmannian
EXAMPLE:    example printVariety; shows an example
"
{
    "A variety of dimension", V.dimension;
}
example
{
    "EXAMPLE:"; echo=2;
    ring r = 0,(h,e),wp(1,1);
    ideal rels = he,h2+e2;
    variety V = makeVariety(2,rels);
    V;
}

proc makeVariety(int d, ideal i)
"USAGE:     makeVariety(d,i); d int, i ideal
ASSUME:     d is a nonnegative integer, i is an ideal
RETURN:     variety
THEORY:     create an abstract variety which has dimension d, and its Chow ring
            should be a quotient ring
KEYWORDS:   abstract variety, projective space, Grassmannian
EXAMPLE:    example makeVariety; shows an example
"
{
    def R = basering;
    variety V;
    V.dimension = d;
    V.baseRing = R;
    V.relations = i;
    return(V);
}
example
{
    "EXAMPLE:"; echo=2;
    ring r = 0,(h,e),wp(1,1);
    ideal rels = he,h2+e2;
    variety V = makeVariety(2,rels);
    V;
    V.dimension;
    V.relations;
}

proc ChowRing(variety V)
"USAGE:     ChowRing(V); V variety
ASSUME:     V is an abstract variety
RETURN:     qring
KEYWORDS:   Chow ring, abstract variety, projective space, Grassmannian
EXAMPLE:    example makeVariety; shows an example
"
{
    def R = V.baseRing;
    setring R;
    ideal rels = V.relations;
    qring CR = std(rels);
    return (CR);
}
example
{
    "EXAMPLE:"; echo=2;
    ring r = 0,(h,e),wp(1,1);
    ideal rels = he,h2+e2;
    int d = 2;
    variety V = makeVariety(2,rels);
    ChowRing(V);
}

////////////////////////////////////////////////////////////////////////////////

proc Grassmannian(int k, int n, list #)
"USAGE:     Grassmannian(k,n); k int, n int
RETURN:     variety
THEORY:     create a Grassmannian G(k,n) as an abstract variety. This abstract
            variety has diemnsion k(n-k) and its Chow ring is the quotient ring
            of a polynomial ring in n-k variables q(1),...,q(n-k), which are the
            Chern classes of tautological quotient bundle on G(k,n), modulo some
            ideal generated by n-k polynomials which come from the Giambelli
            formula. The monomial ordering of this Chow ring is 'wp' with vector
            (1..k,1..n-k). Moreover, we export the Chern characters of
            tautological subbundle and quotient bundle on G(k,n)
            (say 'subBundle' and 'quotientBundle').
KEYWORDS:   Grassmannian, abstract variety, Schubert calculus
SEE ALSO:   projectiveSpace, projectiveBundle
EXAMPLE:    example Grassmannian; shows examples
"
{
    string q;
    if (size(#)==0) {q = "q";}
    else
    {
        if (typeof(#[1]) == "string") {q = #[1];}
        else {Error("invalid optional argument");}
    }
    variety G;
    G.dimension = k*(n-k);
    execute("ring r = 0,("+q+"(1..n-k)),wp(1..n-k);");
    setring r;
    G.baseRing = r;
    int i,j;
    poly v = 1;
    poly u = 1;
    for (j=1;j<=n-k;j++) {v=v+q(j);}
    list l;
    for (i=1;i<=k;i++)
    {
        l=insert(l,1,size(l));
        u=u+(-1)^i*schur(l,v);
    }
    l=insert(l,1,size(l));
    ideal rels = schur(l,v);
    int h = k+2;
    while (h<=n)
    {
        l=insert(l,1,size(l));
        rels = rels,schur(l,v);
        h++;
    }
    G.relations = rels;
    int d = k*(n-k);
    poly subBundle = reduce(logg(u,d)+k,std(rels));
    poly quotientBundle = reduce(logg(v,d)+n-k,std(rels));
    export (subBundle,quotientBundle);
    kill u,v,d,l,rels;
    return (G);
}
example
{
    "EXAMPLE:"; echo=2;
    variety G24 = Grassmannian(2,4);
    G24;
    def r = G24.baseRing;
    setring r;
    subBundle;
    quotientBundle;
    G24.dimension;
    G24.relations;
    ChowRing(G24);
}

proc projectiveSpace(int n, list #)
"USAGE:     projectiveSpace(n); n int
RETURN:     variety
THEORY:     create a projective space of dimension n as an abstract variety. Its
            Chow ring is a quotient ring in one variable h modulo the ideal
            generated by h^(n+1).
KEYWORDS:   projective space, abstract variety
SEE ALSO:   Grassmannian, projectiveBundle
EXAMPLE:    example projectiveSpace; shows examples
"
{
    string h;
    if (size(#)==0) {h = "h";}
    else
    {
        if (typeof(#[1]) == "string") {h = #[1];}
        else {Error("invalid optional argument");}
    }
    variety P;
    P.dimension = n;
    ring r = create_ring(0, "("+h+")", "wp(1)");
    setring r;
    P.baseRing = r;
    ideal rels = var(1)^(n+1);
    P.relations = rels;
    poly u = 1;
    poly v = 1 + var(1);
    list l;
    int i;
    for (i=1;i<=n;i++)
    {
        l=insert(l,1,size(l));
        u=u+(-1)^i*schur(l,v);
    }
    poly subBundle = reduce(logg(u,n)+n,std(rels));
    poly quotientBundle = reduce(logg(v,n)+1,std(rels));
    export(subBundle,quotientBundle);
    kill rels,u,v,l;
    return (P);
}
example
{
    "EXAMPLE:"; echo=2;
    variety P = projectiveSpace(3);
    P;
    P.dimension;
    def r = P.baseRing;
    setring r;
    P.relations;
    ChowRing(P);
}

proc projectiveBundle(sheaf S, list #)
"USAGE:     projectiveBundle(S); S sheaf
INPUT:      a sheaf on an abstract variety
RETURN:     variety
THEORY:     create a projective bundle as an abstract variety. This is related
            to the enumeration of conics.
KEYWORDS:   projective bundle, abstract variety, sheaf, enumeration of conics
SEE ALSO:   projectiveSpace, Grassmannian
EXAMPLE:    example projectiveBundle; shows examples
"
{
    string z;
    if (size(#)==0) {z = "z";}
    else
    {
        if (typeof(#[1]) == "string") {z = #[1];}
        else {Error("invalid optional argument");}
    }
    variety A;
    def B = S.currentVariety;
    def R = B.baseRing;
    setring R;
    ideal rels = B.relations;
    int r = rankSheaf(S);
    A.dimension = r - 1 + B.dimension;
    poly c = totalChernClass(S);
    ring P = create_ring(0, "("+z+")", "wp(1)");
    def CR = P + R;
    setring CR;
    A.baseRing = CR;
    poly c = imap(R,c);
    ideal rels = imap(R,rels);
    poly g = var(1)^r;
    int i;
    for (i=1;i<=r;i++) {g=g+var(1)^(r-i)*homog_part(c,i);}
    A.relations = rels,g;
    poly u = 1 + var(1);
    poly f = logg(u,A.dimension)+1;
    poly QuotientBundle = reduce(f,std(A.relations));
    export (QuotientBundle);
    kill f,rels;
    return (A);
}
example
{
    "EXAMPLE:"; echo=2;
    variety G = Grassmannian(3,5);
    def r = G.baseRing;
    setring r;
    sheaf S = makeSheaf(G,subBundle);
    sheaf B = dualSheaf(S)^2;
    variety PB = projectiveBundle(B);
    PB;
    def R = PB.baseRing;
    setring R;
    QuotientBundle;
    ChowRing(PB);
}

proc productVariety(variety U, variety V)
"USAGE:     productVariety(U,V); U variety, V variety
INPUT:      two abstract varieties
OUTPUT:     a product variety as an abstract variety
RETURN:     variety
KEYWORDS:   product variety, abstract variety
SEE ALSO:   projectiveSpace, Grassmannian, projectiveBundle
EXAMPLE:    example productVariety; shows examples
"
{
    //def br = basering;
    def ur = U.baseRing; setring ur;
    ideal ii1 = U.relations;
    def vr = V.baseRing; setring vr;
    ideal ii2 = V.relations;
    variety W;
    W.dimension = U.dimension + V.dimension;
    def temp = ringtensor(ur,vr);
    setring temp;
    W.baseRing = temp;
    ideal i1 = imap(ur,ii1);
    ideal i2 = imap(vr,ii2);
    W.relations = i1 + i2;
    setring ur;
    kill ii1;
    setring vr;
    kill ii2;
    //setring br;
    return (W);
}
example
{
    "EXAMPLE:"; echo=2;
    variety P = projectiveSpace(3);
    variety G = Grassmannian(2,4);
    variety W = productVariety(P,G);
    W;
    W.dimension == P.dimension + G.dimension;
    def r = W.baseRing;
    setring r;
    W.relations;
}

////////////////////////////////////////////////////////////////////////////////

proc integral(variety V, poly f)
"USAGE:     integral(V,f); V variety, f poly
INPUT:      a abstract variety and a polynomial
RETURN:     int
PURPOSE:    computing intersection numbers.
EXAMPLE:    example integral; shows an example
"
{
    def R = V.baseRing;
    setring R;
    ideal rels = V.relations;
    return (leadcoef(reduce(f,std(rels))));
}
example
{
    "EXAMPLE:"; echo=2;
    variety G = Grassmannian(2,4);
    def r = G.baseRing;
    setring r;
    integral(G,q(1)^4);
}

proc SchubertClass(list p)
"USAGE:     SchubertClass(p); p list
INPUT:      a list of integers which is a partition
RETURN:     poly
PURPOSE:    compute the Schubert classes on a Grassmannian.
EXAMPLE:    example SchubertClass; shows an example
"
{
    def R = basering;
    setring R;
    poly f = 1;
    if (size(p) == 0) {return (f);}
    int i;
    for (i=1;i<=nvars(R);i++)
    {
        f = f + var(i);
    }
    return (schur(p,f));
}
example
{
    "EXAMPLE:"; echo=2;
    variety G = Grassmannian(2,4);
    def r = G.baseRing;
    setring r;
    list p = 1,1;
    SchubertClass(p);
}

////////////////////////////////////////////////////////////////////////////////

proc dualPartition(int k, int n, list p)
"USAGE:     dualPartition(k,n,p); k int, n int, p list
INPUT:      two integers and a partition
RETURN:     list
PURPOSE:    compute the dual of a partition.
SEE ALSO:   SchubertClass
EXAMPLE:    example dualPartition; shows an example
"
{
    while (size(p) < k)
    {
        p = insert(p,0,size(p));
    }
    int i;
    list l;
    for (i=1;i<=size(p);i++)
    {
        l[i] = n-k-p[size(p)-i+1];
    }
    return (l);
}
example
{
    "EXAMPLE:"; echo=2;
    ring r = 0,(x),dp;
    dualPartition(2,4,list(2,1));
}

////////////////////////////////////////////////////////////////////////////////
////////// Procedures concerned with abstract sheaves ///////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

proc printSheaf(sheaf S)
"USAGE:     printSheaf(S); S sheaf
RETURN:     string
INPUT:      a sheaf
THEORY:     This is the print function used by Singular to print a sheaf.
SEE ALSO:   makeSheaf, rankSheaf
EXAMPLE:    example printSheaf; shows an example
"
{
    "A sheaf of rank ", rankSheaf(S);
}
example
{
    "EXAMPLE:"; echo=2;
    variety X;
    X.dimension = 4;
    ring r = 0,(c(1..2),d(1..3)),wp(1..2,1..3);
    setring r;
    X.baseRing = r;
    poly c = 1 + c(1) + c(2);
    poly ch = 2 + logg(c,4);
    sheaf S = makeSheaf(X,ch);
    S;
}

proc makeSheaf(variety V, poly ch)
"USAGE:     makeSheaf(V,ch); V variety, ch poly
RETURN:     sheaf
THEORY:     create a sheaf on an abstract variety, and its Chern character is
            the polynomial ch.
SEE ALSO:   printSheaf, rankSheaf
EXAMPLE:    example makeSheaf; shows an example
"
{
    def R = basering;
    sheaf S;
    S.currentVariety = V;
    S.ChernCharacter = ch;
    return(S);
}
example
{
    "EXAMPLE:"; echo=2;
    variety X;
    X.dimension = 4;
    ring r = 0,(c(1..2),d(1..3)),wp(1..2,1..3);
    setring r;
    X.baseRing = r;
    poly c = 1 + c(1) + c(2);
    poly ch = 2 + logg(c,4);
    sheaf S = makeSheaf(X,ch);
    S;
}

proc rankSheaf(sheaf S)
"USAGE:     rankSheaf(S); S sheaf
RETURN:     int
INPUT:      S is a sheaf
OUTPUT:     a positive integer which is the rank of a sheaf.
SEE ALSO:   makeSheaf, printSheaf
EXAMPLE:    example rankSheaf; shows an example
"
{
    variety V = S.currentVariety;
    def R = V.baseRing;
    setring R;
    poly f = S.ChernCharacter;
    return (int(homog_part(f,0)));
}
example
{
    "EXAMPLE:"; echo=2;
    variety G = Grassmannian(2,4);
    def R = G.baseRing;
    setring R;
    sheaf S = makeSheaf(G,subBundle);
    rankSheaf(S);
}

proc totalChernClass(sheaf S)
"USAGE:     totalChernClass(S); S sheaf
RETURN:     poly
INPUT:      S is a sheaf
OUTPUT:     a polynomial which is the total Chern class of a sheaf
SEE ALSO:   totalSegreClass, topChernClass, ChernClass
EXAMPLE:    example totalChernClass; shows an example
"
{
    variety V = S.currentVariety;
    int d = V.dimension;
    def R = V.baseRing;
    setring R;
    poly ch = S.ChernCharacter;
    poly f = expp(ch,d);
    ideal rels = std(V.relations);
    return (reduce(f,rels));
}
example
{
    "EXAMPLE:"; echo=2;
    variety X;
    X.dimension = 4;
    ring r = 0,(c(1..2),d(1..3)),wp(1..2,1..3);
    setring r;
    X.baseRing = r;
    poly c = 1 + c(1) + c(2);
    poly ch = 2 + logg(c,4);
    sheaf E = makeSheaf(X,ch);
    sheaf S = E^3;
    totalChernClass(S);
}

proc ChernClass(sheaf S, int i)
"USAGE:     ChernClass(S,i); S sheaf, i int
INPUT:      S is a sheaf, i is a nonnegative integer
RETURN:     poly
THEORY:     This is the i-th Chern class of a sheaf
SEE ALSO:   topChernClass, totalChernClass
EXAMPLE:    example ChernClass; shows an example
"
{
    return (homog_part(totalChernClass(S),i));
}
example
{
    "EXAMPLE:"; echo=2;
    variety X;
    X.dimension = 4;
    ring r = 0,(c(1..2),d(1..3)),wp(1..2,1..3);
    setring r;
    X.baseRing = r;
    poly c = 1 + c(1) + c(2);
    poly ch = 2 + logg(c,4);
    sheaf E = makeSheaf(X,ch);
    sheaf S = E^3;
    ChernClass(S,1);
    ChernClass(S,2);
    ChernClass(S,3);
    ChernClass(S,4);
}

proc topChernClass(sheaf S)
"USAGE:     topChernClass(S); S sheaf
RETURN:     poly
INPUT:      S is a sheaf
THEORY:     This is the top Chern class of a sheaf
SEE ALSO:   ChernClass, totalChernClass
EXAMPLE:    example topChernClass; shows an example
"
{
    return (ChernClass(S,rankSheaf(S)));
}
example
{
    "EXAMPLE:"; echo=2;
    variety G = Grassmannian(2,4);
    def R = G.baseRing;
    setring R;
    sheaf S = makeSheaf(G,quotientBundle);
    sheaf B = S^3;
    topChernClass(B);
}

proc totalSegreClass(sheaf S)
"USAGE:     totalSegreClass(S); S sheaf
RETURN:     poly
INPUT:      S is a sheaf
THEORY:     This is the total Segre class of a sheaf.
SEE AlSO:   totalChernClass
EXAMPLE:    example totalSegreClass; shows an example
"
{
    //def D = dualSheaf(S);
    variety V = S.currentVariety;
    def R = V.baseRing;
    setring R;
    poly f = totalChernClass(S);
    poly g;
    int d = V.dimension;
    ideal rels = std(V.relations);
    if (f == 1) {return (1);}
    else
    {
        poly t,h;
        int i,j;
        for (i=0;i<=d;i++) {t = t + (1-f)^i;}
        for (j=0;j<=d;j++) {h = h + homog_part(t,j);}
        return (reduce(h,rels));
    }
}
example
{
    "EXAMPLE:"; echo=2;
    variety G = Grassmannian(2,4);
    def R = G.baseRing;
    setring R;
    sheaf S = makeSheaf(G,subBundle);
    totalSegreClass(S);
}

proc dualSheaf(sheaf S)
"USAGE:     dualSheaf(S); S sheaf
RETURN:     sheaf
THEORY:     This is the dual of a sheaf
SEE ALSO:   addSheaf, symmetricPowerSheaf, tensorSheaf, quotSheaf
EXAMPLE:    example dualSheaf; shows examples
"
{
    variety V = S.currentVariety;
    int d = V.dimension;
    def R = V.baseRing;
    setring R;
    poly ch = S.ChernCharacter;
    poly f = adams(ch,-1);
    sheaf D;
    D.currentVariety = V;
    D.ChernCharacter = f;
    return (D);
}
example
{
    "EXAMPLE:"; echo=2;
    variety G = Grassmannian(2,4);
    def R = G.baseRing;
    setring R;
    sheaf S = makeSheaf(G,subBundle);
    sheaf D = dualSheaf(S);
    D;
}

proc tensorSheaf(sheaf A, sheaf B)
"USAGE:     tensorSheaf(A,B); A sheaf, B sheaf
RETURN:     sheaf
THEORY:     This is the tensor product of two sheaves
SEE ALSO:   addSheaf, symmetricPowerSheaf, quotSheaf, dualSheaf
EXAMPLE:    example tensorSheaf; shows examples
"
{
    sheaf S;
    variety V1 = A.currentVariety;
    variety V2 = B.currentVariety;
    def R1 = V1.baseRing;
    setring R1;
    poly c1 = A.ChernCharacter;
    def R2 = V2.baseRing;
    setring R2;
    poly c2 = B.ChernCharacter;
    if (nvars(R1) < nvars(R2))
    {
        S.currentVariety = V2;
        poly c = imap(R1,c1);
        poly f = homog_parts(c*c2,0,V2.dimension);
        S.ChernCharacter = f;
        return (S);
    }
    else
    {
        setring R1;
        S.currentVariety = V1;
        poly c = imap(R2,c2);
        poly f = homog_parts(c1*c,0,V1.dimension);
        S.ChernCharacter = f;
        return (S);
    }
}
example
{
    "EXAMPLE:"; echo=2;
    variety G = Grassmannian(3,4);
    def R = G.baseRing;
    setring R;
    sheaf S = makeSheaf(G,subBundle);
    sheaf Q = makeSheaf(G,quotientBundle);
    sheaf T = S*Q;
    T;
}

proc symmetricPowerSheaf(sheaf S, int n)
"USAGE:     symmetricPowerSheaf(S,n); S sheaf, n int
RETURN:     sheaf
THEORY:     This is the n-th symmetric power of a sheaf
SEE ALSO:   quotSheaf, addSheaf, tensorSheaf, dualSheaf
EXAMPLE:    example symmetricPowerSheaf; shows examples
"
{
    variety V = S.currentVariety;
    def R = V.baseRing;
    setring R;
    int r = rankSheaf(S);
    int d = V.dimension;
    int i,j,m;
    poly f = S.ChernCharacter;
    poly result;
    list s,w;
    if (n==0) {result=1;}
    if (n==1) {result=f;}
    else
    {
        s = 1,f;
        w = wedges(n,f,d);
        for (i=2;i<=n;i++)
        {
            if (i<=r) {m=i;}
            else {m=r;}
            poly q;
            for (j=1;j<=m;j++)
            {
                q = q + ((-1)^(j+1))*homog_parts(w[j+1]*s[i-j+1],0,d);
            }
            s = insert(s,q,size(s));
            kill q;
        }
        result = s[n+1];
    }
    sheaf A;
    A.currentVariety = V;
    A.ChernCharacter = result;
    return (A);
}
example
{
    "EXAMPLE:"; echo=2;
    variety G = Grassmannian(2,4);
    def R = G.baseRing;
    setring R;
    sheaf S = makeSheaf(G,quotientBundle);
    sheaf B = symmetricPowerSheaf(S,3);
    B;
    sheaf A = S^3;
    A;
    A.ChernCharacter == B.ChernCharacter;
}

proc quotSheaf(sheaf A, sheaf B)
"USAGE:     quotSheaf(A,B); A sheaf, B sheaf
RETURN:     sheaf
THEORY:     This is the quotient of two sheaves
SEE ALSO:   addSheaf, symmetricPowerSheaf, tensorSheaf, dualSheaf
EXAMPLE:    example quotSheaf; shows an example
"
{
    sheaf S;
    variety V1 = A.currentVariety;
    variety V2 = B.currentVariety;
    def R1 = V1.baseRing;
    setring R1;
    poly c1 = A.ChernCharacter;
    def R2 = V2.baseRing;
    setring R2;
    poly c2 = B.ChernCharacter;
    if (nvars(R1) < nvars(R2))
    {
        S.currentVariety = V2;
        poly c = imap(R1,c1);
        S.ChernCharacter = c - c2;
        return (S);
    }
    else
    {
        setring R1;
        S.currentVariety = V1;
        poly c = imap(R2,c2);
        S.ChernCharacter = c1 - c;
        return (S);
    }
}
example
{
    "EXAMPLE:"; echo=2;
    variety G = Grassmannian(3,5);
    def r = G.baseRing;
    setring r;
    sheaf S = makeSheaf(G,subBundle);
    sheaf B = dualSheaf(S)^2;
    sheaf B3 = dualSheaf(S)^3;
    sheaf B5 = dualSheaf(S)^5;
    variety PB = projectiveBundle(B);
    def R = PB.baseRing;
    setring R;
    sheaf Q = makeSheaf(PB,QuotientBundle);
    sheaf V = dualSheaf(Q)*B3;
    sheaf A = B5 - V;
    A;
}

proc addSheaf(sheaf A, sheaf B)
"USAGE:     addSheaf(A,B); A sheaf, B sheaf
RETURN:     sheaf
THEORY:     This is the direct sum of two sheaves.
SEE ALSO:   quotSheaf, symmetricPowerSheaf, tensorSheaf, dualSheaf
EXAMPLE:    example addSheaf; shows an example
"
{
    sheaf S;
    variety V1 = A.currentVariety;
    variety V2 = B.currentVariety;
    def R1 = V1.baseRing;
    setring R1;
    poly c1 = A.ChernCharacter;
    def R2 = V2.baseRing;
    setring R2;
    poly c2 = B.ChernCharacter;
    if (nvars(R1) < nvars(R2))
    {
        S.currentVariety = V2;
        poly c = imap(R1,c1);
        S.ChernCharacter = c + c2;
        return (S);
    }
    else
    {
        setring R1;
        S.currentVariety = V1;
        poly c = imap(R2,c2);
        S.ChernCharacter = c1 + c;
        return (S);
    }
}
example
{
    "EXAMPLE:"; echo=2;
    variety G = Grassmannian(3,5);
    def r = G.baseRing;
    setring r;
    sheaf S = makeSheaf(G,subBundle);
    sheaf Q = makeSheaf(G,quotientBundle);
    sheaf D = S + Q;
    D;
    D.ChernCharacter == rankSheaf(D);
    totalChernClass(D) == 1;
}
