// last change:           17.01.2001
///////////////////////////////////////////////////////////////////////////////
version="$Id: paramet.lib,v 1.15 2005-04-15 13:42:54 Singular Exp $";
category="Visualization";
info="
LIBRARY: paramet.lib   Parametrization of Varieties
AUTHOR:  Thomas Keilen, keilen@mathematik.uni-kl.de
SEE ALSO: normal_lib, primdec_lib, hnoether_lib

PROCEDURES:
 parametrize(I);       parametrizes a prime ideal via the normalization
 parametrizepd(I);     calculates the prim.dec. and parametrizes the components
 parametrizesing(f);   parametrizes an isolated plane curve singularity

OVERVIEW:
 A library to compute parametrizations of algebraic varieties (if possible)
 with the aid of a normalization, or a primary decomposition, resp. to compute
 a parametrization of a plane curve singularity with the aid of a
 Hamburger-Noether expansion.
";
///////////////////////////////////////////////////////////////////////////////
LIB "normal.lib";
LIB "hnoether.lib";
///////////////////////////////////////////////////////////////////////////////

proc parametrize(ideal I)
"USAGE:   parametrize(I); I ideal in an arbitrary number of variables,
          whose radical is prime, in a ring with global ordering
CREATE:   If the parametrization is successful, the basering will be changed to
          the parametrization ring, that is to the ring PR=0,(s,t),dp;
          respectively PR=0,t(1..d),dp;, depending on the dimension of the
          parametrized variety.
RETURN:   a list containing the parametrization ideal resp. the original ideal,
          the number of variables needed for the parametrization resp. 0, and
          1 resp. 0 depending on whether the parametrization was successful
          or not
SEE ALSO: primdecGTZ, normal, radical, parametrizepd
KEYWORDS: parametrization; normalization
EXAMPLE: example parametrize; shows an example"
{
  intvec ov=option(get);
  option(noredefine);
  def BAS=basering;
  ideal newI=radical(std(I));
  int d=dim(std(newI));
  if (size(primdecGTZ(newI))==1)
  {
    list nor=normal(newI);
    def N=nor[1];
    if (d<=2)
    {
      ring PR=0,(s,t),dp;
    }
    else
    {
      ring PR=0,t(1..d),dp;
    }
    setring N;
    // If the ideal is zero dimensional, the procedure works as well in good
    // cases.
    if ((size(norid)==0) or (d==0))
    {
      // Map the parametrization to the parametrization basering PR.
      setring PR;
      map p=N,maxideal(1);
      ideal para=p(normap);
      export para;
      // The i-th list component contains the parametrization, the
      // number of necessary variables, and the information, if
      // the parametrization was successful.
      list @param=para,d,1;
//     if (d==0)
//     {
       // Include sometimes a test, whether the maximal ideal I is of the form
       // (x-a,y-b,z-c), since only then normap=(a,b,c).
//     }
      setring BAS;
      export(PR);
      keepring(PR);
    }
    else
    {
      setring BAS;
      list @param=I,0,0;
    }
  }
  else
  {
    setring BAS;
    list @param=I,0,0;
  }
  option(set,ov);
  return(@param);
}
example
{ "EXAMPLE:";echo = 2;
  ring RING=0,(x,y,z),dp;
  ideal I=z2-y2x2+x3;
  parametrize(I);
}
///////////////////////////////////////////////////////////////////////////////

proc parametrizepd(ideal I)
"USAGE:   parametrizepd(I); I ideal in a polynomial ring with global ordering
CREATE:   If the parametrization is successful, the basering will be changed to
          the parametrization ring, that is to the ring PR=0,(s,t),dp;
          respectively PR=0,t(1..d),dp;, depending on the dimension of the
          parametrized variety.
RETURN:   a list of lists, where each entry contains the parametrization
          of a primary component of I resp. 0, the number of variables
          resp. 0, and 1 resp. 0 depending on whether the parametrization
          of the component was successful or not
SEE ALSO: primdecGTZ, normal, parametrize
KEYWORDS: parametrization; normalization
EXAMPLE:  example parametrizepd; shows an example"
{
  intvec ov=option(get);
  option(noredefine);
  list primary,no,nor,para,@param;
  def BAS=basering;
  int d=dim(std(I));
  if (d<=2)
  {
    ring PR=0,(s,t),dp;
  }
  else
  {
    ring PR=0,t(1..d),dp;
  }
  ideal max=maxideal(1);
  setring BAS;
  primary=primdecGTZ(I);
  for (int ii=1; ii<=size(primary); ii=ii+1)
  {
    no=normal(std(primary[ii][2]));
    nor[ii]=no[1];
    def N=nor[ii];
    setring N;
    d=dim(std(norid));
    // Test if the normalization is K, K[s] or K[s,t].
    // Then give back the parametrization.
    if (size(norid)==0)
    {
      setring PR;
      map p=N,max;
      para[ii]=p(normap);
//         export para[ii];
//         list inter=para[ii],nvars(N),1;
      list inter=para[ii],d,1;
//       if (d==0)
//       {
         // Include sometime a test, whether the maximal ideal I is of the form
         // (x-a,y-b,z-c), since only then normap=(a,b,c).
//       }
      @param[ii]=inter;
      kill inter;
      setring BAS;
    }
    else
    {
      setring PR;
      list inter=0,0,0;
      @param[ii]=inter;
      kill inter;
      setring BAS;
    }
  }
  export nor;
  setring PR;
  export PR;
  keepring PR;
  option(set,ov);
  return(@param);
}
example
{ "EXAMPLE:";echo = 2;
  ring RING=0,(x,y,z),dp;
  ideal I=(x2-y2z2+z3)*(x2-z2-z3),(x2-y2z2+z3)*yz;
  parametrizepd(I);
}
/////////////////////////////////////////////////////////////////////////////

proc parametrizesing(poly f)
"USAGE:   parametrizesing(f); f a polynomial in two variables, ordering ls or ds
CREATE:   If the parametrization is successful, the basering will be changed to
          the parametrization ring, that is to the ring  0,(x,y),ls;
RETURN:   a list containing the parametrizations of the different branches of the
          singularity at the origin resp. 0, if f was not of the desired kind
SEE ALSO: hnoether_lib, reddevelop
KEYWORDS: parametrization; curve singularities
EXAMPLE:  example parametrizesing; shows an example"
{
  intvec ov=option(get);
  option(noredefine);
  list L,para;
  if (nvars(basering)==2 and
      (find(ordstr(basering), "ls") > 0 ||
       find(ordstr(basering), "ds") > 0 ||
       find(ordstr(basering), "lp") > 0))
  {
    L = hnexpansion(f);
    if (typeof(L[1])=="ring") {
      def altring = basering;
      def HNring = L[1]; setring HNring;
      list P = param(hne);
      export P;
      option(set,ov);
      setring(altring);
      return(list(HNring));
    }
    else {
      option(set,ov);
      list P = param(L);
      return(P);
    }   
  }
  else
  {
    option(set,ov);
    return(list());
  }
}
example
{ "EXAMPLE:";echo = 2;
  ring RING=0,(x,y),ls;
  poly f=(x^2-y^3)*(x^2-y^2-y^3);
  parametrizesing(f);
}
