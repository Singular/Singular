///////////////////////////////////////////////////////////
version="version ncfactor.lib 4.3.1.3 Jan_2023 "; //$Id$
category="Noncommutative";
info="
LIBRARY: ncfactor.lib  Tools for factorization in some noncommutative algebras
AUTHORS: Albert Heinle,     aheinle at uwaterloo.ca
@*       Viktor Levandovskyy,     levandov at math.rwth-aachen.de

OVERVIEW: In this library, new methods for factorization on polynomials
@* are implemented for several types of algebras, namely
@* - finitely presented (and also free) associative algebras (Letterplace subsystem)
@* - G-algebras (Plural subsystem), including (q)-Weyl and (q)-shift algebras in 2n variables
@* The determination of the best algorithm available for users input is done
@* automatically in the procedure ncfactor().

@* More detailed description of the algorithms and related publications can be found at
@url{https://cs.uwaterloo.ca/\~aheinle/}.

PROCEDURES:
  ncfactor(h);               Factorization in any finitely presented algebra (incl. G-algebra)
  facWeyl(h);                Factorization in the n'th Weyl algebra
  facFirstWeyl(h);           Factorization in the first Weyl algebra
  testNCfac(l[,h[,1]]);      Tests factorizations from a given list for correctness
  facSubWeyl(h,X,D);         Factorization in the first Weyl algebra as a subalgebra
  facShift(h);               Factorization in the n'th shift algebra
  facFirstShift(h);          Factorization in the first shift algebra
  homogfacNthWeyl(h);        Homogeneous factorization in the n'th Weyl algebra
  homogfacNthQWeyl(h);       Homogeneous factorization in the n'th Q-Weyl algebra
  homogfacFirstQWeyl(h);     Homogeneous factorization in the first Q-Weyl algebra
  homogfacNthQWeyl_all(h);   Homogeneous factorization (complete) in the n'th Q-Weyl algebra
  homogfacFirstQWeyl_all(h); Homogeneous factorization (complete) in the first Q-Weyl algebra
";

LIB "rootsur.lib";
LIB "general.lib";
LIB "nctools.lib";
LIB "involut.lib";
LIB "crypto.lib"; //for introot
LIB "matrix.lib"; //for submatrix
LIB "solve.lib"; //for solve
LIB "polylib.lib"; //for content
LIB "fpadim.lib"; //for letterplace

proc tst_ncfactor()
"
A little test if the library works correct.
Runs all tests for static and non-static functions.
"
{
  print("Testing delete_duplicates_noteval.");
  if(!test_delete_duplicates_noteval())
  {
    ERROR("delete_duplicates_noteval is not working properly.");
  }
  print("Successful.");
  print("Testing delete_duplicates_noteval_and_sort");
  if(!test_delete_duplicates_noteval_and_sort())
  {
    ERROR("delete_duplicates_noteval_and_sort is not working properly.");
  }
  print("Successful.");
  print("Testing combinekfinlf");
  if(!test_combinekfinlf())
  {
    ERROR("combinekfinlf is not working properly.");
  }
  print("Successful.");
  print("Testing permpp");
  if(!test_permpp())
  {
    ERROR("permpp is not working properly.");
  }
  print("Successful.");
  print("Testing binarySearch");
  if(!test_binarySearch())
  {
    ERROR("binarySearch is not working properly.");
  }
  print("Successful.");
  print("Testing getAllDivisorsFromFactList");
  if(!test_getAllDivisorsFromFactList())
  {
    ERROR("getAllDivisorsFromFactList is not working properly.");
  }
  print("Successful.");
  print("Testing triangNum");
  if (!test_triangNum())
  {
    ERROR("triangNum is not working properly.");
  }
  print("Successful.");
  print("Testing fromListToIntvec");
  if (!test_fromListToIntvec())
  {
    ERROR("fromListToIntvec is not working properly.");
  }
  print("Successful.");
  print("Testing fromIntvecToList");
  if (!test_fromIntvecToList())
  {
    ERROR("fromIntvecToList is not working properly.");
  }
  print("Successful.");
  print("Testing produceHomogListForProduct");
  if (!test_produceHomogListForProduct())
  {
    ERROR("produceHomogListForProduct is not working properly.");
  }
  print("Successful.");
  print("Testing possibleHomogPartsInBetween");
  if (!test_possibleHomogPartsInBetween())
  {
    ERROR("possibleHomogPartsInBetween is not working properly.");
  }
  print("Successful.");
  print("Testing nextSmallerEntry");
  if (!test_nextSmallerEntry())
  {
    ERROR("nextSmallerEntry is not working properly.");
  }
  print("Successful.");
  print("Testing possibleHomogPartsInBetweenNonRecursive");
  if (!test_possibleHomogPartsInBetweenNonRecursive())
  {
    ERROR("possibleHomogPartsInBetweenNonRecursive is not working properly.");
  }
  print("Successful.");
  print("Testing increment_intvec");
  if (!test_increment_intvec())
  {
    ERROR("increment_intvec is not working properly.");
  }
  print("Successful.");
  print("Testing isListEqual");
  if (!test_isListEqual())
  {
    ERROR("isListEqual is not working properly.");
  }
  print("Successful.");
  print("Testing ncfactor_isWeyl");
  if (!test_ncfactor_isWeyl())
  {
    ERROR("ncfactor_isWeyl is not working properly.");
  }
  print("Successful.");
  print("Testing ncfactor_isQWeyl");
  if (!test_ncfactor_isQWeyl())
  {
    ERROR("ncfactor_isQWeyl is not working properly.");
  }
  print("Successful.");
  print("Testing checkIfProperNthWeyl");
  if (!test_checkIfProperNthWeyl())
  {
    ERROR("checkIfProperNthWeyl is not working properly.");
  }
  print("Successful.");
  print("Testing checkIfProperNthQWeyl");
  if (!test_checkIfProperNthQWeyl())
  {
    ERROR("checkIfProperNthQWeyl is not working properly.");
  }
  print("Successful.");
  print("Testing isInCommutativeSubRing");
  if (!test_isInCommutativeSubRing())
  {
    ERROR("isInCommutativeSubRing is not working properly.");
  }
  print("Successful.");
  print("Testing factor_commutative");
  if(!test_factor_commutative())
  {
    ERROR("factor_commutative is not working properly.");
  }
  print("Successful.");
  print("Testing factorizeInt");
  if(!test_factorizeInt())
  {
    ERROR("factorizeInt is not working properly.");
  }
  print("Successful.");
  print("Testing getAllCoeffTuplesComb");
  if(!test_getAllCoeffTuplesComb())
  {
    ERROR("getAllCoeffTuplesComb is not working properly.");
  }
  print("Successful.");
  print("Testing normalizeFactors");
  if(!test_normalizeFactors())
  {
    ERROR("normalizeFactors is not working properly.");
  }
  print("Successful.");
  print("Testing divides");
  if(!test_divides())
  {
    ERROR("divides is not working properly.");
  }
  print("Successful.");
  print("Testing multiplyFactIntOutput");
  if(!test_multiplyFactIntOutput())
  {
    ERROR("multiplyFactIntOutput is not working properly.");
  }
  print("Successful.");
  print("Testing testNCfac");
  if(!test_testNCfac())
  {
    ERROR("testNCfac is not working properly.");
  }
  print("Successful.");
  print("Testing monsSmallerThan");
  if(!test_monsSmallerThan())
  {
    ERROR("monsSmallerThan is not working properly.");
  }
  print("Successful.");
  print("Testing getMaxDegreeVec");
  if(!test_getMaxDegreeVec())
  {
    ERROR("getMaxDegreeVec is not working properly.");
  }
  print("Successful.");
  print("Testing isFactorizationSmaller");
  if(!test_isFactorizationSmaller())
  {
    ERROR("test_isFactorizationSmaller is not working properly.");
  }
  print("Successful.");
  print("Testing sortedInsert");
  if(!test_sortedInsert())
  {
    ERROR("sortedInsert is not working properly.");
  }
  print("Successful.");
  print("Testing isFactorizationEqual");
  if(!test_isFactorizationEqual())
  {
    ERROR("isFactorizationEqual is not working properly.");
  }
  print("Successful.");
  print("Testing sortFactorizations");
  if(!test_sortFactorizations())
  {
    ERROR("sortFactorizations is not working properly.");
  }
  print("Successful.");
  print("Testing homogfacNthWeyl");
  if(!test_homogfacNthWeyl())
  {
    ERROR("homogfacNthWeyl is not working properly.");
  }
  print("Successful.");
  print("Testing homogfacNthWeyl_all");
  if(!test_homogfacNthWeyl_all())
  {
    ERROR("homogfacNthWeyl_all is not working properly.");
  }
  print("Successful.");
  print("Testing facWeyl");
  if(!test_facWeyl())
  {
    ERROR("facWeyl is not working properly.");
  }
  print("Successful.");
  print("Testing checkForHomogInhomogInterchangabilityNthWeyl");
  if(!test_checkForHomogInhomogInterchangabilityNthWeyl())
  {
    ERROR("checkForHomogInhomogInterchangabilityNthWeyl is not working properly.");
  }
  print("Successful.");
  print("Testing sfacwa2NthWeyl");
  if(!test_sfacwa2NthWeyl())
  {
    ERROR("sfacwaNthWeyl is not working properly.");
  }
  print("Successful.");
  print("Testing sfacwa2NthWeyl");
  if(!test_sfacwa2NthWeyl())
  {
    ERROR("sfacwaNthWeyl is not working properly.");
  }
  print("Successful.");
  print("Testing determineRestOfHomogPartsNthWeyl");
  if(!test_determineRestOfHomogPartsNthWeyl())
  {
    ERROR("determineRestOfHomogPartsNthWeyl is not working properly.");
  }
  print("Successful.");
  print("Testing gammaForThetaNthWeyl");
  if(!test_gammaForThetaNthWeyl())
  {
    ERROR("gammaForThetaNthWeyl is not working properly.");
  }
  print("Successful.");
  print("Testing extractHomogeneousDivisorsNthWeyl");
  if(!test_extractHomogeneousDivisorsNthWeyl())
  {
    ERROR("extractHomogeneousDivisorsNthWeyl is not working properly.");
  }
  print("Successful.");
  print("Testing extractHomogeneousDivisorsLeftNthWeyl");
  if(!test_extractHomogeneousDivisorsLeftNthWeyl())
  {
    ERROR("extractHomogeneousDivisorsLeftNthWeyl is not working properly.");
  }
  print("Successful.");
  print("Testing extractHomogeneousDivisorsRightNthWeyl");
  if(!test_extractHomogeneousDivisorsRightNthWeyl())
  {
    ERROR("extractHomogeneousDivisorsRightNthWeyl is not working properly.");
  }
  print("Successful.");
  print("Testing computeCombinationsMinMaxHomogNthWeyl");
  if(!test_computeCombinationsMinMaxHomogNthWeyl())
  {
    ERROR("computeCombinationsMinMaxHomogNthWeyl is not working properly.");
  }
  print("Successful.");
  print("Testing getAllCombOfHomogFact");
  if(!test_getAllCombOfHomogFact())
  {
    ERROR("getAllCombOfHomogFact is not working properly.");
  }
  print("Successful.");
  print("Testing getPossibilitiesForRightSides");
  if(!test_getPossibilitiesForRightSides())
  {
    ERROR("getPossibilitiesForRightSides is not working properly.");
  }
  print("Successful.");
  print("Testing homogDistributionNthWeyl");
  if(!test_homogDistributionNthWeyl())
  {
    ERROR("homogDistributionNthWeyl is not working properly.");
  }
  print("Successful.");
  print("Testing extractLeadingTermOfNthWeylPoly");
  if(!test_extractLeadingTermOfNthWeylPoly())
  {
    ERROR("extractLeadingTermOfNthWeylPoly is not working properly.");
  }
  print("Successful.");
  print("Testing degreeOfNthWeylPoly");
  if(!test_degreeOfNthWeylPoly())
  {
    ERROR("degreeOfNthWeylPoly is not working properly.");
  }
  print("Successful.");
  print("Testing degreeOfNthWeylPolyInverted");
  if(!test_degreeOfNthWeylPolyInverted())
  {
    ERROR("degreeOfNthWeylPolyInverted is not working properly.");
  }
  print("Successful.");
  print("Testing homogwithorderNthWeyl");
  if(!test_homogwithorderNthWeyl())
  {
    ERROR("homogwithorderNthWeyl is not working properly.");
  }
  print("Successful.");
  print("Testing isInWeylSubAlg");
  if(!test_isInWeylSubAlg())
  {
    ERROR("isInWeylSubAlg is not working properly.");
  }
  print("Successful.");
  print("Testing facSubWeyl");
  if(!test_facSubWeyl())
  {
    ERROR("facSubWeyl is not working properly.");
  }
  print("Successful.");
  print("Testing facShift");
  if(!test_facShift())
  {
    ERROR("facShift is not working properly.");
  }
  print("Successful.");
  print("Testing homogfacNthQWeyl");
  if(!test_homogfacNthQWeyl())
  {
    ERROR("homogfacNthQWeyl is not working properly.");
  }
  print("Successful.");
  print("Testing homogfacNthQWeyl_all");
  if(!test_homogfacNthQWeyl_all())
  {
    ERROR("homogfacNthQWeyl_all is not working properly.");
  }
  print("Successful.");
  print("Testing ncfactor");
  if(!test_ncfactor())
  {
    ERROR("ncfactor is not working properly.");
  }
  print("Successful.");
  print("Testing ncfactor_without_opt");
  if(!test_ncfactor_without_opt())
  {
    ERROR("ncfactor_without_opt is not working properly.");
  }
  print("Successful.");
  print("Testing factorize_nc_s");
  if(!test_factorize_nc_s())
  {
    ERROR("factorize_nc_s is not working properly.");
  }
  print("Successful.");
  print("Testing getMaxDegreeVecLetterPlace");
  if(!test_getMaxDegreeVecLetterPlace())
  {
    ERROR("getMaxDegreeVecLetterPlace is not working properly.");
  }
  print("Successful.");
  print("Testing wordsWithMaxAppearance");
  if(!test_wordsWithMaxAppearance())
  {
    ERROR("wordsWithMaxAppearance is not working properly.");
  }
  print("Successful.");
  print("Testing monsSmallerThanLetterPlace");
  if(!test_monsSmallerThanLetterPlace())
  {
    ERROR("monsSmallerThanLetterPlace is not working properly.");
  }
  print("Successful.");
  print("Testing ncfactor_letterplace_poly_s");
  if(!test_ncfactor_letterplace_poly_s())
  {
    ERROR("ncfactor_letterplace_poly_s is not working properly.");
  }
  print("Successful.");
  print("Testing ncfactor_without_opt_letterplace");
  if(!test_ncfactor_without_opt_letterplace())
  {
    ERROR("ncfactor_without_opt_letterplace is not working properly.");
  }
  print("Successful.");
  print("All tests ran successfully.");
}
example
{
  "EXAMPLE:";echo=2;
   tst_ncfactor();
}

//////////////////////////////////////////////////
//********COMBINATORIAL HELPER FUNCTIONS**********
//////////////////////////////////////////////////

static proc delete_duplicates_noteval(list l)
"
INPUT: A list of lists; Output same as e.g. FacFirstWeyl. Containing different factorizations
       of a polynomial
OUTPUT: If there are duplicates in this list, this procedure deletes them and returns the list
 without double entries
"
{//proc delete_duplicates_noteval
  list result= l;
  int j; int k; int i;
  int deleted = 0;
  int is_equal;
  for (i = 1; i<= size(l); i++)
  {//Iterate over the different factorizations
    for (j = i+1; j<= size(l); j++)
    {//Compare the i'th factorization to the j'th
      if (size(l[i])!= size(l[j]))
      {//different sizes => not equal
        j++;
        continue;
      }//different sizes => not equal
      is_equal = 1;
      for (k = 1; k <= size(l[i]);k++)
      {//Compare every entry
        if (l[i][k]!=l[j][k])
        {
          is_equal = 0;
          break;
        }
      }//Compare every entry
      if (is_equal == 1)
      {//Delete this entry, because there is another equal one int the list
        result = delete(result, i-deleted);
        deleted = deleted+1;
        break;
      }//Delete this entry, because there is another equal one int the list
    }//Compare the i'th factorization to the j'th
  }//Iterate over the different factorizations
  return(result);
}//proc delete_duplicates_noteval


static proc test_delete_duplicates_noteval()
{//testing delete_duplicates_noteval
  int result = 1;
  //Test 1: empty list should return empty list
  list expected= list();
  list obtained = delete_duplicates_noteval(list());
  if (!isListEqual(expected, obtained))
  {
    print("Test 1 failed for delete_duplicates_noteval.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: one element list
  expected = list(list(1,15));
  obtained = delete_duplicates_noteval(list(list(1,15)));
  if (!isListEqual(expected,obtained))
  {
    print("Test 2 failed for delete_duplicates_noteval.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: Two empty lists in input list
  expected = list(list());
  obtained = delete_duplicates_noteval(list(list(),list()));
  if (!isListEqual(expected,obtained))
  {
    print("Test 3 failed for delete_duplicates_noteval.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  ring r = 0,(x,y),dp;
  setring r;
  //Test 4: Typical output for factorization algorithm, no repeat
  expected = list(list(1,x,y),list(1,y,x));
  obtained = delete_duplicates_noteval(expected);
  if (!isListEqual(obtained,expected))
  {
    print("Test 4 failed for delete_duplicates_noteval");
    result = 0;
  }
  //Test 5: Typical output for factorization algorithm, repeat
  expected =list(list(1,x,y),list(1,y,x));
  list input = insert(expected, list(1,x,y));
  obtained = delete_duplicates_noteval(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 5 failed for delete_duplicates_noteval");
    result = 0;
  }
  return(result);
}//testing delete_duplicates_noteval


static proc delete_duplicates_noteval_and_sort(list l)
"
INPUT: A list of lists; Output same as e.g. FacFirstWeyl. Containing different factorizations
       of a polynomial
OUTPUT: If there are duplicates in this list, this procedure deletes them and returns the list
        without double entries. Furthermore, it sorts the list
"
{//proc delete_duplicates_noteval_and_sort
  list result= sortFactorizations(l);
  int i;
  for (i=1; i<size(result);i++)
  {
    if (isFactorizationEqual(result[i],result[i+1]))
    {
      result = delete(result, i);
      continue;
    }
  }
  return(result);
}//proc delete_duplicates_noteval_and_sort


static proc test_delete_duplicates_noteval_and_sort()
{//testing delete_duplicates_noteval_and_sort
  int result = 1;
  //Test 1: empty list should return empty list
  list expected = list();
  list obtained = delete_duplicates_noteval_and_sort(list());
  if (!isListEqual(obtained,expected))
  {
    print("Test 1 failed for delete_duplicates_noteval_and_sort.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: one element list
  expected = list(list(1,15));
  obtained = delete_duplicates_noteval_and_sort(list(list(1,15)));
  if (!isListEqual(expected,obtained))
  {
    print("Test 2 failed for delete_duplicates_noteval_and_sort.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: Two empty lists in input list
  expected = list(list());
  obtained = delete_duplicates_noteval_and_sort(list(list(),list()));
  if (!isListEqual(expected,obtained))
  {
    print("Test 3 failed for delete_duplicates_noteval_and_sort.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  ring r = 0,(x,y),dp;
  setring r;
  //Test 4: Typical output for factorization algorithm, no repeat
  list input = list(list(1,x,y),list(1,y,x));
  expected = input;
  obtained = delete_duplicates_noteval_and_sort(input);
  if (!isListEqual(obtained,expected))
  {
    print("Test 4 failed for delete_duplicates_noteval_and_sort");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 5: Typical output for factorization algorithm, repeat
  input=insert(input, list(1,x,y));
  expected = list(list(1,x,y),list(1,y,x));
  obtained = delete_duplicates_noteval_and_sort(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 5 failed for delete_duplicates_noteval_and_sort");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 6: Typical output for factorization algorithm, no repeat, unsorted
  input = list(list(1,y,x),list(1,x,y));
  expected = list(list(1,x,y),list(1,y,x));
  obtained = delete_duplicates_noteval_and_sort(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 6 failed for delete_duplicates_noteval_and_sort");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 7: Typical output for factorization algorithm, repeat,
  //unsorted
  input=insert(input, list(1,x,y));
  expected = list(list(1,x,y),list(1,y,x));
  obtained = delete_duplicates_noteval_and_sort(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 7 failed for delete_duplicates_noteval_and_sort");
    result = 0;
  }
  return(result);
}//delete_duplicates_noteval_and_sort


static proc combinekfinlf(list g, int nof)
"
given a list of factors g and a desired size nof, this
procedure combines the factors, such that we receive a
list of the length nof.
INPUT: A list of containing polynomials or any type where the *-operator is existent
OUTPUT: All possibilities (without permutation of the given list) to combine the polynomials
 into nof polynomials given by the user.
"
{//Procedure combinekfinlf
  list result;
  int i; int j; int k; //iteration variables
  list fc; //fc stands for "factors combined"
  list temp; //a temporary store for factors
  def nofgl = size(g); //nofgl stands for "number of factors of the given list"
  if (nofgl == 0)
  {//g was the empty list
    return(result);
  }//g was the empty list
  if (nof <= 0)
  {//The user wants to receive a negative number or no element as a result
    return(result);
  }//The user wants to receive a negative number or no element as a result
  if (nofgl == nof)
  {//There are no factors to combine
    result = result + list(g);
    return(result);
  }//There are no factors to combine
  if (nof == 1)
  {//User wants to get just one factor
    result = result + list(list(product(g)));
    return(result);
  }//User wants to get just one factor
  if(nof>nofgl)
  {//something is so wrong. Just returning the original list
    result = result + list(g);
    return(result);
  }//something is so wrong. Just returning the original list
  def leftPart;
  list rightPart;
  list recResult;
  for (i = 1; i<=nofgl-nof+1; i++)
  {//combine first i and recursive call results
    recResult = list();
    rightPart = list();
    leftPart = g[1];
    for (j=2; j<=i; j++)
    {//filling the leftPart
      leftPart = leftPart * g[j];
    }//filling the leftPart
    for (j=i+1; j<=nofgl; j++)
    { rightPart[j-i] = g[j]; }
    recResult = combinekfinlf(rightPart, nof-1);
    for (j=1; j<=size(recResult); j++)
    {//pushing the left part in
      recResult[j] = insert(recResult[j],leftPart,0);
    }//pushing the left part in
    result = result + recResult;
  }//combine first i and recursive call results
  result = delete_duplicates_noteval_and_sort(result);
  return(result);
}//Procedure combinekfinlf


static proc test_combinekfinlf()
{//testing combinekfinlf
  int result = 1;
  //Test1: The usual same old empty list
  list expected = list();
  list obtained = combinekfinlf(list(),5);
  if (!isListEqual(obtained,expected))
  {
    print("Test 1 for combinekfinlf failed.\n");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test2: list of length 1, nof=0
  expected = list();
  obtained = combinekfinlf(list(1),0);
  if (!isListEqual(expected,obtained))
  {
    print("Test 2 for combinekfinlf failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test3: list of length 1, nof=1
  expected= list(list(5));
  obtained = combinekfinlf(list(5),1);
  if (!isListEqual(expected, obtained))
  {
    print("Test 3 for combinekfinlf failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test4: list of length 1, nof > 1
  expected = (list(list(5)));
  obtained = combinekfinlf(list(5),5);
  if (!isListEqual(expected, obtained))
  {
    print("Test 4 for combinekfinlf failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test5: list of larger length, nof = 1
  expected=list(list(1*2*3*4*5*6));
  obtained= combinekfinlf(list(1,2,3,4,5,6),1);
  if (!isListEqual(expected, obtained))
  {
    print("Test 5 for combinekfinlf failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test6: list of larger length, nof = 2
  expected= delete_duplicates_noteval_and_sort(
    list(list(1,2*3*4*5*6),list(2,3*4*5*6),
     list(1*2*3,4*5*6),list(1*2*3*4,5*6),
     list(1*2*3*4*5,6)));
  obtained = combinekfinlf(list(1,2,3,4,5,6),2);
  if (!isListEqual(expected, obtained))
  {
    print("Test 6 for combinekfinlf failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test7: list of larger length, nof = length of list
  expected = list(list(1,2,3,4,5,6));
  obtained = combinekfinlf(list(1,2,3,4,5,6),6);
  if (!isListEqual(expected, obtained))
  {
    print("Test 7 for combinekfinlf failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test8 list of larger length, nof = half of the length
  expected = delete_duplicates_noteval_and_sort(
    list(list(1,2,3*4*5*6),list(1,2*3,4*5*6),
     list(1,2*3*4,5*6),list(1,2*3*4*5,6),
     list(1*2,3,4*5*6),list(1*2,3*4,5*6),
     list(1*2,3*4*5,6),list(1*2*3,4,5*6),
     list(1*2*3,4*5,6),list(1*2*3*4,5,6)));
  obtained = (combinekfinlf(list(1,2,3,4,5,6),3));
  if (!isListEqual(expected, obtained))
  {
    print("Test 8 for combinekfinlf failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing combinekfinlf


static proc permpp(list l)
"
INPUT: A list with entries of a type, where the ==-operator is defined
OUTPUT: A list with all permutations of this given list.
"
{//proc permpp
  int i; int j;
  list tempresult;
  list l_without_double;
  list l_without_double_pos;
  int double_entry;
  list result;
  if (size(l)==0)
  {
    return(list());
  }
  if (size(l)==1)
  {
    return(list(l));
  }
  for (i = 1; i<=size(l);i++)
  {//Filling the list with unique entries
    double_entry = 0;
    for (j = 1; j<=size(l_without_double);j++)
    {
      if (l_without_double[j] == l[i])
      {
        double_entry = 1;
        break;
      }
    }
    if (!double_entry)
    {
      l_without_double = l_without_double + list(l[i]);
      l_without_double_pos = l_without_double_pos + list(i);
    }
  }//Filling the list with unique entries
  for (i = 1; i<=size(l_without_double); i++ )
  {
    tempresult = permpp(delete(l,l_without_double_pos[i]));
    for (j = 1; j<=size(tempresult);j++)
    {
      tempresult[j] = list(l_without_double[i])+tempresult[j];
    }
    result = result+tempresult;
  }
  return(result);
}//proc permpp


static proc test_permpp()
{//testing permpp
  int result = 1;
  //Test 1: empty list
  list expected = list();
  list obtained = permpp(list());
  if (!isListEqual(expected, obtained))
  {
    print("Test 1 for permpp failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: 1 element list
  expected = list(list(1));
  obtained = permpp(list(1));
  if (!isListEqual(expected, obtained))
  {
    print("Test 2 for permpp failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: multi-element list, but only one unique element.
  expected = list(list(2,2,2,2,2,2,2));
  obtained = permpp(list(2,2,2,2,2,2,2));
  if (!isListEqual(expected, obtained))
  {
    print("Test 3 for permpp failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: multi-element list, all elements distinct
  expected = sortFactorizations(
    list(list(1,2,3,4),list(1,2,4,3),list(1,3,2,4),
     list(1,3,4,2),list(1,4,2,3),list(1,4,3,2),
     list(2,1,3,4),list(2,1,4,3),list(2,4,1,3),
     list(2,4,3,1),list(2,3,1,4),list(2,3,4,1),
     list(3,1,2,4),list(3,1,4,2),list(3,2,1,4),
     list(3,2,4,1),list(3,4,1,2),list(3,4,2,1),
     list(4,1,2,3),list(4,1,3,2),list(4,2,1,3),
     list(4,2,3,1),list(4,3,1,2),list(4,3,2,1)));
  obtained = sortFactorizations(permpp(list(1,2,3,4)));
  if (!isListEqual(expected, obtained))
  {
    print("Test 4 for permpp failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test5: multi-element list, same elements available.
  expected = sortFactorizations(
    list(list(1,2,2,3),list(1,2,3,2),list(1,3,2,2),
     list(2,1,2,3),list(2,1,3,2),list(2,2,1,3),
     list(2,2,3,1),list(2,3,1,2),list(2,3,2,1),
     list(3,2,2,1),list(3,2,1,2),list(3,1,2,2)));
  obtained = sortFactorizations(permpp(list(1,2,2,3)));
  if (!isListEqual(expected, obtained))
  {
    print("Test 5 for permpp failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing permpp


static proc binarySearch(def inputList, def inputElem)
"
INPUT: An iterable inputList (ideal/vector/intvec), which has to be
       sorted, and an element inputElem, for which it has to be
       possible to compare it to the other elements.
OUTPUT: If the entry was found, it returns its position, otherwise it returns 0.
"
{//binarySearch
  int first = 1;
  int last = size(inputList);
  int middle;
  while (first <= last)
  {
    middle = first + ((last - first) div 2);
    if (inputList[middle] < inputElem)
    {
      first = middle + 1;
    }
    else
    {
      if (inputList[middle] > inputElem)
      {
        last = middle -1;
      }
      else
      {
        return(middle);
      }
    }
  }
  return(0);
}//binarySearch


static proc test_binarySearch()
{//testing binarySearch
  int result = 1;
  //Test 1: Empty list
  int expected = 0;
  int obtained = binarySearch(list(),5);
  if (expected != obtained)
  {
    print("Test 1 for binarySearch failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test2: One element list, element not found
  expected = 0;
  obtained = binarySearch(list(1),2);
  if (expected != obtained)
  {
    print("Test 2 for binarySearch failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test3: One element list, element found
  expected = 1;
  obtained = binarySearch(list(1),1);
  if (expected != obtained)
  {
    print("Test 3 for binarySearch failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test4: Two element list, element not found
  expected = 0;
  obtained = binarySearch(list(1,3),2);
  if (expected != obtained)
  {
    print("Test 4 for binarySearch failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test5: Two element list, element found
  expected = 2;
  obtained = binarySearch(list(1,2),2);
  if (expected != obtained)
  {
    print("Test 5 for binarySearch failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test6: Multi element list, element not found
  expected =0;
  obtained = binarySearch(list(1,2,6,9,15,22),5);
  if (expected != obtained)
  {
    print("Test 6 for binarySearch failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test7: Multi element list, element found
  expected =4;
  obtained = binarySearch(list(1,2,6,9,15,22),9);
  if (expected != obtained)
  {
    print("Test 7 for binarySearch failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing binarySearch


static proc getAllDivisorsFromFactList(list l)
"USAGE: getAllDivisorsFromFactList(l); l is a list containing two
        lists; first list represents the prime factors, second list
    their powers.
RETURNS: list(int)
PURPOSE: Computes all possible factors of the integer n, whose
          factorization into prime factors is defined by l;
ASSUMPTIONS:
- The list is containing two lists. They can be assumed to be outputs of the function
factorizeInt. They have at least one entry. If it is exactly one entry, the second intvec should
contain a value at least 2.
  "
{//proc getAllDivisorsFromFactList
  list primeFactors=l[1];
  list powersOfThem = l[2];
  int i;int j;
  //Casting the entries to be numbers
  for (i=1; i<=size(primeFactors); i++)
  {
    primeFactors[i] = number(primeFactors[i]);
    powersOfThem[i] = number(powersOfThem[i]);
  }

  //Alternative Code
  list result;
  number tempPrimeFactor = 1;
  list recursiveCall;
  list recursivePowersOfThem;
  if (size(primeFactors)==1)
  {//base case: we can right away compute the result and return it.
    for (i = 1; i<=powersOfThem[1];i++)
    {
      tempPrimeFactor = tempPrimeFactor*primeFactors[1];
      result = insert(result,tempPrimeFactor);
    }
  }//base case: we can right away compute the result and return it.
  else
  {//non-base-case that involves recursion.
    if (powersOfThem[1] == 1)
    {//we have used up all our powers of that prime
      recursiveCall =
    getAllDivisorsFromFactList(list(delete(primeFactors,1),delete(powersOfThem,1)));
    }//we have used up all our powers of that prime
    else
    {//There is more power to that one prime
      recursivePowersOfThem = powersOfThem;
      recursivePowersOfThem[1] = recursivePowersOfThem[1] -1;
      recursiveCall = getAllDivisorsFromFactList(list(primeFactors, recursivePowersOfThem));
    }//There is more power to that one prime
    result = recursiveCall;
    for (i=1; i<=size(recursiveCall); i++)
    {//inserting the possibilities with the one factor included.
      result = insert(result, recursiveCall[i]*primeFactors[1]);
    }//inserting the possibilities with the one factor included.
  }//non-base-case that involves recursion.
  result = insert(result,number(1));
  result = sort(result)[1];
  result = delete_duplicates_noteval(result);
  return(result);
}//proc getAllDivisorsFromFactList


static proc test_getAllDivisorsFromFactList()
{//testing getAllDivisorsFromFactList
  int result = 1;
  ring R = 0,(x),dp;
  //Test 1: factor of 1
  list expected = list(number(1));
  list obtained = getAllDivisorsFromFactList(factorizeInt(1));
  if (!isListEqual(expected, obtained))
  {
    print("Test 1 for getAllDivisorsFromFactList failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test2: single prime
  expected = list(number(1),number(5));
  obtained = getAllDivisorsFromFactList(factorizeInt(5));
  if (!isListEqual(expected, obtained))
  {
    print("Test 2 for getAllDivisorsFromFactList failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test3: prime power
  expected = list(number(1),number(2),number(4),number(8));
  obtained = getAllDivisorsFromFactList(factorizeInt(8));
  if (!isListEqual(expected, obtained))
  {
    print("Test 3 for getAllDivisorsFromFactList failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test4: Arbitrary number
  expected = list(number(1),number(2),number(5),number(10));
  obtained = getAllDivisorsFromFactList(factorizeInt(10));
  if (!isListEqual(expected, obtained))
  {
    print("Test 2 for getAllDivisorsFromFactList failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing getAllDivisorsFromFactList


static proc triangNum(int n)
"Returns the nth triangular number."
{
  if (n == 0)
  {
    return(0);
  }
  return (n*(n+1) div 2);
}


static proc test_triangNum()
{//testing triangNum
  int result = 1;
  //Test 1: 0
  int expected = 0;
  int obtained = triangNum(0);
  if (expected !=obtained)
  {
    print("Test 1 for tringNum failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: 1
  expected = 1;
  obtained = triangNum(1);
  if (expected !=obtained)
  {
    print("Test 2 for tringNum failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: some non-trivial higher number (gauss)
  expected = 5050;
  obtained = triangNum(100);
  if (expected !=obtained)
  {
    print("Test 3 for tringNum failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing triangNum



static proc fromListToIntvec(list l)
"Converter from List to intvec.
Assuming all entries in the given
list are integers, and the list is not empty."
{
  intvec result; int i;
  for (i = 1; i<=size(l); i++)
  {
    result[i] = l[i];
  }
  return(result);
}


static proc test_fromListToIntvec()
{//testing fromListToIntvec
  int result = 1;
  //Test 1: List with 1 element
  list input = list(1);
  intvec expected = intvec(1);
  intvec obtained = fromListToIntvec(input);
  if (expected !=obtained)
  {
    print("Test 1 for fromListToIntvec failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: List with more than 1 element
  input = list(1,6,3,2);
  expected = intvec(1,6,3,2);
  obtained = fromListToIntvec(input);
  if (expected !=obtained)
  {
    print("Test 2 for fromListToIntvec failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing fromListToIntvec


static proc fromIntvecToList(intvec l)"
Converter from intvec to list"
{//proc fromIntvecToList
  list result = list();
  int i;
  for (i = size(l); i>=1; i--)
  {
    result = insert(result, l[i]);
  }
  return(result);
}//proc fromIntvecToList

static proc test_fromIntvecToList()
{//testing fromIntvecToList
  int result = 1;
  //Test1: Intvec(0)
  intvec input;
  list expected = list(0);
  list obtained = fromIntvecToList(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 1 for fromIntvecToList failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test2: Intvec(1)
  input= intvec(1);
  expected = list(1);
  obtained = fromIntvecToList(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 2 for fromIntvecToList failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: Intvec with arbitrarily many elements
  input= intvec(6,4,7,1,24);
  expected = list(6,4,7,1,24);
  obtained = fromIntvecToList(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 3 for fromIntvecToList failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing fromIntvecToList


static proc produceHomogListForProduct(list homogParts1, list homogParts2)
"
INPUT: Two lists of integer vectors, homogParts1 and homogParts2,
       where the contained integer vectors all have the same size n.
OUTPUT: One list of integer vectors, which have size n respectively.
        The entries form a subset of possible integer vectors which result
        of a sum of an entry y in homogParts1 and an entry x in
    homogParts2.
        The subset is given by the property that for each index i in
    homogparts1, the i'th entry in the resulting list has
    homogparts1[i] as a summand. Furthermore,
    result[length(result)-i] should also have
    homogparts1[length(homogparts)-i] as a summand.
"
{//produceHomogListForProduct
  int i; int j; int k;
  list p = reverse(sort(homogParts1)[1]);
  list q = reverse(sort(homogParts2)[1]);
  list result;
  intvec tempIntVec;
  for (i = 1; i<= size(homogParts1); i++)
  {
    for (j = 1; j<= size(homogParts2); j++)
    {
      tempIntVec = homogParts1[i] + homogParts2[j];
      if (binarySearch(result,tempIntVec)==0)
      {//Element was not yet in result, add it
        result = result + list(tempIntVec);
        result = sort(result)[1];
      }//Element was not yet in result, add it
    }
  }
  if (size(result)==0)
  {
    return(result);
  }
  result = reverse(result);
  //Till here, we have a complete list with entries that are between hmax and hmin
  //Now, we need to filter this list.

  int isIn;
  for(i = 1; i<=size(p); i++)
  {//Checking, if homogparts[i] has a counterpart in homogparts2
    isIn = 0;
    for (j = 1; j<=size(q); j++)
    {//iterating through the counterparts
      if(p[i] + q[j] == result[i])
      {
        isIn = 1;
        break;
      }
    }//iterating through the counterparts
    if(!isIn)
    {
      result = delete(result,i);
      continue;
    }
  }//Checking, if homogparts[i] has a counterpart in homogparts2
  for (i = 0; i<size(p); i++)
  {//The same from the top
    isIn = 0;
    for (j = 1; j<=size(q); j++)
    {//iterating through the counterparts
      if(p[size(p)-i] + q[j] == result[size(result) - i])
      {
        isIn = 1;
        break;
      }
    }//iterating through the counterparts
    if(!isIn)
    {
      result = delete(result,size(result)-i);
      continue;
    }
  }//The same from the top
  return(result);
}//produceHomogListForProduct


static proc test_produceHomogListForProduct()
{//testing produceHomogListForProduct
  int result = 1;
  //Test 1: Both lists are empty
  list expected = list();
  list obtained = produceHomogListForProduct(list(),list());
  if (!isListEqual(expected, obtained))
  {
    print("Test 1 for produceHomogListForProduct failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: one list empty, the other one contains elements.
  expected = list();
  list input1 = list();
  list input2 = list(intvec(1,2,3),intvec(4,5,6));
  obtained = produceHomogListForProduct(input1,input2);
  if (!isListEqual(expected, obtained))
  {
    print("Test 2 for produceHomogListForProduct failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: one list contains elements, the other list is empty.
  expected = list();
  input2 = list();
  input1 = list(intvec(1,2,3),intvec(4,5,6));
  obtained = produceHomogListForProduct(input1,input2);
  if (!isListEqual(expected, obtained))
  {
    print("Test 3 for produceHomogListForProduct failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: each list has one element
  expected = list(intvec(5,7,9));
  input1 = list(intvec(4,5,6));
  input2 = list(intvec(1,2,3));
  obtained = produceHomogListForProduct(input1,input2);
  if (!isListEqual(expected, obtained))
  {
    print("Test 4 for produceHomogListForProduct failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test5: Random multiple elements, different size
  expected = list(intvec(19,23,2),intvec(5,7,9),intvec(4,4,4));
  input1 = list(intvec(4,5,6),intvec(3,2,1),intvec(11,15,1));
  input2 = list(intvec(1,2,3),intvec(8,8,1));
  obtained = produceHomogListForProduct(input1,input2);
  if (!isListEqual(expected, obtained))
  {
    print("Test 5 for produceHomogListForProduct failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test6: Random multiple elements, same size
  expected = list(intvec(19,23,2),intvec(5,7,9));
  input1 = list(intvec(4,5,6),intvec(11,15,1));
  input2 = list(intvec(1,2,3),intvec(8,8,1));
  obtained = produceHomogListForProduct(input1,input2);
  if (!isListEqual(expected, obtained))
  {
    print("Test 6 for produceHomogListForProduct failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing produceHomogListForProduct


static proc possibleHomogPartsInBetween(intvec pmax, intvec pmin, intvec maxDegrees)
"
INPUT: Integer vectors pmax, pmin and maxDegrees. All are of the same size,
       except from maxDegrees, which is double of the size of the rest.
OUTPUT: A list of possible points in Z^n that can lie between pmax and
        pmin, sorted with respect to the lexicographic order from
        biggest to smallest (leftmost entry in the intvec is the biggest),
        represented as list of intvecs. Upper bounds are given by maxDegrees.
"
{//possibleHomogPartsInBetween
  if (size(pmax) != size(pmin) || 2*size(pmax)!=size(maxDegrees) || pmax<=pmin)
  {
    ERROR("pmax and pmin shall have the same size, and maxDegrees
    shall be double the size of both. Furthermore, it must hold that pmax>pmin. The
    Input was: " + string(pmax) + ", " + string(pmin) + ", " + string(maxDegrees));
  }
  list result;
  intvec tempIntVec = pmax;
  while(tempIntVec > pmin)
  {
    result = result + list(tempIntVec);
    tempIntVec = nextSmallerEntry(tempIntVec,pmin,maxDegrees);
  }
  result = result + list(pmin);
  return (sort(result)[1]);
}//possibleHomogPartsInBetween


static proc test_possibleHomogPartsInBetween()
{//testing possibleHomogPartsInBetween
  int result = 1;
  //Test 1: Nothing in between
  list expected = list(intvec(1,1),intvec(1,2));
  list obtained =
    possibleHomogPartsInBetween(intvec(1,2),
                intvec(1,1),
                intvec(10,10,10,10));
  if (!isListEqual(expected, obtained))
  {
    print("Test 1 for possibleHomogPartsInBetween failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: exactly one intvec in between
  expected = list(intvec(1,1),intvec(1,2),intvec(1,3));
  obtained =
    possibleHomogPartsInBetween(intvec(1,3),
                intvec(1,1),
                intvec(10,10,10,10));
  if (!isListEqual(expected, obtained))
  {
    print("Test 2 for possibleHomogPartsInBetween failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: One complete degree of freedom
  expected = list(intvec(1,1,1),
          intvec(1,1,2),
          intvec(1,1,3),
          intvec(1,1,4),
          intvec(1,1,5),
          intvec(1,2,-5),
          intvec(1,2,-4),
          intvec(1,2,-3),
          intvec(1,2,-2),
          intvec(1,2,-1),
          intvec(1,2,0),
          intvec(1,2,1),
          intvec(1,2,2),
          intvec(1,2,3),
          intvec(1,2,4),
          intvec(1,2,5),
          intvec(1,3,-5),
          intvec(1,3,-4),
          intvec(1,3,-3),
          intvec(1,3,-2),
          intvec(1,3,-1),
          intvec(1,3,0),
          intvec(1,3,1),
          intvec(1,3,2),
          intvec(1,3,3),
          intvec(1,3,4),
          intvec(1,3,5));
  obtained =
    possibleHomogPartsInBetween(intvec(1,3,5),
                intvec(1,1,1),
                intvec(5,5,5,5,5,5));
  if (!isListEqual(expected, obtained))
  {
    print("Test 3 for possibleHomogPartsInBetween failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing possibleHomogPartsInBetween


static proc nextSmallerEntry(intvec pmax, intvec pmin, intvec maxDegrees)
"INPUT: Integer vectors pmax, pmin and maxDegrees. maxDegrees has to have size 2*size(pmax),
        where pmin has to have the same size as pmax.
OUTPUT: Counting down by lexicographical ordering, this function returns the next smaller
entry after pmax, which is still bigger than pmin.
"
{//nextSmallerEntry
  if (pmax == pmin)
  {return (pmin);}
  if (size(pmax) == 1)
  {
    if (pmax <= pmin)
    {return(pmin);}
    else
    {return(pmax -1);}
  }
  int i;
  intvec recPmax = pmax[1..(size(pmax)-1)];
  intvec recPmin = pmin[1..(size(pmin)-1)];
  intvec recMaxDegrees = intvec(maxDegrees[1]);
  for (i = 2; i<=size(maxDegrees); i++)
  {
    if (i!=size(pmax) && i!= size(2*size(pmax)))
    {
      recMaxDegrees = recMaxDegrees,maxDegrees[i];
    }
  }
  if (recPmax == recPmin)
  {//In this case, we can only possibly count down at our current position
    if (pmax[size(pmax)] > pmin[size(pmin)])
    {return (recPmax,(pmax[size(pmax)]-1));}
    else
    {return(pmin);}
  }//In this case, we can only possibly count down at our current position
  else
  {//In this case, we can go down to the bounds given by maxDegrees
    if (pmax[size(pmax)] > -maxDegrees[size(pmax)])
    {
      return (recPmax,(pmax[size(pmax)]-1));
    }
    else
    {
      return(nextSmallerEntry(recPmax,recPmin,recMaxDegrees),maxDegrees[2*size(pmax)]);
    }
  }//In this case, we can go down to the bounds given by maxDegrees
}//nextSmallerEntry


static proc test_nextSmallerEntry()
{//testing nextSmallerEntry
  int result = 1;
  //Test 1: one element in intvec
  intvec expected = intvec(2);
  intvec obtained = nextSmallerEntry(intvec(3),
                     intvec(2),
                     intvec(5,5));
  if (expected!=obtained)
  {
    print("Test 1 for nextSmallerEntry failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: more than one element in intvec, no overlap
  expected = intvec(1,1);
  obtained = nextSmallerEntry(intvec(1,2), intvec(1,1),
                  intvec(5,5,5,5));
  if (expected!=obtained)
  {
    print("Test 2 for nextSmallerEntry failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: More than one element in intvec, overlap
  expected = intvec(1,5);
  obtained = nextSmallerEntry(intvec(2,-5), intvec(1,1),
                  intvec(5,5,5,5));
  if (expected!=obtained)
  {
    print("Test 3 for nextSmallerEntry failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: More than one element in intvec, more than one overlap
  expected = intvec(1,5,5);
  obtained = nextSmallerEntry(intvec(2,-5,-5), intvec(1,1,1),
                  intvec(5,5,5,5,5,5));
  if (expected!=obtained)
  {
    print("Test 4 for nextSmallerEntry failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing nextSmallerEntry


static proc possibleHomogPartsInBetweenNonRecursive(intvec pmax, intvec pmin, intvec maxDegrees)
"
INPUT: Integer vectors pmax and maxDegrees. All but maxDegrees are of the same size,
       except from maxDegrees, which is double of the size of the rest.
OUTPUT: A list of possible points in Z^n that can lie between pmax and
        pmin, sorted with respect to the lexicographic order from
        biggest to smallest (leftmost entry in the intvec is the biggest),
        represented as list of intvecs.
"
{//possibleHomogPartsInBetween
  if (size(pmax) != size(pmin) || 2*size(pmax)!=size(maxDegrees) || pmax<=pmin)
  {
    ERROR("pmax and pmin shall have the same size, and maxDegrees
    shall be double the size of both. Furthermore, it must hold that pmax>pmin. The
    Input was: " + string(pmax) + ", " + string(pmin) + ", " + string(maxDegrees));
  }
  list result = list(pmax);
  int pos; int i; int j; int k;
  list leftPart;
  int leftPartIsMaxAndMin;
  list possibleMiddles;
  list possibleRightParts = list(list());
  list tempRightParts;
  intvec tempentry;
  for (pos = size(pmax); pos >=1 ; pos--)
  {
    leftPart = list();
    leftPartIsMaxAndMin = 1;
    possibleMiddles = list();
    for (i = 1; i < pos; i++)
    {//filling the left part
      leftPart[i] = pmax[i];
      if(pmax[i]!=pmin[i])
      {leftPartIsMaxAndMin = 0;}
    }//filling the left part
    if (leftPartIsMaxAndMin)
    {
      for (i = pmax[pos]-1; i>pmin[pos]; i--)
      {//possible entries for position pos
        possibleMiddles = possibleMiddles + list(i);
      }//possible entries for position pos
    }
    else
    {
      for (i = pmax[pos]-1; i>=-maxDegrees[pos]; i--)
      {//possible entries for position pos
        possibleMiddles = possibleMiddles + list(i);
      }//possible entries for position pos
    }
    for (i = 1; i<=size(possibleMiddles); i++)
    {//Adding possibilities to result
      for (j = 1; j<=size(possibleRightParts); j++)
      {//going through the right parts
        tempentry = intvec(0);
        for (k = 1; k<=size(leftPart);k++)
        {
          tempentry[k] = leftPart[k];
        }
        if (size(leftPart)==0)
        {tempentry = possibleMiddles[i];}
        else
        {tempentry = tempentry,possibleMiddles[i];}
        for (k = 1; k<=size(possibleRightParts[j]) ; k++)
        {
          tempentry = tempentry, possibleRightParts[j][k];
        }
        result = result + list(tempentry);
      }//going through the right parts
    }//Adding possibilities to result
    tempRightParts = list();
    for (i = 1; i<=size(possibleRightParts);i++)
    {
      for (j = -maxDegrees[pos]; j <= maxDegrees[pos + size(pmax)];
           j++)
      {
        tempRightParts = tempRightParts + list(list(j) + possibleRightParts[i]);
      }
    }
    possibleRightParts = tempRightParts;
  }
  //Now the last possible guys
  result = result + list(pmin);
  leftPart = list();
  int positionWhereDifference = 1;
  for (i = 1; i<= size(pmin); i++)
  {
    if(pmax[i] != pmin[i])
    {
      positionWhereDifference = i;
      break;
    }
  }
  possibleRightParts = list(list());
  for (pos = size(pmin); pos > positionWhereDifference; pos--)
  {//Dealing with the minimal parts that we left out in the loop above
    leftPart = list();
    possibleMiddles = list();
    for (i = 1; i < pos; i++)
    {//filling up the left part
      leftPart[i] = pmin[i];
    }//filling up the left part
    for (i = pmin[pos] +1 ; i<=maxDegrees[pos + size(pmin)] ; i++)
    {
      possibleMiddles = possibleMiddles + list(i);
    }
    for (i = 1; i<=size(possibleMiddles); i++)
    {//Adding possibilities to result
      for (j = 1; j<=size(possibleRightParts); j++)
      {//going through the right parts
        tempentry = intvec(0);
        for (k = 1; k<=size(leftPart);k++)
        {
          tempentry[k] = leftPart[k];
        }
        if (size(leftPart)==0)
        {tempentry = possibleMiddles[i];}
        else
        {tempentry = tempentry,possibleMiddles[i];}
        for (k = 1; k<=size(possibleRightParts[j]) ; k++)
        {
          tempentry = tempentry, possibleRightParts[j][k];
        }
        result = result + list(tempentry);
      }//going through the right parts
    }//Adding possibilities to result
    tempRightParts = list();
    for (i = 1; i<=size(possibleRightParts);i++)
    {
      for (j = -maxDegrees[pos]; j <= maxDegrees[pos + size(pmax)];
           j++)
      {
        tempRightParts = tempRightParts + list(list(j) + possibleRightParts[i]);
      }
    }
    possibleRightParts = tempRightParts;
  }//Dealing with the minimal parts that we left out in the loop above
  result = sort(result)[1];
   if (result[1] != pmin)
  {result = insert(result,pmin);}
  return(result);
}//possibleHomogPartsInBetween


static proc test_possibleHomogPartsInBetweenNonRecursive()
{//testing possibleHomogPartsInBetweenNonRecursive
  int result = 1;
  //Test 1: Nothing in between
  list expected = list(intvec(1,1),intvec(1,2));
  list obtained =
    possibleHomogPartsInBetweenNonRecursive(intvec(1,2),
                intvec(1,1),
                intvec(10,10,10,10));
  if (!isListEqual(expected, obtained))
  {
    print("Test 1 for possibleHomogPartsInBetweenNonRecursive failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: exactly one intvec in between
  expected = list(intvec(1,1),intvec(1,2),intvec(1,3));
  obtained =
    possibleHomogPartsInBetweenNonRecursive(intvec(1,3),
                intvec(1,1),
                intvec(10,10,10,10));
  if (!isListEqual(expected, obtained))
  {
    print("Test 2 for possibleHomogPartsInBetweenNonRecursive failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: One complete degree of freedom
  expected = list(intvec(1,1,1),
          intvec(1,1,2),
          intvec(1,1,3),
          intvec(1,1,4),
          intvec(1,1,5),
          intvec(1,2,-5),
          intvec(1,2,-4),
          intvec(1,2,-3),
          intvec(1,2,-2),
          intvec(1,2,-1),
          intvec(1,2,0),
          intvec(1,2,1),
          intvec(1,2,2),
          intvec(1,2,3),
          intvec(1,2,4),
          intvec(1,2,5),
          intvec(1,3,-5),
          intvec(1,3,-4),
          intvec(1,3,-3),
          intvec(1,3,-2),
          intvec(1,3,-1),
          intvec(1,3,0),
          intvec(1,3,1),
          intvec(1,3,2),
          intvec(1,3,3),
          intvec(1,3,4),
          intvec(1,3,5));
  obtained =
    possibleHomogPartsInBetweenNonRecursive(intvec(1,3,5),
                intvec(1,1,1),
                intvec(5,5,5,5,5,5));
  if (!isListEqual(expected, obtained))
  {
    print("Test 3 for possibleHomogPartsInBetweenNonRecursive failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing possibleHomogPartsInBetweenNonRecursive


static proc increment_intvec(intvec v, intvec maxDegInCoordinates)
"USAGE: increment_intvec(v,maxDegInCoordinates); v and
maxDegInCoordinates are both intvecs.
RETURN: intvec
PURPOSE: Increments the intvec v, assuming that each coordinate has
maximal entry as given in the respective position in
maxDegInCoordinates.
ASSUMPTIONS:
- v and maxDegInCoordinates have the same size.
"{//increment_intvec
  intvec result = v;
  int i;
  for (i = size(result); i>0; i--)
  {//going through the positions
    if (result[i] >= maxDegInCoordinates[i])
    {//need to go to different position
      if (i == 1)
      {//max position already reached; i.e. max vector
        return(v);
      }//max position already reached; i.e. max vector
      result[i] = 0;
    }//need to go to different position
    else
    {//just change counter at that position and done
      result[i]= result[i]+1;
      break;
    }//just change counter at that position and done
  }//going through the positions
  return(result);
}//increment_intvec


static proc test_increment_intvec()
{//testing increment_intvec
  int result = 1;
  //Test 1: one element in intvec
  intvec expected = intvec(4);
  intvec obtained = increment_intvec(intvec(3),
                     intvec(5));
  if (expected!=obtained)
  {
    print("Test 1 for increment_intvec failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: more than one element in intvec, no overlap
  expected = intvec(1,3);
  obtained = increment_intvec(intvec(1,2),intvec(5,5));
  if (expected!=obtained)
  {
    print("Test 2 for increment_intvec failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: More than one element in intvec, overlap
  expected = intvec(3,0);
  obtained = increment_intvec(intvec(2,5),
                  intvec(5,5));
  if (expected!=obtained)
  {
    print("Test 3 for increment_intvec failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: More than one element in intvec, more than one overlap
  expected = intvec(3,0,0);
  obtained = increment_intvec(intvec(2,5,5),
                  intvec(5,5,5));
  if (expected!=obtained)
  {
    print("Test 4 for increment_intvec failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing increment_intvec

static proc isListEqual(list l1, list l2)
"USAGE: isListEq(l1,l2); l1 and l2 are arbitrary lists.
PURPOSE: returns if l1 and l2 contain the same elements
ASSUME: every non-list element in l1 and l2 can be compared with the
== operator
"{
  if (size(l1)!=size(l2))
  {return(0);}
  int i;
  for (i = 1; i<=size(l1);i++)
  {
    if (typeof(l1[i])!=typeof(l2[i]))
    { return (0); }
    if (typeof(l1[i])=="list")
    {
      if (!isListEqual(l1[i],l2[i]))
      {
    return(0);
      }
    }
    else
    {
      if (l1[i]!=l2[i])
      {return(0);}
    }
  }
  return(1);
}

static proc test_isListEqual()
{
  int result = 1;
  //Test 1: empty list and empty list
  int expected = 1;
  list input1 = list();
  list input2 = list();
  int obtained = isListEqual(input1,input2);
  if (expected !=obtained)
  {
    print("Test 1 for isListEqual failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: empty list and non-empty list
  expected = 0;
  input1 = list();
  input2 = list(list(),1,3,4);
  obtained = isListEqual(input1,input2);
  if (expected !=obtained)
  {
    print("Test 2 for isListEqual failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: non-empty list and empty list
  expected = 0;
  input2 = list();
  input1 = list(list(),1,3,4);
  obtained = isListEqual(input1,input2);
  if (expected !=obtained)
  {
    print("Test 3 for isListEqual failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: lists with entries of the same type, equal
  expected = 1;
  input1 = list(1,2,3,4);
  input2 = list(1,2,3,4);
  obtained = isListEqual(input1,input2);
  if (expected !=obtained)
  {
    print("Test 4 for isListEqual failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 5: lists with entries of the same type, not equal
  expected = 0;
  input1 = list(4,3,2,1);
  input2 = list(1,2,3,4);
  obtained = isListEqual(input1,input2);
  if (expected !=obtained)
  {
    print("Test 5 for isListEqual failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 6: lists with entries of the different types, equal
  expected = 1;
  input1 = list(4,intvec(3,2),list(list()),1);
  input2 = list(4,intvec(3,2),list(list()),1);
  obtained = isListEqual(input1,input2);
  if (expected !=obtained)
  {
    print("Test 6 for isListEqual failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 7: lists with entries of the different types, not equal
  expected = 0;
  input1 = list(4,intvec(3,2),list(),1);
  input2 = list(4,intvec(3,2),list(list()),1);
  obtained = isListEqual(input1,input2);
  if (expected !=obtained)
  {
    print("Test 7 for isListEqual failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}

//////////////////////////////////////////////////
//*********RING HANDLING HELPER FUNCTIONS*********
//////////////////////////////////////////////////

static proc ncfactor_isWeyl()
"
INPUT: None
OUTPUT: Returns 1 if the basering is a Weyl algebra,
        0 otherwise.
"
{//ncfactor_isWeyl
  if (nvars(basering) % 2 != 0)
  {//Ring cannot be a Weyl algebra, as we need an even number of vars
    return(0);
  }//Ring cannot be a Weyl algebra, as we need an even number of vars
  list tempRingList = ringlist(basering);
  if (size(tempRingList)<=4)
  {//Given ring is commutative
    return(0);
  }//Given ring is commutative
  matrix C = tempRingList[5];
  matrix D = tempRingList[6];
  int i; int j;

  //Checking if C is okay.
  for (i = 1; i<ncols(C); i++)
  {//Iterating the diagonal
    for (j = i+1; j<=ncols(C); j++)
    {//Iterating the off-diagonal
      if (C[i,j] != 1)
      { return(0); }
    }//Iterating the off-diagonal
  }//Iterating the diagonal

  //Checking if D is okay
  int countOnes;
  for (i = 1; i<=ncols(D); i++)
  {//Iterating the diagonal
    countOnes = 0;
    for (j = i+1; j<=ncols(D); j++)
    {//Checking whether there is at most one nontrivial entry in each row.
      if (D[i,j] == 1 or D[i,j]==-1)
      {countOnes++;}
    }//Checking whether there is at most one nontrivial entry in each row.
    if (countOnes > 1)
    {return(0);}
    countOnes = 0;
    for (j = i-1; j>=1; j--)
    {//Checking whether there is at most one nontrivial entry in each col
      if (D[j,i] == 1 or D[j,i]==-1)
      {countOnes++;}
    }//Checking whether there is at most one nontrivial entry in each col
    if (countOnes > 1)
    {return(0);}
  }//Iterating the diagonal

  //Now check if all variables are paired up.
  list the_vars;
  for (i = 1; i<=nvars(basering); i++)
  {
    the_vars[i] = var(i);
  }
  int noPairForFirstOne;
  while(size(the_vars)>0)
  {//We did not pair up all variables yet
    noPairForFirstOne = 1;
    for (i = 2; i<=size(the_vars); i++)
    {//Compare the commutation relations of the jth variable to the first one
      if (the_vars[1]*the_vars[i] - the_vars[i]*the_vars[1] == 1 or
          the_vars[1]*the_vars[i] - the_vars[i]*the_vars[1] == -1)
      {//Found a counter matching one
        noPairForFirstOne = 0;
        the_vars = delete(the_vars,i);
        the_vars = delete(the_vars,1);
        break;
      }//Found a counter matching one
    }//Compare the commutation relations of the jth variable to the first one
    if(noPairForFirstOne)
    {return(0);}
  }//We did not pair up all variables yet
  return(1);
}//ncfactor_isWeyl


static proc test_ncfactor_isWeyl()
{//testing ncfactor_isWeyl
  int result = 1;
  int i; int j; int k;
  //Test 1: first Weyl algebra, x before d
  ring R = 0,(x,d),dp;
  def r = nc_algebra(1,1);
  setring(r);
  int expected = 1;
  int obtained = ncfactor_isWeyl();
  if (expected !=obtained)
  {
    print("Test 1 for ncfactor_isWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: first Weyl algebra, d before x
  ring R2 = 0,(x,d),dp;
  def r2 = nc_algebra(1,-1);
  setring(r);
  expected = 1;
  obtained = ncfactor_isWeyl();
  if (expected !=obtained)
  {
    print("Test 2 for ncfactor_isWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: All possibilities for third Weyl algebra
  list perms =list(list(list(1,0,0,0,0,0),
            list(0,1,0,0,0,0),
            list(0,0,1,0,0,0)),
           list(list(1,0,0,0,0,0),
            list(0,0,1,0,0,0),
            list(0,1,0,0,0,0)),
           list(list(0,1,0,0,0,0),
            list(1,0,0,0,0,0),
            list(0,0,1,0,0,0)),
           list(list(0,1,0,0,0,0),
            list(0,0,1,0,0,0),
            list(1,0,0,0,0,0)),
           list(list(0,0,1,0,0,0),
            list(0,1,0,0,0,0),
            list(1,0,0,0,0,0)),
           list(list(0,0,1,0,0,0),
            list(1,0,0,0,0,0),
            list(0,1,0,0,0,0)));
  for(i=1;i<=size(perms);i++)
  {
    ring R3 = 0,(x,y,z,w,v,u),dp;
    matrix C[6][6] = 1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1;
    matrix D[6][6];
    for (j=1;j<=size(perms[i]);j++)
    {
      for (k=1;k<=size(perms[i][j]);k++)
      {
    D[k,3+j]=perms[i][j][k];
      }
    }
    def r3 = nc_algebra(C,D);
    setring(r3);
    expected = 1;
    obtained = ncfactor_isWeyl();
    if (expected !=obtained)
    {
      print("Test 3 for ncfactor_isWeyl failed.");
      print("Expected:\n");
      print(expected);
      print("obtained:\n");
      print(obtained);
      result = 0;
    }
    kill r3;
    kill R3;
  }
  //Test 4: All possibilities for third Weyl algebra reversed
  kill perms;
  list perms =list(list(list(-1,0,0,0,0,0),
            list(0,-1,0,0,0,0),
            list(0,0,-1,0,0,0)),
           list(list(-1,0,0,0,0,0),
            list(0,0,-1,0,0,0),
            list(0,-1,0,0,0,0)),
           list(list(0,-1,0,0,0,0),
            list(-1,0,0,0,0,0),
            list(0,0,-1,0,0,0)),
           list(list(0,-1,0,0,0,0),
            list(0,0,-1,0,0,0),
            list(-1,0,0,0,0,0)),
           list(list(0,0,-1,0,0,0),
            list(0,-1,0,0,0,0),
            list(-1,0,0,0,0,0)),
           list(list(0,0,-1,0,0,0),
            list(-1,0,0,0,0,0),
            list(0,-1,0,0,0,0)));
  for(i=1;i<=size(perms);i++)
  {
    ring R3 = 0,(x,y,z,w,v,u),dp;
    matrix C[6][6] = 1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1;
    matrix D[6][6];
    for (j=1;j<=size(perms[i]);j++)
    {
      for (k=1;k<=size(perms[i][j]);k++)
      {
    D[k,3+j]=perms[i][j][k];
      }
    }
    def r3 = nc_algebra(C,D);
    setring(r3);
    expected = 1;
    obtained = ncfactor_isWeyl();
    if (expected !=obtained)
    {
      print("Test 4 for ncfactor_isWeyl failed.");
      print("Expected:\n");
      print(expected);
      print("obtained:\n");
      print(obtained);
      result = 0;
    }
    kill r3;
    kill R3;
  }
  //Test 5: SubWeyl but not Weyl
  ring R4 = 0,(x,y,z),dp;
  matrix D[3][3] = 0,0,1,0,0,0,0,0,0;
  matrix C[3][3] = 1,1,1,1,1,1,1,1,1;
  def r4 = nc_algebra(C,D);
  expected = 0;
  obtained = ncfactor_isWeyl();
  if (expected !=obtained)
  {
    print("Test 5 for ncfactor_isWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 6: Commutative ring
  ring R5 = 0,(x,d),dp;
  expected = 0;
  obtained = ncfactor_isWeyl();
  if (expected !=obtained)
  {
    print("Test 6 for ncfactor_isWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 7: q-Weyl algebra
  ring R6 = (0,q),(x,d),dp;
  def r6 = nc_algebra(q,1);
  setring r6;
  expected = 0;
  obtained = ncfactor_isWeyl();
  if (expected !=obtained)
  {
    print("Test 7 for ncfactor_isWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 8: Weyl, but with parameter
  ring R7 = (0,q),(x,d),dp;
  def r7 = nc_algebra(1,1);
  setring r7;
  expected = 1;
  obtained = ncfactor_isWeyl();
  if (expected !=obtained)
  {
    print("Test 8 for ncfactor_isWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing ncfactor_isWeyl


static proc ncfactor_isQWeyl()
"
INPUT: None
OUTPUT: Returns 1 if the basering is a q-Weyl algebra,
        0 otherwise.
ASSUMPTIONS:
- A q-Weyl algebra in this setup is an algebra that has
  half as many parameters than variables, and the non-commutative
  relations are strictly given by
  x_id_i = q(i)*d_ix_i+1
"
{//ncfactor_isqWeyl
  if (nvars(basering) % 2 != 0)
  {//Ring cannot be a Weyl algebra, as we need an even number of vars
    return(0);
  }//Ring cannot be a Weyl algebra, as we need an even number of vars
  /* if (npars(basering)!=nvars(basering) div 2) */
  /* {//Ring must have enough parameters */
  /*   return(0); */
  /* }//Ring must have enough parameters */
  list tempRingList = ringlist(basering);
  if (size(tempRingList)<=4)
  {//Given ring is commutative
    return(0);
  }//Given ring is commutative
  matrix C = tempRingList[5];
  matrix D = tempRingList[6];
  int i; int j; int k;
  int validentry;
  //Checking if C is okay.
  for (i = 1; i<ncols(C); i++)
  {//Iterating the diagonal
    for (j = i+1; j<=ncols(C); j++)
    {//Iterating the off-diagonal
      if (C[i,j] != 1)
      {
        validentry = 0;
        for (k = 1; k<=npars(basering); k++)
        {
          if (C[i,j]==par(k) || C[i,j]==1/par(k))
          {
            validentry = 1;
            break;
          }
        }
        if (!validentry)
        {
          return(0);
        }
      }
    }//Iterating the off-diagonal
  }//Iterating the diagonal
  //Checking if D is okay
  int countOnes;
  for (i = 1; i<=ncols(D); i++)
  {//Iterating the diagonal
    countOnes = 0;
    for (j = i+1; j<=ncols(D); j++)
    {//Checking whether there is at most one nontrivial entry in each row.
      if (D[i,j] == 1 or D[i,j]==-1)
      {countOnes++;}
    }//Checking whether there is at most one nontrivial entry in each row.
    if (countOnes > 1)
    {return(0);}
    countOnes = 0;
    for (j = i-1; j>=1; j--)
    {//Checking whether there is at most one nontrivial entry in each col
      if (D[j,i] == 1 or D[j,i]==-1)
      {countOnes++;}
    }//Checking whether there is at most one nontrivial entry in each col
    if (countOnes > 1)
    {return(0);}
  }//Iterating the diagonal

  //Now check if all variables are paired up.
  list the_vars;
  for (i = 1; i<=nvars(basering); i++)
  {
    the_vars[i] = var(i);
  }
  int noPairForFirstOne;
  while(size(the_vars)>0)
  {//We did not pair up all variables yet
    noPairForFirstOne = 1;
    for (i = 2; i<=size(the_vars); i++)
    {//Compare the commutation relations of the jth variable to the first one
      for (k = 1; k<= npars(basering); k++)
      {
    if (the_vars[1]*the_vars[i] - 1/par(k)*the_vars[i]*the_vars[1] ==1 or
        1/par(k)*the_vars[1]*the_vars[i] - the_vars[i]*the_vars[1]==1 or
        the_vars[1]*the_vars[i] - par(k)*the_vars[i]*the_vars[1] ==-1 or
        par(k)*the_vars[1]*the_vars[i] - the_vars[i]*the_vars[1]==-1)
      {//Found a counter matching one
      noPairForFirstOne = 0;
      break;
    }//Found a counter matching one
      }
      if(noPairForFirstOne==0)
      {
        the_vars = delete(the_vars,i);
        the_vars = delete(the_vars,1);
        break;
      }
    }//Compare the commutation relations of the jth variable to the first one
    if(noPairForFirstOne)
    {return(0);}
  }//We did not pair up all variables yet
  return(1);
}//ncfactor_isqWeyl


static proc test_ncfactor_isQWeyl()
{//testing ncfactor_isQWeyl
  int result = 1;
  int i; int j; int k;
  //Test 1: first Weyl algebra, x before d
  ring R = (0,q),(x,d),dp;
  def r = nc_algebra(q,1);
  setring(r);
  int expected = 1;
  int obtained = ncfactor_isQWeyl();
  if (expected !=obtained)
  {
    print("Test 1 for ncfactor_isQWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: first Weyl algebra, d before x
  ring R2 = (0,q),(x,d),dp;
  def r2 = nc_algebra(1/q,-1);
  setring(r2);
  expected = 1;
  obtained = ncfactor_isQWeyl();
  if (expected !=obtained)
  {
    print("Test 2 for ncfactor_isQWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: All possibilities for third Weyl algebra
  list perms =list(list(list(1,0,0,0,0,0),
              list(0,1,0,0,0,0),
              list(0,0,1,0,0,0)),
             list(list(1,0,0,0,0,0),
              list(0,0,1,0,0,0),
              list(0,1,0,0,0,0)),
             list(list(0,1,0,0,0,0),
              list(1,0,0,0,0,0),
              list(0,0,1,0,0,0)),
             list(list(0,1,0,0,0,0),
              list(0,0,1,0,0,0),
              list(1,0,0,0,0,0)),
             list(list(0,0,1,0,0,0),
              list(0,1,0,0,0,0),
              list(1,0,0,0,0,0)),
             list(list(0,0,1,0,0,0),
              list(1,0,0,0,0,0),
              list(0,1,0,0,0,0)));
  for(i=1;i<=size(perms);i++)
  {
    ring R3 = (0,q(1..3)),(x,y,z,w,v,u),dp;
    matrix D[6][6];
    for (j=1;j<=size(perms[i]);j++)
    {
      for (k=1;k<=size(perms[i][j]);k++)
      {
      D[k,3+j]=perms[i][j][k];
      }
    }
    matrix C[6][6] = 1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1;
    for (j=1;j<=size(perms[i]);j++)
    {
      for (k=1;k<=size(perms[i][j]);k++)
      {
      if(perms[i][j][k]==1)
      {
        C[k,3+j]=q(j);
      }
      }
    }
    def r3 = nc_algebra(C,D);
    setring(r3);
    expected = 1;
    obtained = ncfactor_isQWeyl();
    if (expected !=obtained)
    {
      print("Test 3 for ncfactor_isQWeyl failed. Basering:");
      basering;
      print("Expected:\n");
      print(expected);
      print("obtained:\n");
      print(obtained);
      result = 0;
    }
    kill r3;
    kill R3;
  }
  //Test 4: All possibilities for third Weyl algebra reversed
  kill perms;
  list perms =list(list(list(-1,0,0,0,0,0),
              list(0,-1,0,0,0,0),
              list(0,0,-1,0,0,0)),
             list(list(-1,0,0,0,0,0),
              list(0,0,-1,0,0,0),
              list(0,-1,0,0,0,0)),
             list(list(0,-1,0,0,0,0),
              list(-1,0,0,0,0,0),
              list(0,0,-1,0,0,0)),
             list(list(0,-1,0,0,0,0),
              list(0,0,-1,0,0,0),
              list(-1,0,0,0,0,0)),
             list(list(0,0,-1,0,0,0),
              list(0,-1,0,0,0,0),
              list(-1,0,0,0,0,0)),
             list(list(0,0,-1,0,0,0),
              list(-1,0,0,0,0,0),
              list(0,-1,0,0,0,0)));
  for(i=1;i<=size(perms);i++)
  {
    ring R3 = (0,q(1..3)),(x,y,z,w,v,u),dp;
    matrix D[6][6];
    matrix C[6][6] = 1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1;
    for (j=1;j<=size(perms[i]);j++)
    {
      for (k=1;k<=size(perms[i][j]);k++)
      {
      if(perms[i][j][k]==-1)
      {
        C[k,3+j]=1/q(j);
      }
      }
    }
    for (j=1;j<=size(perms[i]);j++)
    {
      for (k=1;k<=size(perms[i][j]);k++)
      {
      D[k,3+j]=perms[i][j][k];
      }
    }
    def r3 = nc_algebra(C,D);
    setring(r3);
    expected = 1;
    obtained = ncfactor_isQWeyl();
    if (expected !=obtained)
    {
      print("Test 4 for ncfactor_isQWeyl failed. Basering:");
      basering;
      print("Expected:\n");
      print(expected);
      print("obtained:\n");
      print(obtained);
      result = 0;
    }
    kill r3;
    kill R3;
  }
  //Test 5: SubQWeyl but not Weyl
  ring R4 = (0,q),(x,y,z),dp;
  matrix D[3][3] = 0,0,1,0,0,0,0,0,0;
  matrix C[3][3] = 1,1,q,1,1,1,1,1,1;
  def r4 = nc_algebra(C,D);
  expected = 0;
  obtained = ncfactor_isQWeyl();
  if (expected !=obtained)
  {
    print("Test 5 for ncfactor_isQWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 6: Commutative ring
  ring R5 = 0,(x,d),dp;
  expected = 0;
  obtained = ncfactor_isQWeyl();
  if (expected !=obtained)
  {
    print("Test 6 for ncfactor_isQWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 7: Weyl algebra
  ring R6 = 0,(x,d),dp;
  def r6 = nc_algebra(1,1);
  setring r6;
  expected = 0;
  obtained = ncfactor_isQWeyl();
  if (expected !=obtained)
  {
    print("Test 7 for ncfactor_isQWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 8: q-Weyl, but with extra parameter
  ring R7 = (0,q,q2),(x,d),dp;
  def r7 = nc_algebra(q,1);
  setring r7;
  expected = 1;
  obtained = ncfactor_isQWeyl();
  if (expected !=obtained)
  {
    print("Test 8 for ncfactor_isQWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing ncfactor_isQWeyl


static proc checkIfProperNthWeyl()
"
INPUT: None
OUTPUT: Checks whether the given basering is a proper Weyl algebra.
        Proper means in the sense of our algorithms, i.e. fulfilling
        the assumption that o ur basering is the Nth Weyl algebra and
        that the xs are the first n variables, the differential
        operators are the last n. Returns 1 if proper, 0 otherwise.
"
{//checkIfProperNthWeyl
  if (!ncfactor_isWeyl())
  {return(0);}
  int i;
  for (i = 1; i<=nvars(basering) div 2; i++)
  {
    if (var(i + nvars(basering) div 2)*var(i)
        - var(i)*var(i+nvars(basering) div 2)!=1)
    {
      return(0);
    }
  }
  return(1);
}//checkIfProperNthWeyl


static proc test_checkIfProperNthWeyl()
{//testing checkIfProperNthWeyl
  int result = 1; int i; int j; int k;
  //Test 1: proper 1st Weyl
  ring R = 0,(x,y),dp;
  def r= nc_algebra(1,1);
  setring r;
  int expected = 1;
  int obtained = checkIfProperNthWeyl();
  if (expected !=obtained)
  {
    print("Test 1 for checkIfProperNthWeyl failed. Basering:");
    basering;
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill R; kill r;
  //Test 2: non proper 1st Weyl
  ring R = 0,(x,y),dp;
  def r= nc_algebra(1,-1);
  setring r;
  expected = 0;
  obtained = checkIfProperNthWeyl();
  if (expected !=obtained)
  {
    print("Test 2 for checkIfProperNthWeyl failed. Basering:");
    basering;
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill R; kill r;
  //Test 3: All possible non-proper third Weyls
  list perms =list(list(list(1,0,0,0,0,0),
            list(0,0,1,0,0,0),
            list(0,1,0,0,0,0)),
           list(list(0,1,0,0,0,0),
            list(1,0,0,0,0,0),
            list(0,0,1,0,0,0)),
           list(list(0,1,0,0,0,0),
            list(0,0,1,0,0,0),
            list(1,0,0,0,0,0)),
           list(list(0,0,1,0,0,0),
            list(0,1,0,0,0,0),
            list(1,0,0,0,0,0)),
           list(list(0,0,1,0,0,0),
            list(1,0,0,0,0,0),
            list(0,1,0,0,0,0)));
  for(i=1;i<=size(perms);i++)
  {
    ring R3 = 0,(x,y,z,w,v,u),dp;
    matrix C[6][6] = 1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1;
    matrix D[6][6];
    for (j=1;j<=size(perms[i]);j++)
    {
      for (k=1;k<=size(perms[i][j]);k++)
      {
    D[k,3+j]=perms[i][j][k];
      }
    }
    def r3 = nc_algebra(C,D);
    setring(r3);
    expected = 0;
    obtained = checkIfProperNthWeyl();
    if (expected !=obtained)
    {
      print("Test 3 for checkIfProperNthWeyl failed.");
      print("Expected:\n");
      print(expected);
      print("obtained:\n");
      print(obtained);
      result = 0;
    }
    kill r3;
    kill R3;
  }
  //Test 4: All reversed possibilities for the 3rd weyl algebra
  kill perms;
  list perms =list(list(list(-1,0,0,0,0,0),
            list(0,-1,0,0,0,0),
            list(0,0,-1,0,0,0)),
           list(list(-1,0,0,0,0,0),
            list(0,0,-1,0,0,0),
            list(0,-1,0,0,0,0)),
           list(list(0,-1,0,0,0,0),
            list(-1,0,0,0,0,0),
            list(0,0,-1,0,0,0)),
           list(list(0,-1,0,0,0,0),
            list(0,0,-1,0,0,0),
            list(-1,0,0,0,0,0)),
           list(list(0,0,-1,0,0,0),
            list(0,-1,0,0,0,0),
            list(-1,0,0,0,0,0)),
           list(list(0,0,-1,0,0,0),
            list(-1,0,0,0,0,0),
            list(0,-1,0,0,0,0)));
  for(i=1;i<=size(perms);i++)
  {
    ring R3 = 0,(x,y,z,w,v,u),dp;
    matrix C[6][6] = 1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1;
    matrix D[6][6];
    for (j=1;j<=size(perms[i]);j++)
    {
      for (k=1;k<=size(perms[i][j]);k++)
      {
    D[k,3+j]=perms[i][j][k];
      }
    }
    def r3 = nc_algebra(C,D);
    setring(r3);
    expected = 0;
    obtained = checkIfProperNthWeyl();
    if (expected !=obtained)
    {
      print("Test 4 for checkIfProperNthWeyl failed.");
      print("Expected:\n");
      print(expected);
      print("obtained:\n");
      print(obtained);
      result = 0;
    }
    kill r3;
    kill R3;
  }
  //Test 5: Proper third Weyl algebra
  ring R = 0,(x1,x2,x3,d1,d2,d3),dp;
  matrix C[6][6] = 1,1,1,1,1,1,
    1,1,1,1,1,1,
    1,1,1,1,1,1,
    1,1,1,1,1,1,
    1,1,1,1,1,1,
    1,1,1,1,1,1;
  matrix D[6][6] = 0,0,0,1,0,0,
    0,0,0,0,1,0,
    0,0,0,0,0,1;
  def r= nc_algebra(C,D);
  setring r;
  expected = 1;
  obtained = checkIfProperNthWeyl();
  if (expected !=obtained)
  {
    print("Test 5 for checkIfProperNthWeyl failed. Basering:");
    basering;
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill R; kill r;
  //Test 6: Commutative ring
  ring R = 0,(x1,x2,x3,d1,d2,d3),dp;
  expected = 0;
  obtained = checkIfProperNthWeyl();
  if (expected !=obtained)
  {
    print("Test 6 for checkIfProperNthWeyl failed. Basering:");
    basering;
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing checkIfProperNthWeyl


static proc checkIfProperNthQWeyl()
"
INPUT: None
OUTPUT: Checks whether the given basering is a proper q-Weyl algebra.
        Proper means in the sense of our algorithms, i.e. fulfilling
        the assumption that o ur basering is the Nth Weyl algebra and
        that the xs are the first n variables, the differential
        operators are the last n. Returns 1 if proper, 0 otherwise.
"
{//checkIfProperNthQWeyl
  if (!ncfactor_isQWeyl())
  {return(0);}
  int i;
  for (i = 1; i<=nvars(basering) div 2; i++)
  {
    if (var(i + nvars(basering) div 2)*var(i)
        - par(i)*var(i)*var(i+nvars(basering) div 2)!=1)
    {
      return(0);
    }
  }
  return(1);
}//checkIfProperNthQWeyl


static proc test_checkIfProperNthQWeyl()
{//testing checkIfProperNthQWeyl
  int result = 1;
  int i; int j; int k;
  //Test 1: first Weyl algebra, x before d
  ring R = (0,q),(x,d),dp;
  def r = nc_algebra(q,1);
  setring(r);
  int expected = 1;
  int obtained = checkIfProperNthQWeyl();
  if (expected !=obtained)
  {
    print("Test 1 for checkIfProperNthQWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: first Weyl algebra, d before x
  ring R2 = (0,q),(x,d),dp;
  def r2 = nc_algebra(q,-1);
  setring(r2);
  expected = 0;
  obtained = checkIfProperNthQWeyl();
  if (expected !=obtained)
  {
    print("Test 2 for checkIfProperNthQWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: All possibilities for third Weyl algebra
  list perms =list(list(list(1,0,0,0,0,0),
              list(0,0,1,0,0,0),
              list(0,1,0,0,0,0)),
             list(list(0,1,0,0,0,0),
              list(1,0,0,0,0,0),
              list(0,0,1,0,0,0)),
             list(list(0,1,0,0,0,0),
              list(0,0,1,0,0,0),
              list(1,0,0,0,0,0)),
             list(list(0,0,1,0,0,0),
              list(0,1,0,0,0,0),
              list(1,0,0,0,0,0)),
             list(list(0,0,1,0,0,0),
              list(1,0,0,0,0,0),
              list(0,1,0,0,0,0)));
  for(i=1;i<=size(perms);i++)
  {
    ring R3 = (0,q(1..3)),(x,y,z,w,v,u),dp;
    matrix D[6][6];
    for (j=1;j<=size(perms[i]);j++)
    {
      for (k=1;k<=size(perms[i][j]);k++)
      {
      D[k,3+j]=perms[i][j][k];
      }
    }
    matrix C[6][6] = 1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1;
    for (j=1;j<=size(perms[i]);j++)
    {
      for (k=1;k<=size(perms[i][j]);k++)
      {
      if(perms[i][j][k]==1)
      {
        C[k,3+j]=q(j);
      }
      }
    }
    def r3 = nc_algebra(C,D);
    setring(r3);
    expected = 0;
    obtained = checkIfProperNthQWeyl();
    if (expected !=obtained)
    {
      print("Test 3 for checkIfProperNthQWeyl failed. Basering:");
      basering;
      print("Expected:\n");
      print(expected);
      print("obtained:\n");
      print(obtained);
      result = 0;
    }
    kill r3;
    kill R3;
  }
  //Test 4: All possibilities for third Weyl algebra reversed
  kill perms;
  list perms =list(list(list(-1,0,0,0,0,0),
              list(0,-1,0,0,0,0),
              list(0,0,-1,0,0,0)),
             list(list(-1,0,0,0,0,0),
              list(0,0,-1,0,0,0),
              list(0,-1,0,0,0,0)),
             list(list(0,-1,0,0,0,0),
              list(-1,0,0,0,0,0),
              list(0,0,-1,0,0,0)),
             list(list(0,-1,0,0,0,0),
              list(0,0,-1,0,0,0),
              list(-1,0,0,0,0,0)),
             list(list(0,0,-1,0,0,0),
              list(0,-1,0,0,0,0),
              list(-1,0,0,0,0,0)),
             list(list(0,0,-1,0,0,0),
              list(-1,0,0,0,0,0),
              list(0,-1,0,0,0,0)));
  for(i=1;i<=size(perms);i++)
  {
    ring R3 = (0,q(1..3)),(x,y,z,w,v,u),dp;
    matrix D[6][6];
    matrix C[6][6] = 1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1,
      1,1,1,1,1,1;
    for (j=1;j<=size(perms[i]);j++)
    {
      for (k=1;k<=size(perms[i][j]);k++)
      {
      if(perms[i][j][k]==-1)
      {
        C[k,3+j]=1/q(j);
      }
      }
    }
    for (j=1;j<=size(perms[i]);j++)
    {
      for (k=1;k<=size(perms[i][j]);k++)
      {
      D[k,3+j]=perms[i][j][k];
      }
    }
    def r3 = nc_algebra(C,D);
    setring(r3);
    expected = 0;
    obtained = checkIfProperNthQWeyl();
    if (expected !=obtained)
    {
      print("Test 4 for checkIfProperNthQWeyl failed. Basering:");
      basering;
      print("Expected:\n");
      print(expected);
      print("obtained:\n");
      print(obtained);
      result = 0;
    }
    kill r3;
    kill R3;
  }
  //Test 5: SubQWeyl but not Weyl
  ring R4 = (0,q),(x,y,z),dp;
  matrix D[3][3] = 0,0,1,0,0,0,0,0,0;
  matrix C[3][3] = 1,1,q,1,1,1,1,1,1;
  def r4 = nc_algebra(C,D);
  expected = 0;
  obtained = checkIfProperNthQWeyl();
  if (expected !=obtained)
  {
    print("Test 5 for checkIfProperNthQWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 6: Commutative ring
  ring R5 = 0,(x,d),dp;
  expected = 0;
  obtained = checkIfProperNthQWeyl();
  if (expected !=obtained)
  {
    print("Test 6 for checkIfProperNthQWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 7: Weyl algebra
  ring R6 = 0,(x,d),dp;
  def r6 = nc_algebra(1,1);
  setring r6;
  expected = 0;
  obtained = checkIfProperNthQWeyl();
  if (expected !=obtained)
  {
    print("Test 7 for checkIfProperNthQWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 8: q-Weyl, but with extra parameter
  ring R7 = (0,q,q2),(x,d),dp;
  def r7 = nc_algebra(q,1);
  setring r7;
  expected = 1;
  obtained = checkIfProperNthQWeyl();
  if (expected !=obtained)
  {
    print("Test 8 for checkIfProperNthQWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing checkIfProperNthQWeyl


//////////////////////////////////////////////////
//*****COMMUTATIVE FACTORIZATION HELPERS**********
//////////////////////////////////////////////////

static proc isInCommutativeSubRing(poly h)
"
INPUT: A polynomial h in an arbitrary polynomial ring.
OUTPUT: 1, if all variables that appear at least in 1 monomial in h
        are all commuting, 0 else.
"
{//isInCommutativeSubRing
  int i; int j; int k;
  intvec tempIntVec;
  int previouslyEncounteredVar = -1;
  if ( attrib(basering, "isLetterplaceRing") >= 1)
  {//separate department: letterplace case
    for (i = 1; i<=size(h); i++)
    {//iterating over the monomials of h
      tempIntVec = lp2iv(h[i]);
      if (size(tempIntVec) > 1)
      {//nontrivial monomial
    j = tempIntVec[1];
    if (previouslyEncounteredVar != -1 and j != previouslyEncounteredVar)
    {//In this case, the previously encountered var is not equal to this one
      return(0);
    }//In this case, the previously encountered var is not equal to this one
    previouslyEncounteredVar = j;
    for (k = 2; k <= size(tempIntVec); k++)
    {//checking if each entry in the intvec is the same
      if (tempIntVec[k]!=j)
      {//more than one variable in monomial
        return(0);
      }//more than one variable in monomial
    }//checking if each entry in the intvec is the same
      }//nontrivial monomial
      else
      {i++; continue;}
    }//iterating over the monomials of h
    return(1);
  }//separate department: letterplace case
  list tempRingList = ringlist(basering);
  if (size(tempRingList)<=4)
  {//In this case, the given ring was commutative
    return(1);
  }//In this case, the given ring was commutative
  list appearing_variables;
  intvec degreeIntVec;
  for (i = 1; i<=nvars(basering);i++)
  {//checking for variables that appear
    degreeIntVec = 0:nvars(basering);
    degreeIntVec[i] = 1;
    if (deg(h, degreeIntVec) >0)
    {//Variable does appear in h
      appearing_variables = appearing_variables + list(var(i));
    }//Variable does appear in h
  }//checking for variables that appear
  for (i = 1; i<size(appearing_variables); i++)
  {
    for (j = i+1; j<=size(appearing_variables); j++)
    {
      if (appearing_variables[i]*appearing_variables[j] -
          appearing_variables[j]*appearing_variables[i] != 0)
      {
        return(0)
      }
    }
  }
  return(1);
}//isInCommutativeSubRing


static proc test_isInCommutativeSubRing()
{//testing isInCommutativeSubRing
  int result = 1;
  //Test 1: Commutative ring anyways
  ring R = 0,(x1,x2,d1,d2),dp;
  int expected = 1;
  int obtained = isInCommutativeSubRing(x1+x2+d1+d2);
  if (expected !=obtained)
  {
    print("Test 1 for isInCommutativeSubRing failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill R;
  //Test 2: Non-commutative ring, constant
  ring R = 0,(x,d),dp;
  def r = nc_algebra(1,1);
  setring(r);
  expected = 1;
  obtained = isInCommutativeSubRing(3445);
  if (expected !=obtained)
  {
    print("Test 2 for isInCommutativeSubRing failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill r; kill R;
  //Test 3: Non-commutative ring, definitely commutative subring
  ring R = 0,(x1,x2,d1,d2),dp;
  def r = Weyl();
  setring r;
  expected = 1;
  obtained = isInCommutativeSubRing(x1*d2+ x1 + d2 + 1);
  if (expected !=obtained)
  {
    print("Test 3 for isInCommutativeSubRing failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: Non-commutative ring, definitely non-commutative subring
  expected = 0;
  obtained = isInCommutativeSubRing(x1*d2*d1+ x1 + d2 + d1+5);
  if (expected !=obtained)
  {
    print("Test 4 for isInCommutativeSubRing failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
  //Test 5: Letterplace ring, negative example
  ring r2 = 0,(x,y,z),dp;
  int d =4; // degree bound
  def R2 = makeLetterplaceRing(d);
  setring R2;
  expected = 0;
  obtained = isInCommutativeSubRing(x + y);
  if (expected !=obtained)
  {
    print("Test 5 for isInCommutativeSubRing failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 6: Letterplace ring, positive example
  expected = 1;
  obtained = isInCommutativeSubRing(x + x*x);
  if (expected !=obtained)
  {
    print("Test 6 for isInCommutativeSubRing failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 7: Letterplace ring, previous bug
  expected = 0;
  obtained = isInCommutativeSubRing(x*x - y*y);
  if (expected !=obtained)
  {
    print("Test 7 for isInCommutativeSubRing failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing isInCommutativeSubRing


static proc factor_commutative(poly h)
"USAGE: factor_commutative(h); h is a polynomial in a
        non-commutative ring, for which all the variables that appear in a
        positive powers in the monomials of h are pairwise commutative.
RETURN: list(list)
PURPOSE: Sometimes, we end up having polynomials in a non-commutative
         ring, which lie in a commutative subring, and we can factor
         them in a commutative fashion.
ASSUME:
- k is a ring, such that factorize can factor any univariate and
  multivariate commutative polynomial over k.
- h is in a commutative subring (NOT CHECKED)
SEE ALSO: ncfactor
"{//proc factor_commutative
  int p = printlevel-voice+2;
  int i; int j;
  string dbprintWhitespace = "";
  for (i = 1; i<=voice;i++)
  {dbprintWhitespace = dbprintWhitespace + " ";}
  if (deg(h)<=0)
  {
    dbprint(p,dbprintWhitespace + "h is a constant. Returning immediately");
    return(list(list(h)));
  }
  def r = basering;
  list factorizeOutput;
  if (size(ring_list(basering))<=4 && (attrib(r, "isLetterplaceRing") == 0) )
  {//commutative ring case
    dbprint(p,dbprintWhitespace + "We are in a commutative ring. Factoring h using factorize.");
    factorizeOutput = factorize(h);
  }//commutative ring case
  else
  {//commutative subring case;
    dbprint(p,dbprintWhitespace + "We are in a commutative subring. Generating commutative ring.");
    if (attrib(r, "isLetterplaceRing") == 0)
    {//G-algebra case
      def rList = ringlist(basering);
      rList = delete(rList,5);
      rList = delete(rList,5);
      def tempRing = ring(rList);
      setring(tempRing);
      poly h = imap(r,h);
      dbprint(p, dbprintWhitespace+"Factoring h in commutative ring.");
      list tempResult = factorize(h);
      setring(r);
      factorizeOutput = imap(tempRing,tempResult);
    }//G-algebra case
    else
    {//Letterplace case
      int theRightVar = lp2iv(h[1])[1];
      list commFactInIv = list();
      list tempMonomList = list();
      def rList = ringlist(basering);
      rList[2] = list("@x");
      rList[3] = list(list("dp", intvec(1)),
              list("C", 0));
      def tempRing = ring(rList);
      setring(tempRing);
      ideal tempIdeal;
      for (i=1; i<=nvars(r); i++)
      {tempIdeal[i] = var(1);}
      map fromR = r, tempIdeal;
      poly h = fromR(h);
      dbprint(p, dbprintWhitespace+"Factoring h in commutative ring.");
      list tempResult = factorize(h);
      dbprint(p, dbprintWhitespace+"Done. The result is:");
      dbprint(p, tempResult);
      dbprint(p, dbprintWhitespace+"Now translated into intvec representation:");
      for (i = 1; i <= size(tempResult[1]); i++)
      {//translate all factorizations into lists of intvecs and coeffs
    commFactInIv[i] = list();
    for (j = 1; j <= size(tempResult[1][i]); j++)
    {//iterate over each monomial
      commFactInIv[i][j] = list(leadcoef(tempResult[1][i][j]));
      if (deg(tempResult[1][i][j]) != 0)
      {//a power of @x
        commFactInIv[i][j] = commFactInIv[i][j] + list(theRightVar:deg(tempResult[1][i][j]));
      }//a power of @x
    }//iterate over each monomial
      }//translate all factorizations into lists of intvecs and coeffs
      dbprint(p, commFactInIv);
      setring(r);
      factorizeOutput = imap(tempRing,tempResult);
      list commFactInIv = imap(tempRing, commFactInIv);
      poly tempEntry;
      for (i = 1; i<=size(commFactInIv); i++)
      {
    tempEntry = 0;
    for (j=1; j<=size(commFactInIv[i]); j++)
    {
      if (size(commFactInIv[i][j]) == 1)
      {//simply a number
        tempEntry = tempEntry + commFactInIv[i][j][1];
      }//simply a number
      else
      {
        tempEntry = tempEntry + commFactInIv[i][j][1]*iv2lp(commFactInIv[i][j][2]);
      }
    }
    factorizeOutput[1][i] = tempEntry;
      }
    }//Letterplace case
  }//commutative subring case;
  dbprint(p,dbprintWhitespace + "Done commutatively factorizing. The result isssssss:");
  dbprint(p,factorizeOutput);
  dbprint(p,dbprintWhitespace+"Computing all permutations of this factorization.");
  list result = list(list());
  for (i = 1; i<=size(factorizeOutput[1]); i++)
  {
    for (j = 1; j<=factorizeOutput[2][i]; j++)
    {
      result[1] = result[1] + list(factorizeOutput[1][i]);
    }
  }
  poly constantFactor = result[1][1];
  result[1] = delete(result[1],1);//Deleting the constant factor
  result=permpp(result[1]);
  for (i = 1; i<=size(result);i++)
  {//Insert constant factor
    result[i] = insert(result[i],constantFactor);
  }//Insert constant factor
  dbprint(p,dbprintWhitespace+"Done.");
  result = delete_duplicates_noteval_and_sort(result);
  return(result);
}//proc factor_commutative


static proc test_factor_commutative()
{//testing factor_commutative
  int result = 1;
  //Test 1: Commutative ring anyways
  ring R = 0,(x1,x2,d1,d2),dp;
  list expected = list(list(poly(1),x1+x2+d1+d2));
  list obtained = factor_commutative(x1+x2+d1+d2);
  if (!isListEqual(expected,obtained))
  {
    print("Test 1 for factor_commutative failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill R;
  //Test 2: G-Algebra, constant
  ring R = 0,(x,d),dp;
  def r = nc_algebra(1,1);
  setring(r);
  list expected = list(list(poly(3445)));
  list obtained = factor_commutative(3445);
  if (!isListEqual(expected,obtained))
  {
    print("Test 2 for factor_commutative failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill r; kill R;
  //Test 3: G-Algebra, definitely commutative subring, irreducible
  ring R = 0,(x1,x2,d1,d2),dp;
  def r = Weyl();
  setring r;
  list expected = list(list(poly(1), x1*d2+ x1 + d2 + 2));
  list obtained = factor_commutative(x1*d2+ x1 + d2 + 2);
  if (!isListEqual(expected,obtained))
  {
    print("Test 3 for factor_commutative failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill r; kill R;
  //Test 4: G-Algebra, definitely commutative subring,
  //reducible
  ring R = 0,(x1,x2,d1,d2),dp;
  def r = Weyl();
  setring r;
  list expected = list(list(poly(1), x1*d2+ x1 + d2 + 2, x1*d2- x1 -
                d2 - 2),
               (list(poly(1), x1*d2- x1 - d2 - 2,  x1*d2+ x1 +
                 d2 + 2)));
  list obtained = factor_commutative((x1*d2+ x1 + d2 + 2)*(x1*d2- x1 -
                               d2 - 2));
  if (!isListEqual(expected,obtained))
  {
    print("Test 4 for factor_commutative failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill r; kill R;
  //Test 5: Letterplace ring, constant
  ring r = 0,(x,y,z),dp;
  int d =4; // degree bound
  def R = makeLetterplaceRing(d);
  setring R;
  list expected = list(list(poly(3445)));
  list obtained = factor_commutative(3445);
  if (!isListEqual(expected,obtained))
  {
    print("Test 5 for factor_commutative failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 6: Letterplace ring, definitely commutative subring, irreducible
  expected = list(list(poly(1), x*x+ 2*x + 2));
  obtained = factor_commutative(x*x+ 2*x + 2);
  if (!isListEqual(expected,obtained))
  {
    print("Test 6 for factor_commutative failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 7: Letterplace ring, definitely commutative subring,
  //reducible
  expected = list(list(poly(1), x*x+ 2*x + 2, x*x- 2*x - 2),
            list(poly(1), x*x- 2*x - 2, x*x+ 2*x + 2));
  obtained = factor_commutative((x*x+ 2*x + 2)*(x*x- 2*x - 2));
  if (!isListEqual(expected,obtained))
  {
    print("Test 7 for factor_commutative failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 8: Letterplace ring, using last variable
  expected = list(list(poly(1), z*z+ 2*z + 2, z*z - 2*z - 2),
            list(poly(1), z*z - 2*z - 2, z*z+ 2*z + 2));
  obtained = factor_commutative((z*z+ 2*z + 2)*(z*z - 2*z - 2));
  if (!isListEqual(expected,obtained))
  {
    print("Test 8 for factor_commutative failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing factor_commutative


static proc factorizeInt(number n)
"Given an integer n, factorizeInt computes its factorization. The output is a list
containing two lists. The first contains the prime factors, the second its powers.
ASSUMPTIONS:
- n is given as integer number
"{//factorizeInt
  if (n==0)
  {return(list(list(0),list(1)));}
  int i;
  list temp = primefactors(n);
  if (n<0)
  {list result = list(list(-1),list(1));}
  else
  {list result = list(list(1),list(1));}
  result[1] = result[1] + temp[1];
  result[2] = result[2] + temp[2];
  return(result);
}//factorizeInt


static proc test_factorizeInt()
{//Testing factorizeInt
  int result =1;
  //Test 1: factorizing 0
  ring R = 0,(x),dp;
  list expected = list(list(0),list(1));
  list obtained = factorizeInt(number(0));
  if (!isListEqual(expected,obtained))
  {
    print("Test 1 for factorizeInt failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: factorizing 1
  expected = list(list(1),list(1));
  obtained = factorizeInt(number(1));
  if (!isListEqual(expected,obtained))
  {
    print("Test 2 for factorizeInt failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: factorizing a positive composite
  expected = list(list(1,2,5),list(1,2,1));
  obtained = factorizeInt(20);
  if (!isListEqual(expected,obtained))
  {
    print("Test 3 for factorizeInt failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: factorizing a negative composite
  expected = list(list(-1,2,5),list(1,2,1));
  obtained = factorizeInt(-20);
  if (!isListEqual(expected,obtained))
  {
    print("Test 4 for factorizeInt failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 5: factoring a prime
  expected = list(list(1,23),list(1,1));
  obtained = factorizeInt(23);
  if (!isListEqual(expected,obtained))
  {
    print("Test 5 for factorizeInt failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//Testing factorizeInt


static proc getAllCoeffTuplesComb(list l)"
Given the output of factorizeInt ((a_1,...,a_n),(i_1,...,i_n)) , it returns all possible tuples
of the set {(a,b) | There exists a real N!=emptyset subset of {1,...,n}, such that
a = prod_{i \in N}a_i, b=prod_{i \not\in N} a_i}
Assumption: The list is sorted from smallest integer to highest.
- it is not the factorization of 0.
"
{//proc getAllCoeffTuplesComb
  list result;
  if (l[1][1] == 0)
  {
    ERROR("getAllCoeffTuplesComb: Zero Coefficients as leading and Tail Coeffs?
That is not possible. Something went wrong.");
  }
  if (size(l[1]) == 1)
  {//Trivial Factorization, just 1
    if (l[1][1] == 1)
    {
      return(list(list(number(1),number(1)),list(-number(1),-number(1))));
    }
    else
    {
      return(list(list(-number(1),number(1)),list(number(1),-number(1))));
    }
  }//Trivial Factorization, just 1
  if (size(l[1]) == 2 and l[2][2]==1)
  {//Just a prime number
    if (l[1][1] == 1)
    {
      result = list(number(l[1][2]),number(1)),list(number(1),number(l[1][2]));
      result = result + list(list(number(-l[1][2]),number(-1)),list(number(-1),number(-l[1][2])));
      return(result);
    }
    else
    {
      result = list(list(number(l[1][2]),number(-1)),list(number(1),number(-l[1][2])));
      result = result + list(list(number(-l[1][2]),number(1)),list(number(-1),number(l[1][2])));
      return(result);
    }
  }//Just a prime number
  //Now comes the interesting case: a product of primes
  list tempPrimeFactors;
  list tempPowersOfThem;
  int i;
  for (i = 2; i<=size(l[1]);i++)
  {//Removing the starting 1 or -1 to get the N's
    tempPrimeFactors[i-1] = l[1][i];
    tempPowersOfThem[i-1] = l[2][i];
  }//Removing the starting 1 or -1 to get the N's
  list Ns = getAllDivisorsFromFactList(list(tempPrimeFactors,tempPowersOfThem));
  list tempTuples;
  number productOfl = multiplyFactIntOutput(l);
  if (productOfl<0){productOfl = -productOfl;}
  tempTuples = tempTuples + list(list(number(1),productOfl),list(productOfl,number(1)));
  for (i = 1; i<=size(Ns); i++)
  {
    if (productOfl/Ns[i]>Ns[i])
    {
      tempTuples = tempTuples + list(list(Ns[i],productOfl/Ns[i]),list(productOfl/Ns[i],Ns[i]));
    }
    if (productOfl/Ns[i]==Ns[i])
    {
      tempTuples = tempTuples + list(list(Ns[i],Ns[i]));
    }
  }
  //And now, it just remains to get the -1s and 1-s correctly to the tuples
  list tempEntry;
  if (l[1][1] == 1)
  {
    for (i = 1; i<=size(tempTuples);i++)
    {//Adding everything to result
      tempEntry = tempTuples[i];
      result = result + list(tempEntry);
      result = result + list(list(-tempEntry[1], -tempEntry[2]));
    }//Adding everyThing to Result
  }
  else
  {
    for (i = 1; i<=size(tempTuples);i++)
    {//Adding everything to result
      tempEntry = tempTuples[i];
      result = result + list(list(tempEntry[1],-tempEntry[2]));
      result = result + list(list(-tempEntry[1], tempEntry[2]));
    }//Adding everyThing to Result
  }
  return(delete_duplicates_noteval_and_sort(result));
}//proc getAllCoeffTuplesComb


static proc test_getAllCoeffTuplesComb()
{//testing getAllCoeffTuplesComb
  int result = 1;
  ring R = 0,(x),dp;
  //Test 1: 1
  list input = factorizeInt(1);
  list expected = list(list(number(1),number(1)),list(-number(1),-number(1)));
  list obtained = getAllCoeffTuplesComb(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 1 for getAllCoeffTuplesComb failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: prime
  input = factorizeInt(13);
  expected = sortFactorizations(
    list(
      list(number(1),number(13)),list(number(13),number(1)),
      list(-number(1),-number(13)),list(-number(13),-number(1))));
  obtained = sortFactorizations(getAllCoeffTuplesComb(input));
  if (!isListEqual(expected,obtained))
  {
    print("Test 2 for getAllCoeffTuplesComb failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: composite
  input = factorizeInt(13*5);
  expected = sortFactorizations(
    list(
      list(number(1),number(13)*number(5)),list(number(13)*number(5),number(1)),
      list(number(13),number(5)),list(number(5),number(13)),
      list(-number(1),-number(13)*number(5)),list(-number(13)*number(5),-number(1)),
      list(-number(13),-number(5)),list(-number(5),-number(13))
      ));
  obtained = sortFactorizations(getAllCoeffTuplesComb(input));
  if (!isListEqual(expected,obtained))
  {
    print("Test 3 for getAllCoeffTuplesComb failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing getAllCoeffTuplesComb


//////////////////////////////////////////////////
//*FACTORIZATION RELATED GENERAL HELPER FUNCTIONS*
//////////////////////////////////////////////////


static proc normalizeFactors(list factList)
"INPUT: A list of factorizations, as outputted e.g. by facWeyl
OUTPUT: If any entry  in a factorization is not primitive, this function
        divides the common divisor out and multiplies the first entry with it.
"
{//normalizeFactors
  int i; int j;
  list result = factList;
  for (i = 1; i<=size(result); i++)
  {//iterating through every different factorization
    for (j=2; j<=size(result[i]); j++)
    {//Iterating through all respective factors
      if (content(result[i][j])!=number(1))
      {//Got one where the content is not equal to 1
        result[i][1] = result[i][1] * content(result[i][j]);
        result[i][j] = result[i][j] / content(result[i][j]);
      }//Got one where the content is not equal to 1
    }//Iterating through all respective factors
  }//iterating through every different factorization
  return(result);
}//normalizeFactors


static proc test_normalizeFactors()
{//testing normalizeFactors
  int result = 1;
  //Test 1: Empty list
  list expected = list();
  list obtained = normalizeFactors(list());
  if (!isListEqual(expected,obtained))
  {
    print("Test 1 for normalizeFactors failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: list with only constant factor
  expected = list(list(2));
  obtained = normalizeFactors(list(list(2)));
  if (!isListEqual(expected,obtained))
  {
    print("Test 2 for normalizeFactors failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  // Test 3: list with one factor, content 1
  ring R = 0,(x,y),dp;
  expected = list(list(2,x^2+y^2));
  obtained = normalizeFactors(list(list(2,x^2+y^2)));
  if (!isListEqual(expected,obtained))
  {
    print("Test 3 for normalizeFactors failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill R;
  // Test 4: list with one factor, content not 1
  ring R = 0,(x,y),dp;
  list expected = list(list(number(6),x^2+y^2));
  list obtained = normalizeFactors(list(list(2,3*x^2+3*y^2)));
  if (!isListEqual(expected,obtained))
  {
    print("Test 4 for normalizeFactors failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill R;
  // Test 5: list with more than one factor, content 1
  ring R = 0,(x,y),dp;
  list expected = list(list(2,x^2+y^2,x,y));
  list obtained = normalizeFactors(list(list(2,x^2+y^2,x,y)));
  if (!isListEqual(expected,obtained))
  {
    print("Test 5 for normalizeFactors failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill R;
  //Test 6: list with more than one factor, content not 1
  ring R = 0,(x,y),dp;
  list expected = list(list(number(12),x^2+y^2,x,y));
  list obtained = normalizeFactors(list(list(2,x^2+y^2,2*x,3*y)));
  if (!isListEqual(expected,obtained))
  {
    print("Test 6 for normalizeFactors failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing normalizeFactors


static proc divides(poly p1, poly p2,map invo, list #)
  "Tests, whether p1 divides p2 either from left or from right. The involution invo is needed
for checking both sides. The optional argument is needed in order to also return the other factor.
RETURN: If no optional argument is given, it will just return 1 or 0.
 Otherwise a list with at least one element
 Case 1: p1 does not divide p2 from any side. Then the output will be the empty list.
 Case 2: p2 does divide p2 from one side at least.
  Then it returns a list with tuples p,q, such that p or q equals p1 and
  pq = p2.
ASSUMPTIONS: - The map invo is an involution on the basering."
{//proc divides
  list result = list();
  poly tempfactor;
  if (involution(reduce(involution(p2,invo),std(involution(ideal(p1),invo))),invo)==0)
  {//p1 is a left divisor
    if(size(#)==0){return(1);}
    tempfactor = involution(lift(involution(p1,invo),involution(p2,invo))[1,1],invo);
    result = result + list(list(content(p1)*content(p2),
                p1/content(p1),tempfactor/content(tempfactor)));
  }//p1 is a left divisor

  if (reduce(p2,std(ideal(p1))) == 0)
  {//p1 is  a right divisor
    if(size(#)==0){return(1);}
    tempfactor = lift(p1, p2)[1,1];
    result = result + list(list(content(p1)*content(p2),
                tempfactor/content(tempfactor),p1/content(p1)));
  }//p1 is already a right divisor
  if (size(#)==0){return(0);}
  return(result);
}//proc divides


static proc test_divides()
{//testing divides
  int result = 1;
  //Test 1: both polys are constant
  ring R = 0,(x,y),dp;
  def r = nc_algebra(1,1);
  setring r;
  map invo = r, -x , y;
  int expected = 1;
  int obtained = divides(1,2,invo);
  if (expected!=obtained)
  {
    print("Test 1 for divides failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: poly 1 does not divide poly 2
  expected = 0;
  obtained = divides(x+y, x-y, invo);
  if (expected!=obtained)
  {
    print("Test 2 for divides failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: poly 1 does divide poly 2 from the left
  expected = 1;
  obtained = divides(x+y, (x+y)*(x-y), invo);
  list  poly_expected = list(list(number(1),x+y,x-y));
  list  poly_obtained = divides(x+y, (x+y)*(x-y), invo,1);
  if (expected!=obtained||!isListEqual(poly_expected,poly_obtained))
  {
    print("Test 3 for divides failed.");
    print("Expected 1:\n");
    print(expected);
    print("Obtained 1:\n");
    print(obtained);
    print("Expected 2:\n");
    print(poly_expected);
    print("Obtained 2:\n");
    print(poly_obtained);
    result = 0;
  }
  //Test 4: poly 1 does divide poly 2 from the right
  expected = 1;
  obtained = divides(x+y, (x-y)*(x+y), invo);
  poly_expected = list(list(1,x-y,x+y));
  poly_obtained = divides(x+y, (x-y)*(x+y), invo,1);
  if (expected!=obtained)
  {
    print("Test 4 for divides failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    print("Expected 2:\n");
    print(poly_expected);
    print("Obtained 2:\n");
    print(poly_obtained);
    result = 0;
  }
  kill R; kill r;
  //Test 5: different algebra, no division
  ring R = 0,(x1,x2,n1,n2),dp;
  matrix C[4][4] = 1,1,1,1,
    1,1,1,1,
    1,1,1,1,
    1,1,1,1;
  matrix D[4][4] = 0,0,n1,0,
    0,0,0,n2,
    0,0,0,0,
    0,0,0,0;
  def r = nc_algebra(C,D);
  setring r;
  map invo = r, -x1,-x2,n1,n2;
  expected = 0;
  obtained = divides(x1+n1, (x1-n1), invo);
  if (expected!=obtained)
  {
    print("Test 5 for divides failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 6: different algebra, division from both sides
  expected = 1;
  obtained = divides(x1+n1, (x1+n1)*(x1-n1)*(x1+n1), invo);
  list poly_expected = list(list(number(1), (x1+n1),(x1-n1)*(x1+n1)),
                list(number(1), (x1+n1)*(x1-n1),(x1+n1)));
  list poly_obtained = divides(x1+n1, (x1+n1)*(x1-n1)*(x1+n1), invo,1);
  if (expected!=obtained||!isListEqual(poly_expected,poly_obtained))
  {
    print("Test 6 for divides failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    print("Expected 2:\n");
    print(poly_expected);
    print("Obtained 2:\n");
    print(poly_obtained);
    result = 0;
  }
  //Test 7: Content is not 1
  expected = 1;
  obtained = divides(x1+n1, 5*(x1+n1)*(x1-n1)*(x1+n1), invo);
  poly_expected = list(list(number(5), (x1+n1),(x1-n1)*(x1+n1)),
               list(number(5), (x1+n1)*(x1-n1),(x1+n1)));
  poly_obtained = divides(x1+n1, 5*(x1+n1)*(x1-n1)*(x1+n1), invo,1);
  if (expected!=obtained||!isListEqual(poly_expected,poly_obtained))
  {
    print("Test 7 for divides failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    print("Expected 2:\n");
    print(poly_expected);
    print("Obtained 2:\n");
    print(poly_obtained);
    result = 0;
  }
  return(result);
}//testing divides


static proc multiplyFactIntOutput(list l)
"Given the output of factorizeInt, this method computes the product of it."
{//proc multiplyFactIntOutput
  int i;
  number result = 1;
  for (i = 1; i<=size(l[1]); i++)
  {
    result = result*(l[1][i])^(l[2][i]);
  }
  return(result);
}//proc multiplyFactIntOutput


static proc test_multiplyFactIntOutput()
{//testing multiplyFactIntOutput
  int result = 1;
  //Test 1: empty list
  ring R = 0,(x),dp;
  number expected = 1;
  number obtained = multiplyFactIntOutput(list(list(),list()));
  if (expected!=obtained)
  {
    print("Test 1 for multiplyFactIntOutput failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: 1
  expected = 1;
  obtained = multiplyFactIntOutput(factorizeInt(1));
  if (expected!=obtained)
  {
    print("Test 2 for multiplyFactIntOutput failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: prime
  expected = 5;
  obtained = multiplyFactIntOutput(factorizeInt(5));
  if (expected!=obtained)
  {
    print("Test 3 for multiplyFactIntOutput failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: Arbitrary composite
  expected = 5*10*66;
  obtained = multiplyFactIntOutput(factorizeInt(5*10*66));
  if (expected!=obtained)
  {
    print("Test 4 for multiplyFactIntOutput failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 5: 0
  expected = 0;
  obtained = multiplyFactIntOutput(factorizeInt(0));
  if (expected!=obtained)
  {
    print("Test 5 for multiplyFactIntOutput failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing multiplyFactIntOutput


//Testfac: Given a list with different factorizations of
// one polynomial, the following procedure checks
// whether they all refer to the same polynomial.
// If they do, the output will be a list, that contains
// the product of each factorization. If not, the empty
// list will be returned.
// If the optional argument # is given (i.e. the polynomial
// which is factorized by the elements of the given list),
// then we look, if the entries are factorizations of p
// and if not, a list with the products subtracted by p
// will be returned
proc testNCfac(list l, list #)
"USAGE: testNCfac(l[,p,b]); l is a list, p is an optional poly, b is 1 or 0
RETURN: Case 1: No optional argument. In this case the output is 1, if the
  entries in the given list represent the same polynomial or 0
  otherwise.
 Case 2: One optional argument p is given. In this case it returns 1,
  if all the entries in l are factorizations of p, otherwise 0.
 Case 3: Second optional b is given. In this case a list is returned
  containing the difference between the product of each entry in
  l and p.
ASSUME: basering is the first Weyl algebra, the entries of l are polynomials
PURPOSE: Checks whether a list of factorizations contains factorizations of
  the same element in the first Weyl algebra
THEORY: @code{testNCfac} multiplies out each factorization and checks whether
 each factorization was a factorization of the same element.
@* - if there is only a list given, the output will be 0, if it
     does not contain factorizations of the same element. Otherwise the output
     will be 1.
@* - if there is a polynomial in the second argument, then the procedure checks
     whether the given list contains factorizations of this polynomial. If it
     does, then the output depends on the third argument. If it is not given,
     the procedure will check whether the factorizations in the list
     l are associated to this polynomial and return either 1 or 0, respectively.
     If the third argument is given, the output will be a list with
     the length of the given one and in each entry is the product of one
     entry in l subtracted by the polynomial.
EXAMPLE: example testNCfac; shows examples
SEE ALSO: facFirstWeyl, facSubWeyl, facFirstShift
"{//proc testfac
  int p = printlevel - voice + 2;
  int i;
  string dbprintWhitespace = "";
  for (i = 1; i<=voice;i++)
  {dbprintWhitespace = dbprintWhitespace + " ";}
  dbprint(p,dbprintWhitespace + " Checking the input");
  if (size(l)==0)
  {//The empty list is given
    dbprint(p,dbprintWhitespace + " Given list was empty");
    return(list());
  }//The empty list is given
  if (size(#)>2)
  {//We want max. two optional arguments
    dbprint(p,dbprintWhitespace + " More than two optional arguments");
    return(list());
  }//We want max. two optional arguments
  dbprint(p,dbprintWhitespace + " Done");
  list result;
  int j;
  if (size(#)==0)
  {//No optional argument is given
    dbprint(p,dbprintWhitespace + " No optional arguments");
    int valid = 1;
    for (i = size(l);i>=1;i--)
    {//iterate over the elements of the given list
      if (size(result)>0)
      {
        if (product(l[i])!=result[size(l)-i])
        {
          valid = 0;
          break;
        }
      }
      result = insert(result, product(l[i]));
    }//iterate over the elements of the given list
    return(valid);
  }//No optional argument is given
  else
  {
    dbprint(p,dbprintWhitespace + " Optional arguments are given.");
    int valid = 1;
    for (i = size(l);i>=1;i--)
    {//iterate over the elements of the given list
      if (product(l[i])!=#[1])
      {
        valid = 0;
      }
      result = insert(result, product(l[i])-#[1]);
    }//iterate over the elements of the given list
    if(size(#)==2)
    {
      dbprint(p,dbprintWhitespace + " A third argument is given. Output is a list now.");
      return(result);
    }
    return(valid);
  }
}//proc testfac
example
{
  "EXAMPLE:";echo=2;
  ring r = 0,(x,y),dp;
  def R = nc_algebra(1,1);
  setring R;
  poly h = (x^2*y^2+1)*(x^2);
  def t1 = facFirstWeyl(h);
  //fist a correct list
  testNCfac(t1);
  //now a correct list with the factorized polynomial
  testNCfac(t1,h);
  //now we put in an incorrect list without a polynomial
  t1[3][3] = y;
  testNCfac(t1);
  // take h as additional input
  testNCfac(t1,h);
  // take h as additional input and output list of differences
  testNCfac(t1,h,1);
}


static proc test_testNCfac()
{//testing testNCfac
  int result = 1;
  //Test 1: 1, no second or third parameter
  int expected = 1;
  int obtained = testNCfac(list(list(1)));
  if (expected!=obtained)
  {
    print("Test 1 for testNCfac failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: 1, second parameter, no third parameter
  expected = 1;
  obtained = testNCfac(list(list(1)),1);
  if (expected!=obtained)
  {
    print("Test 2 for testNCfac failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: 1, all possible parameters set
  list expected_third = list(0);
  list obtained_third = testNCfac(list(list(1)),1,1);
  if (!isListEqual(expected_third,obtained_third))
  {
    print("Test 3 for testNCfac failed.");
    print("Expected:\n");
    print(expected_third);
    print("obtained:\n");
    print(obtained_third);
    result = 0;
  }
  //Test 4: correct factorization, more than one element, no second or
  //third parameter
  ring R = 0,(x,d),dp;
  def r = nc_algebra(1,1);
  setring r;
  expected = 1;
  obtained =
    testNCfac(list(list(1,x4d-x3d-3x3+3x2d+6x2-3xd-3x+12,x2d+xd-3x-1),
           list(1,x4d+x3d-4x3+3x2d-3x2+3xd-6x-3,x2d-xd-2x+4)));
  if (expected!=obtained)
  {
    print("Test 4 for testNCfac failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 5: correct factorization, more than one element, correct second
  //but not third parameter
  expected = 1;
  obtained =
    testNCfac(list(list(1,x4d-x3d-3x3+3x2d+6x2-3xd-3x+12,x2d+xd-3x-1),
           list(1,x4d+x3d-4x3+3x2d-3x2+3xd-6x-3,x2d-xd-2x+4)),
      (x^6+2*x^4-3*x^2)*d^2-(4*x^5-4*x^4-12*x^2-12*x)*d +
      (6*x^4-12*x^3-6*x^2-24*x-12));
  if (expected!=obtained)
  {
    print("Test 5 for testNCfac failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 6: incorrect factorization, more than one element, incorrect second
  //but not third parameter
  expected = 0;
  obtained =
    testNCfac(list(list(1,x4d-x3d-3x3+3x2d+6x2-3xd-3x+12,x2d+xd-3x-1),
           list(1,x4d+x3d-4x3+3x2d-3x2+3xd-6x-3,x2d-xd-2x+4)),
      (x^6+2*x^4-3*x^2)*d^2-(4*x^5-4*x^4-12*x^2-12*x)*d +
      (6*x^4-12*x^3-6*x^2-24*x+12));
  if (expected!=obtained)
  {
    print("Test 6 for testNCfac failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 7: incorrect factorization, more than one element, no second
  //or third parameter
  expected = 0;
  obtained =
    testNCfac(list(list(1,x4d-x3d-3x3+3x2d+6x2-3xd-3x+12,x2d+xd-3x-1),
           list(1,x4d+x3d-4x3+3x2d-3x2+3xd-6x-3,x2d-xd-2x-4)));
  if (expected!=obtained)
  {
    print("Test 7 for testNCfac failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 8: correct factorization, more than one element, correct second
  //and third parameter
  expected_third = list(poly(0),poly(0));
  obtained_third =
    testNCfac(list(list(1,x4d-x3d-3x3+3x2d+6x2-3xd-3x+12,x2d+xd-3x-1),
           list(1,x4d+x3d-4x3+3x2d-3x2+3xd-6x-3,x2d-xd-2x+4)),
          (x^6+2*x^4-3*x^2)*d^2-(4*x^5-4*x^4-12*x^2-12*x)*d +
          (6*x^4-12*x^3-6*x^2-24*x-12),1);
  if (!isListEqual(expected_third,obtained_third))
  {
    print("Test 8 for testNCfac failed.");
    print("Expected:\n");
    print(expected_third);
    print("obtained:\n");
    print(obtained_third);
    result = 0;
  }
  //Test 9: incorrect factorization, more than one element, correct second
  //and third parameter
  expected_third = list(poly(2x4d-2x3d-6x3+6x2d+12x2-6xd-6x+24),poly(0));
  obtained_third =
    testNCfac(list(list(1,x4d-x3d-3x3+3x2d+6x2-3xd-3x+12,x2d+xd-3x+1),
           list(1,x4d+x3d-4x3+3x2d-3x2+3xd-6x-3,x2d-xd-2x+4)),
          (x^6+2*x^4-3*x^2)*d^2-(4*x^5-4*x^4-12*x^2-12*x)*d +
          (6*x^4-12*x^3-6*x^2-24*x-12),1);
  if (!isListEqual(expected_third,obtained_third))
  {
    print("Test 9 for testNCfac failed.");
    print("Expected:\n");
    print(expected_third);
    print("obtained:\n");
    print(obtained_third);
    result = 0;
  }
  //Test 9: correct factorization, more than one element, incorrect second
  //and third parameter
  expected_third = list(poly(-24),poly(-24));
  obtained_third =
    testNCfac(list(list(1,x4d-x3d-3x3+3x2d+6x2-3xd-3x+12,x2d+xd-3x-1),
           list(1,x4d+x3d-4x3+3x2d-3x2+3xd-6x-3,x2d-xd-2x+4)),
          (x^6+2*x^4-3*x^2)*d^2-(4*x^5-4*x^4-12*x^2-12*x)*d +
          (6*x^4-12*x^3-6*x^2-24*x+12),1);
  if (!isListEqual(expected_third,obtained_third))
  {
    print("Test 9 for testNCfac failed.");
    print("Expected:\n");
    print(expected_third);
    print("obtained:\n");
    print(obtained_third);
    result = 0;
  }
  return(result);
}//testing testNCfac


static proc monsSmallerThan(poly e, intvec maxDegInCoordinates)
"USAGE: monsSmallerThan(e, maxDegInCoordinates); e is a
polynomial, but we are only interested in its leading monomial.
maxDegInCoordinates encodes the maximal degree we want to encounter
in each variable.
RETURN: list
PURPOSE: Computes all monomials in the basering which are degree-wise
smaller than the leading monomial of e.
"{//monsSmallerThan
  int p=printlevel-voice+2;//for dbprint
  int i;
  string dbprintWhitespace = "";
  for (i = 1; i<=voice;i++)
  {dbprintWhitespace = dbprintWhitespace + " ";}
  list result;
  intvec tempIntVec = leadexp(1);
  while(increment_intvec(tempIntVec,maxDegInCoordinates) != tempIntVec)
  {//counting through all possible monomials
    tempIntVec = increment_intvec(tempIntVec,maxDegInCoordinates);
    if (monomial(tempIntVec)<leadmonom(e))
    {
      result = insert(result, monomial(tempIntVec));
    }
  }//counting through all possible monomials
  return(result);
}//monsSmallerThan


static proc test_monsSmallerThan()
{//testing monsSmallerThan
  int result = 1;
  ring R = 0,(x,y,z,d,w),lp;
  //Test 1: 0
  poly input1 = 0;
  intvec input2 = intvec(2,2,2,2,2);
  list expected = list();
  list obtained = monsSmallerThan(input1, input2);
  if (!isListEqual(expected,obtained))
  {
    print("Test 1 for monsSmallerThan failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: 1
  input1 = 1;
  input2 = intvec(2,2,2,2,2);
  expected = list();
  obtained = monsSmallerThan(input1, input2);
  if (!isListEqual(expected,obtained))
  {
    print("Test 2 for monsSmallerThan failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: lowest monomial
  input1 = w;
  input2 = intvec(2,2,2,2,2);
  expected = list();
  obtained = monsSmallerThan(input1, input2);
  if (!isListEqual(expected,obtained))
  {
    print("Test 3 for monsSmallerThan failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: second lowest monomial
  input1 = d;
  input2 = intvec(2,2,2,2,2);
  expected = list(w^2,w);
  obtained = monsSmallerThan(input1, input2);
  if (!isListEqual(expected,obtained))
  {
    print("Test 4 for monsSmallerThan failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 5: third lowest monomial, no second lowest
  input1 = z;
  input2 = intvec(2,2,2,0,2);
  expected = list(w^2,w);
  obtained = monsSmallerThan(input1, input2);
  if (!isListEqual(expected,obtained))
  {
    print("Test 5 for monsSmallerThan failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 6: highest monomial, random max degrees for the others
  input1 = x;
  input2 = intvec(3,1,1,0,1);
  expected = list(yzw,yz,yw,y,zw,z,w);
  obtained = monsSmallerThan(input1, input2);
  if (!isListEqual(expected,obtained))
  {
    print("Test 6 for monsSmallerThan failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return (result);
}//testing monsSmallerThan


static proc getMaxDegreeVec(poly h)
"USAGE: getMaxDegreeVec(h); h is a polynomial in the
current ring.
RETURN: intvec
PURPOSE: Returns for each variable in the ring the maximal
         degree in which it appears in h.
"
{
  if (h == 0)
  {return(0:nvars(basering));}
  intvec tempIntVec1 = 0:nvars(basering);
  intvec maxDegrees = 0:nvars(basering);
  int i;
  for (i = 1; i <= nvars(basering); i++)
  {//filling maxDegrees
    tempIntVec1 = 0:nvars(basering);
    tempIntVec1[i] = 1;
    maxDegrees[i] = deg(h,tempIntVec1);
  }//filling maxDegrees
  return(maxDegrees);
}


static proc test_getMaxDegreeVec()
{//testing getMaxDegreeVec
  int result = 1;
  //Test1: 0
  ring R = 0,(u,v,w,x,y,z),dp;
  intvec expected = 0:6;
  intvec obtained = getMaxDegreeVec(0);
  if (expected!=obtained)
  {
    print("Test 1 for getMaxDegreeVec failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test2: Constant neq 0
  expected = 0:6;
  obtained = getMaxDegreeVec(5);
  if (expected!=obtained)
  {
    print("Test 2 for getMaxDegreeVec failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: univariate, first variable
  expected = 2,0,0,0,0,0;
  obtained = getMaxDegreeVec(5*u^2 + u + 1);
  if (expected!=obtained)
  {
    print("Test 3 for getMaxDegreeVec failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: univariate, another variable
  expected = 0,0,0,3,0,0;
  obtained = getMaxDegreeVec(5*x^3 + x^2 + 1);
  if (expected!=obtained)
  {
    print("Test 4 for getMaxDegreeVec failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 5: random polynomial
  expected = 3,1,2,4,3,2;
  obtained = getMaxDegreeVec(u^3*x^2*v*w^2*z + x^4 + y^3*z^2 + 1);
  if (expected!=obtained)
  {
    print("Test 5 for getMaxDegreeVec failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing getMaxDegreeVec


static proc isFactorizationSmaller(list f1, list f2)
"USAGE: isFactorizationSmallerEq(f1,f2); f1 and f2 are lists
        containing polynomials
RETURN: bool
PURPOSE: Checks entry-wise of all factorizations in f1 are smaller
         than the ones in f2 (lexicographic order, starting from
     the first position).
"{//proc isFactorizationSmaller
  return (string(f1)<string(f2));
}//proc isFactorizationSmaller


static proc test_isFactorizationSmaller()
{//isFactorizationSmaller
  int result = 1;
  ring R = 0,(x,d),dp;
  def r = nc_algebra(1,1);
  setring r;
  //Test 1: Two equal lists, empty
  list input1 = list();
  list input2 = list();
  int expected = 0;
  int obtained = isFactorizationSmaller(input1,input2);
  if (expected!=obtained)
  {
    print("Test 1 for isFactorizationSmaller failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: Two not equal lists, first one is empty
  input1 = list(1,2,3);
  input2 = list();
  expected = 0;
  obtained = isFactorizationSmaller(input1,input2);
  if (expected!=obtained)
  {
    print("Test 2 for isFactorizationSmaller failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: Two not equal lists, second one is empty
  input1 = list();
  input2 = list(1,2,3);
  expected = 1;
  obtained = isFactorizationSmaller(input1,input2);
  if (expected!=obtained)
  {
    print("Test 3 for isFactorizationSmaller failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: Two different factorizations, real ones
  input1 = list(1,x4d-x3d-3x3+3x2d+6x2-3xd-3x+12,x2d+xd-3x-1);
  input2 = list(1,x4d+x3d-4x3+3x2d-3x2+3xd-6x-3,x2d-xd-2x+4);
  expected = 0;
  obtained = isFactorizationSmaller(input1,input2);
  if (expected!=obtained)
  {
    print("Test 4 for isFactorizationSmaller failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 5: Same as test 4, but reversed
  input1 = list(1,x4d+x3d-4x3+3x2d-3x2+3xd-6x-3,x2d-xd-2x+4);
  input2 = list(1,x4d-x3d-3x3+3x2d+6x2-3xd-3x+12,x2d+xd-3x-1);
  expected = 1;
  obtained = isFactorizationSmaller(input1,input2);
  if (expected!=obtained)
  {
    print("Test 5 for isFactorizationSmaller failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing isFactorizationSmaller


static proc sortedInsert(list newFact, list factList)
"USAGE: sortedInsert(newFact, factList); newFact is a list that
represents a factorization of a certain polynomial, and factList is a
list containing several different factorizations of the same
polynomial.
RETURN: list(list)
PURPOSE: Inserts newFact into factList, if not yet contained in
         factList.
"{//proc sortedInsert
  int first = 1;
  int last = size(factList);
  int middle;
  while (first <= last)
  {
    middle = first + ((last - first) div 2);
    if (isFactorizationSmaller(factList[middle], newFact))
    {
      first = middle + 1;
    }
    else
    {
      if (isFactorizationSmaller(newFact, factList[middle]))
      {
        last = middle -1;
      }
      else
      {
        return(factList);
      }
    }
  }
  return(insert(factList,newFact,first-1));
}//proc sortedInsert


static proc test_sortedInsert()
{//testing sortedInsert
  int result = 1;
  //Test 1: empty list to insert into empty list
  ring R = 0,(x,d),dp;
  def r = nc_algebra(1,1);
  setring r;
  list input1 = list();
  list input2 = list();
  list expected = list(list());
  list obtained = sortedInsert(input1,input2);
  if (!isListEqual(expected,obtained))
  {
    print("Test 1 for sortedInsert failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: One element list, insert
  input1 = list(1,x4d+x3d-4x3+3x2d-3x2+3xd-6x-3,x2d-xd-2x+4);
  input2 = list(list(1,x4d-x3d-3x3+3x2d+6x2-3xd-3x+12,x2d+xd-3x-1));
  expected = list(list(1,x4d+x3d-4x3+3x2d-3x2+3xd-6x-3,x2d-xd-2x+4),
    list(1,x4d-x3d-3x3+3x2d+6x2-3xd-3x+12,x2d+xd-3x-1));
  obtained = sortedInsert(input1,input2);
  if (!isListEqual(expected,obtained))
  {
    print("Test 2 for sortedInsert failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: Multi-element list, insert in middle
  input1 = list(1,x4d-x3d-2x3+3x2d-3x2+3xd-6x-3,x2d-xd-2x+4);
  input2 = list(list(1,x4d+x3d-4x3+3x2d-3x2+3xd-6x-3,x2d-xd-2x+4),
        list(1,x4d-x3d-3x3+3x2d+6x2-3xd-3x+12,x2d+xd-3x-1));
  expected = list(list(1,x4d+x3d-4x3+3x2d-3x2+3xd-6x-3,x2d-xd-2x+4),
          list(1,x4d-x3d-2x3+3x2d-3x2+3xd-6x-3,x2d-xd-2x+4),
          list(1,x4d-x3d-3x3+3x2d+6x2-3xd-3x+12,x2d+xd-3x-1));
  obtained = sortedInsert(input1,input2);
  if (!isListEqual(expected,obtained))
  {
    print("Test 3 for sortedInsert failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing sortedInsert


static proc isFactorizationEqual(list l1, list l2)
"USAGE: isFactorizationEqual(l1,l2); l1 and l2 are factorizations of
        the same polynomial.
RETURN: bool
PURPOSE: checks if two lists are equal in every entry.
"{//isFactorizationEqual
  if (size(l1)!=size(l2))
  { return(0); }
  int i;
  for (i=1;i<=size(l1);i++)
  {
    if (l1[i]!=l2[i])
    {return(0);}
  }
  return(1);
}//isFactorizationEqual


static proc test_isFactorizationEqual()
{//testing isFactorizationEqual
  int result = 1;
  ring R = 0,(x,d),dp;
  def r = nc_algebra(1,1);
  setring r;
  //Test 1: Two empty lists
  int expected = 1;
  list input1 = list();
  list input2 = list();
  int obtained = isFactorizationEqual(input1,input2);
  if (expected!=obtained)
  {
    print("Test 1 for isFactorizationEqual failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: empty list, non-empty list
  expected = 0;
  input1 = list();
  input2 = list(1,x,d);
  obtained = isFactorizationEqual(input1,input2);
  if (expected!=obtained)
  {
    print("Test 2 for isFactorizationEqual failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: non-empty list, empty list
  expected = 0;
  input1 = list(1,x,d);
  input2 = list();
  obtained = isFactorizationEqual(input1,input2);
  if (expected!=obtained)
  {
    print("Test 3 for isFactorizationEqual failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: Two different factorizations of the same polynomial
  expected = 0;
  input1 = list(1,x4d+x3d-4x3+3x2d-3x2+3xd-6x-3,x2d-xd-2x+4);
  input2 = list(1,x4d-x3d-3x3+3x2d+6x2-3xd-3x+12,x2d+xd-3x-1);
  obtained = isFactorizationEqual(input1,input2);
  if (expected!=obtained)
  {
    print("Test 4 for isFactorizationEqual failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 5: Two same factorizations
  expected = 1;
  input1 = list(1,x4d+x3d-4x3+3x2d-3x2+3xd-6x-3,x2d-xd-2x+4);
  input2 = list(1,x4d+x3d-4x3+3x2d-3x2+3xd-6x-3,x2d-xd-2x+4);
  obtained = isFactorizationEqual(input1,input2);
  if (expected!=obtained)
  {
    print("Test 5 for isFactorizationEqual failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing isFactorizationEqual


static proc sortFactorizations(list factList)
"USAGE: sortFactorizations(factList); factList is a list of different
        factorizations of the same polynomial h.
RETURN: list(list)
PURPOSE: sorts the list of factorizations in O(nlog(n))
"{//sortFactorizations
  if (size(factList)<=1)
  {//empty lists and 1 element lists are already sorted.
    return(factList);
  }//empty lists and 1 element lists are already sorted.
  int middle = size(factList) div 2;
  list left;
  list right;
  int i;
  for (i = 0; i<middle;i++)
  {//filling in left
    left = insert(left, factList[i+1], i);
  }//filling in left
  for (i = middle; i<size(factList);i++)
  {//filling in right
    right = insert(right, factList[i+1], i-middle);
  }//filling in right
  left = sortFactorizations(left);
  right = sortFactorizations(right);
  list result;
  int posl=1;
  int posr=1;
  for (i = 1; i<=size(left)+size(right); i++)
  {//merging the lists
    if (posl > size(left))
    {//we can only insert elements from the right list
      result= insert(result, right[posr], i-1);
      posr++;
    }//we can only insert elements from the right list
    else
    {//in this case we have still elements in the left list
      if (posr>size(right))
      {//only elements from the left list can be filled
    result= insert(result, left[posl], i-1);
    posl++;
      }//only elements from the left list can be filled
      else
      {//We have still both lists available
    if (isFactorizationSmaller(left[posl],right[posr]))
    {
      result= insert(result, left[posl], i-1);
      posl++;
    }
    else
    {
      result= insert(result, right[posr], i-1);
      posr++;
    }
      }//We have still both lists available
    }//in this case we have still elements in the left list
  }//merging the lists
  return(result);
}//sortFactorizations


static proc test_sortFactorizations()
{//testing sortFactorizations
  int result = 1;
  //Test 1: empty list
  list input = list();
  list expected = list();
  list obtained = sortFactorizations(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 1 for sortFactorizations failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: sorted list, two elements
  ring R = 0,(x,d),dp;
  def r = nc_algebra(1,1);
  setring(r);
  input = list(list(1,x4d+x3d-4x3+3x2d-3x2+3xd-6x-3,x2d-xd-2x+4),
           list(1,x4d-x3d-3x3+3x2d+6x2-3xd-3x+12,x2d+xd-3x-1));
  expected = input;
  obtained = sortFactorizations(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 2 for sortFactorizations failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: unsorted list, two elements
  input = list(list(1,x4d-x3d-3x3+3x2d+6x2-3xd-3x+12,x2d+xd-3x-1),
           list(1,x4d+x3d-4x3+3x2d-3x2+3xd-6x-3,x2d-xd-2x+4));
  expected = list(list(1,x4d+x3d-4x3+3x2d-3x2+3xd-6x-3,x2d-xd-2x+4),
          list(1,x4d-x3d-3x3+3x2d+6x2-3xd-3x+12,x2d+xd-3x-1));
  obtained = sortFactorizations(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 3 for sortFactorizations failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: sorted list, many elements
  input = list(list(1,d,xd-2,x+1,x-1,x2+1),
           list(1,d,xd-2,x+1,x2+1,x-1),
           list(1,d,xd-2,x-1,x+1,x2+1),
           list(1,d,xd-2,x-1,x2+1,x+1),
           list(1,d,xd-2,x2+1,x+1,x-1),
           list(1,d,xd-2,x2+1,x-1,x+1),
           list(1,x3d+3x2+xd-1,d,x+1,x-1),
           list(1,x3d+3x2+xd-1,d,x-1,x+1),
           list(1,xd-1,d,x+1,x-1,x2+1),
           list(1,xd-1,d,x+1,x2+1,x-1),
           list(1,xd-1,d,x-1,x+1,x2+1),
           list(1,xd-1,d,x-1,x2+1,x+1),
           list(1,xd-1,d,x2+1,x+1,x-1),
           list(1, xd-1,d,x2+1,x-1,x+1));
  expected = input;
  obtained = sortFactorizations(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 4 for sortFactorizations failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 5: unsorted list, many elements
  input = list(list(1,d,xd-2,x-1,x+1,x2+1),
           list(1,d,xd-2,x+1,x-1,x2+1),
           list(1,d,xd-2,x-1,x2+1,x+1),
           list(1,d,xd-2,x2+1,x+1,x-1),
           list(1,d,xd-2,x2+1,x-1,x+1),
           list(1,x3d+3x2+xd-1,d,x-1,x+1),
           list(1,x3d+3x2+xd-1,d,x+1,x-1),
           list(1,xd-1,d,x+1,x-1,x2+1),
           list(1,xd-1,d,x+1,x2+1,x-1),
           list(1,xd-1,d,x-1,x+1,x2+1),
           list(1, xd-1,d,x2+1,x-1,x+1),
           list(1,d,xd-2,x+1,x2+1,x-1),
           list(1,xd-1,d,x-1,x2+1,x+1),
           list(1,xd-1,d,x2+1,x+1,x-1));
  expected = list(list(1,d,xd-2,x+1,x-1,x2+1),
           list(1,d,xd-2,x+1,x2+1,x-1),
           list(1,d,xd-2,x-1,x+1,x2+1),
           list(1,d,xd-2,x-1,x2+1,x+1),
           list(1,d,xd-2,x2+1,x+1,x-1),
           list(1,d,xd-2,x2+1,x-1,x+1),
           list(1,x3d+3x2+xd-1,d,x+1,x-1),
           list(1,x3d+3x2+xd-1,d,x-1,x+1),
           list(1,xd-1,d,x+1,x-1,x2+1),
           list(1,xd-1,d,x+1,x2+1,x-1),
           list(1,xd-1,d,x-1,x+1,x2+1),
           list(1,xd-1,d,x-1,x2+1,x+1),
           list(1,xd-1,d,x2+1,x+1,x-1),
           list(1, xd-1,d,x2+1,x-1,x+1));
  obtained = sortFactorizations(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 5 for sortFactorizations failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing sortFactorizations


//////////////////////////////////////////////////
//*******N'TH WEYL ALGEBRA SECTION***************
//////////////////////////////////////////////////

proc homogfacNthWeyl(poly h)
"USAGE: homogfacNthWeyl(h); h is a homogeneous polynomial in the
 nth Weyl algebra with respect to the -1,1-grading
RETURN: list
PURPOSE: Computes a factorization of a homogeneous polynomial h with
  respect to the ZZ-grading on the n-th Weyl algebra.
THEORY: @code{homogfacFirstWeyl} returns a list with a factorization of the given,
 [-1,1]-homogeneous polynomial. For every i in 1..n: If the degree of the polynomial
 in [d_i,x_i] is k with k positive, the last k entries in the output list are the second
 variable. If k is positive, the last k entries will be x_i. The other
 entries will be irreducible polynomials of degree zero or 1 resp. -1. resp. other variables

GENERAL ASSUMPTIONS:
 - The basering is the nth Weyl algebra and has the form, that the first n variables represent
   x1, ..., xn, and the second n variables do represent the d1, ..., dn.
"
{//proc homogfacNthWeyl
  int p = printlevel-voice+2;//for dbprint
  poly hath = h;
  def r = basering;
  int i; int j; int k;
  string dbprintWhitespace = "";
  for (i = 1; i<=voice;i++)
  {dbprintWhitespace = dbprintWhitespace + " ";}
  intvec ivm11 = intvec(-1,1);
  if (!homogwithorderNthWeyl(h))
  {//The given polynomial is not homogeneous
    ERROR("Given polynomial was not [-1,1]-homogeneous");
    return(list());
  }//The given polynomial is not homogeneous
  if (h==0)
  {
    return(list(0));
  }
  list result;
  intvec m = degreeOfNthWeylPoly(h);
  dbprint(p,dbprintWhitespace +" Splitting the polynomial in A_0 and A_k-Part");
  dbprint(p,dbprintWhitespace + "Its [-1,1] degree is "+string(m));
  for (j = 1; j<=nvars(basering) div 2; j++)
  {//extracting the respective variable for every position
    dbprint(p,dbprintWhitespace + "Considering variables x_"+string(j)+" and d" + string(j));
    if (m[j]!=0)
    {//The degree is not zero
      if (m[j] <0)
      {//There are more x than y
        hath = lift(var(j)^(-m[j]),hath)[1,1];
        for (i = 1; i<=-m[j]; i++)
        {
          result = result + list(var(j));
        }
      }//There are more x than y
      else
      {//There are more y than x
        hath = lift(var(nvars(basering) div 2 + j)^m[j],hath)[1,1];
        for (i = 1; i<=m[j];i++)
        {
          result = result + list(var(nvars(basering) div 2 + j));
        }
      }//There are more y than x
    }//The degree is not zero
  }//extracting the respective variable for every position
  dbprint(p,dbprintWhitespace+" Done");
  //beginning to factor the zero-homogeneous part
  list mons;
  dbprint(p,dbprintWhitespace+" Putting the monomials in the A_0-part in a list.");
  for(i = 1; i<=size(hath);i++)
  {//Putting the monomials in a list
    mons = mons+list(hath[i]);
  }//Putting the monomials in a list
  dbprint(p,dbprintWhitespace+" Done");
  dbprint(p,dbprintWhitespace+" Mapping this monomials to K[theta_1, ... , theta_n]");
  ring tempRing = 0,(x(1..(nvars(basering) div 2)),
                     y(1..(nvars(basering) div 2)),
                     theta(1..(nvars(basering) div 2))),dp;
  setring tempRing;
  ideal mapList;
  for (i = 1; i<=nvars(r) ; i++)
  {//filling the list of elements we want to map
    mapList[i] = var(i);
  }//filling the list of elements we want to map
  map thetamap = r,mapList;
  list mons = thetamap(mons);
  poly entry;
  intvec lExp;
  for (i = 1; i<=size(mons);i++)
  {//transforming the monomials as monomials in theta
    entry = leadcoef(mons[i]);
    lExp  = leadexp(mons[i]);
    for (k = 1; k<=nvars(r) div 2; k++)
    {//iterating over the pairs x_kd_k
      for (j = 0; j<lExp[k];j++)
      {
        entry = entry * (theta(k)-j);
      }
    }//iterating over the pairs x_kd_k
    mons[i] = entry;
  }//transforming the monomials as monomials in theta
  dbprint(p,dbprintWhitespace+" Done");
  dbprint(p,dbprintWhitespace+" Factorize the A_0-Part in K[theta]");
  list azeroresult = factorize(sum(mons));
  dbprint(p,dbprintWhitespace+" Successful");
  list azeroresult_return_form;
  for (i = 1; i<=size(azeroresult[1]);i++)
  {//rewrite the result of the commutative factorization
    for (j = 1; j <= azeroresult[2][i];j++)
    {
      azeroresult_return_form = azeroresult_return_form + list(azeroresult[1][i]);
    }
  }//rewrite the result of the commutative factorization
  dbprint(p,dbprintWhitespace+" Mapping back to A_0.");
  setring(r);
  ideal finalMapList;
  for(i = 1; i<=nvars(r);i++)
  {
    finalMapList[i] = var(i);
  }
  for (i = 1; i<=nvars(r) div 2; i++)
  {
    finalMapList[i + nvars(r)] = var(i)*var(i + (nvars(r) div 2));
  }
  map finalmap = tempRing,finalMapList;
  list tempresult = finalmap(azeroresult_return_form);
  dbprint(p,dbprintWhitespace+"Successful.");
  for (k = 1; k<=nvars(r) div 2; k++)
  {
    for (i = 1; i<=size(tempresult);i++)
    {//factorizations of theta resp. theta +1
      if(tempresult[i]==var(k)*var(k + nvars(r) div 2))
      {
        tempresult = insert(tempresult,var(k),i-1);
        i++;
        tempresult[i]=var(k +nvars(r) div 2);
      }
      if(tempresult[i]==var(k + nvars(r) div 2)*var(k))
      {
        tempresult = insert(tempresult,var(k + nvars(r) div 2),i-1);
        i++;
        tempresult[i]=var(k);
      }
    }//factorizations of theta resp. theta +1
  }
  result = tempresult+result;
  return(result);
}//proc homogfacNthWeyl


static proc test_homogfacNthWeyl()
{//testing homogfacNthWeyl
  int result=1;
  ring R = 0,(x,d),dp;
  def r = nc_algebra(1,1);
  setring(r);
  //Test 1: 0
  poly input = 0;
  list expected = list(0);
  list obtained = homogfacNthWeyl(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 1 for homogfacNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: Any other constant
  input = 1/3;
  expected = list(poly(1/3));
  obtained = homogfacNthWeyl(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 2 for homogfacNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: one variable first Weyl
  input = 2*x;
  expected = list(poly(2),x);
  obtained = homogfacNthWeyl(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 3 for homogfacNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: reducible polynomial first Weyl
  input = (x*d-1)*(x*d + 4);
  expected = list(poly(1),x*d-1,x*d+4);
  list expected_alt = list(poly(1),x*d+4,x*d-1);
  obtained = homogfacNthWeyl(input);
  if ((!isListEqual(expected,obtained)) and
      (!isListEqual(expected_alt,obtained)))
  {
    print("Test 4 for homogfacNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("or");
    print(expected_alt);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 5: irreducible polynomial first Weyl
  input = (x*d-1);
  expected = list(poly(1),x*d-1);
  obtained = homogfacNthWeyl(input);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 5 for homogfacNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 6: edge case x*d
  input = (x*d);
  expected = list(poly(1),x,d);
  obtained = homogfacNthWeyl(input);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 6 for homogfacNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 7: edge case x*d+1
  input = (x*d+1);
  expected = list(poly(1),d,x);
  obtained = homogfacNthWeyl(input);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 7 for homogfacNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill R;
  kill r;
  //Test 8: Multivariate irreducible
  ring R = 0,(x(1..4),d(1..4)),lp;
  def r = Weyl();
  setring r;
  poly input = x(1)^2*x(3)^2*d(1)^2*d(3)^2-1;
  list expected = list(poly(1), x(1)^2*x(3)^2*d(1)^2*d(3)^2-1);
  list obtained = homogfacNthWeyl(input);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 8 for homogfacNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 9: Multivariate reducible
  input = (x(1)*d(1)+1)*d(4);
  expected = list(poly(1), d(1),x(1),d(4));
  list expected_alt = list(poly(1), d(1),d(4),x(1));
  list expected_alt2 = list(poly(1), d(4),d(1),x(1));
  obtained = homogfacNthWeyl(input);
  if ((!isListEqual(expected,obtained)) and
      (!isListEqual(expected_alt,obtained)) and
      (!isListEqual(expected,obtained)))
  {
    print("Test 9 for homogfacNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("or");
    print(expected_alt);
    print("or");
    print(expected_alt2);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing homogfacNthWeyl


static proc homogfacNthWeyl_all(poly h)
"USAGE: homogfacNthWeyl_all(h); h is a homogeneous polynomial in the nth Weyl algebra
 with respect to the ZZ-grading on the nth Weyl algebra.
RETURN: list
PURPOSE: Computes all factorizations of a homogeneous polynomial h with respect
  to the ZZ-grading on the nth Weyl algebra
THEORY: @code{homogfacFirstWeyl} returns a list with all factorization of the given,
 homogeneous polynomial. It uses the output of homogfacNthWeyl and permutes
 its entries with respect to the commutation rule. Furthermore, if a
 factor of degree zero is irreducible in K[theta_1, ..., theta_n], but reducible in
 the nth Weyl algebra, the permutations of this element with the other
 entries will also be computed.
SEE ALSO: homogfacFirstWeyl
"{//proc HomogfacNthWeylAll
  int p=printlevel-voice+2;//for dbprint
  intvec iv11= 1:nvars(basering);
  if (deg(h,iv11) <= 0 )
  {//h is a constant
    dbprint(p,"Given polynomial was not homogeneous");
    return(list(list(h)));
  }//h is a constant
  def r = basering;
  list one_hom_fac; //stands for one homogeneous factorization
  int i; int j; int k; int l;
  string dbprintWhitespace = "";
  for (i = 1; i<=voice;i++)
  {dbprintWhitespace = dbprintWhitespace + " ";}
  dbprint(p,dbprintWhitespace +" Calculate one homogeneous factorization using homogfacNthWeyl");
  //Compute again a homogeneous factorization
  one_hom_fac = homogfacNthWeyl(h);
  dbprint(p,dbprintWhitespace +"Successful");
  if (size(one_hom_fac) == 0)
  {//there is no homogeneous factorization or the polynomial was not homogeneous
    return(list());
  }//there is no homogeneous factorization or the polynomial was not homogeneous
  //divide list in A0-Part and a list of x_i's resp. y_i's
  list list_not_azero = list();
  list list_azero;
  list k_factor;
  int is_list_not_azero_empty = 1;
  int is_list_azero_empty = 1;
  k_factor = list(number(one_hom_fac[1]));
  dbprint(p, dbprintWhitespace + "Determine whether there is an A0
part or not.");
  int absValueOfDegree = 0;
  intvec degVecH = degreeOfNthWeylPoly(h);
  intvec lExp;
  for (i = 1; i<=size(degVecH); i++)
  {//adding up the absolute values of the degrees of the respective variables
    absValueOfDegree = absValueOfDegree + absValue(degVecH[i]);
  }//adding up the absolute values of the degrees of the respective variables
  if (absValueOfDegree < size(one_hom_fac) - 1)
  {//There is a nontrivial A0 part
    list_azero = one_hom_fac[2..(size(one_hom_fac)-absValueOfDegree)];
    is_list_azero_empty = 0;
  }//There is a nontrivial A0 part
  dbprint(p,dbprintWhitespace +" Combine x_i,d_i to x_id_i in the
factorization again.");
  dbprint(p,dbprintWhitespace + " The corresponding list of A0
    factors is: " + string(list_azero));
  for (i = 1; i<size(list_azero);i++)
  {//in homogfacFirstWeyl, we factorized the theta_i, and this will be
   //made undone
    for (j = 1; j<=nvars(basering) div 2; j++)
    {//iterating through the variables
      if (list_azero[i] == var(j))
      {
        if (list_azero[i+1]==var(j + nvars(basering) div 2))
        {
          list_azero[i] = var(j)*var(j + nvars(basering) div 2);
          list_azero = delete(list_azero,i+1);
        }
      }
      if (list_azero[i] == var(j + nvars(basering) div 2))
      {
        if (list_azero[i+1]==var(j))
        {
          list_azero[i] = var(j + nvars(basering) div 2)*var(j);
          list_azero = delete(list_azero,i+1);
        }
      }
    }//iterating through the variables
  }//in homogfacFirstWeyl, we factorized theta_i, and this will be
   //made undone
  dbprint(p,dbprintWhitespace +" Done");
  dbprint(p, dbprintWhitespace + "The new list is: " +
          string(list_azero));
  if (degVecH != 0:(nvars(basering) div 2))
  {//list_not_azero is not empty
    list_not_azero = one_hom_fac[(size(one_hom_fac) -
                                  absValueOfDegree +1)..size(one_hom_fac)];
    is_list_not_azero_empty = 0;
  }//list_not_azero is not empty
  dbprint(p,dbprintWhitespace+" Mapping list_azero to K[theta_1, ... , theta_n]");
  ring tempRing = 0,(x(1..(nvars(basering) div 2)),
                     y(1..(nvars(basering) div 2)),
                     theta(1..(nvars(basering) div 2))),dp;
  setring tempRing;
  poly entry;
  ideal mapList;
  for (i = 1; i<=nvars(r) ; i++)
  {//filling the list of elements we want to map
    mapList[i] = var(i);
  }//filling the list of elements we want to map
  map thetamap = r,mapList;
  if(!is_list_not_azero_empty)
  {//Mapping in Singular is only possible, if the list before
    //contained at least one element of the other ring
    list list_not_azero = thetamap(list_not_azero);
  }//Mapping in Singular is only possible, if the list before
  //contained at least one element of the other ring
  if(!is_list_azero_empty)
  {//Mapping in Singular is only possible, if the list before
    //contained at least one element of the other ring
    list list_azero= thetamap(list_azero);
  }//Mapping in Singular is only possible, if the list before
  //contained at least one element of the other ring
  list k_factor = thetamap(k_factor);
  list tempmons;
  dbprint(p,dbprintWhitespace +" Done");
  for(i = 1; i<=size(list_azero);i++)
  {//rewrite the polynomials in A1 as polynomials in K[theta]
    tempmons = list();
    for (j = 1; j<=size(list_azero[i]);j++)
    {
      tempmons = tempmons + list(list_azero[i][j]);
    }
    for (j = 1 ; j<=size(tempmons);j++)
    {
      entry = leadcoef(tempmons[j]);
      lExp  = leadexp(tempmons[j]);
      for (l = 1; l<=nvars(r) div 2; l++)
      {
        for (k = 0; k < lExp[l];k++)
        {
          entry = entry*(theta(l)-k);
        }
      }
      tempmons[j] = entry;
    }
    list_azero[i] = sum(tempmons);
  }//rewrite the polynomials in A1 as polynomials in K[theta]
  //Compute all permutations of the A0-part
  dbprint(p, dbprintWhitespace + "The polynomials rewritten in
K[theta_1, ... , theta_n] look like:");
  dbprint(p,list_azero);
  dbprint(p,dbprintWhitespace +" Compute all permutations of the A_0-part with the first resp.
the snd. variable");
  list result;
  intvec shift = 0:(nvars(r) div 2);
  if (size(list_not_azero)!=0)
  {//Compute all possibilities to permute the x's resp. the y's in the list
    result = permpp(list_azero + list_not_azero);
    for (i = 1; i<= size(result); i++)
    {//adjust the a_0-parts
      shift = 0:(nvars(r) div 2);
      for (j=1; j<=size(result[i]);j++)
      {//iterating through each factor
        if (deg(result[i][j],(1:nvars(r),0:(nvars(r) div 2))) !=0)
        {//the factor is a single variable
          for(k = 1; k<=nvars(r); k++)
          {//Iterating through the variables to find the variable
            if (result[i][j]==var(k))
            {//found it!
              if (k<=nvars(r) div 2)
              {shift[k] = shift[k] + 1;}
              else
              {shift[k -(nvars(r) div 2)] = shift[k -(nvars(r) div
                                                      2)] -1;
              }
              break;
            }//found it!
          }//Iterating through the variables to find the variable
        }//the factor is a single variable
        else
        {//factor was a theta poly
          for (k= 1; k <= nvars(r) div 2;k++)
          {result[i][j] = subst(result[i][j],theta(k),theta(k)
                                + shift[k]);}
        }//factor was a theta poly
      }//iterating through each factor
    }//adjust the a_0-parts
  }//Compute all possibilities to permute the x's resp. the y's in the list
  else
  {//The result is just all the permutations of the a_0-part
    result = permpp(list_azero);
  }//The result is just all the permutations of the a_0 part
  if (size(result)==0)
  {
    return(result);
  }
  dbprint(p,dbprintWhitespace +" Done");
  dbprint(p, dbprintWhitespace + "The factorization list is now:");
  dbprint(p,result);
  dbprint(p, dbprintWhitespace + "Checking whether the
        intermediate result is correct or not");
  dbprint(p,testNCfac(result));
  dbprint(p,dbprintWhitespace +" Searching for theta resp. theta+1 in
  the list and fact. them");
  //Now we are going deeper and search for theta resp. theta + 1, substitute
  //them by xy resp. yx and go on permuting
  int found_theta;
  int thetapos;
  int shift_sign;
  int thetaIndex;
  poly shiftvar;
  list leftpart;
  list rightpart;
  list lparts;
  list rparts;
  list tempadd;
  for (i = 1; i<=size(result) ; i++)
  {//checking every entry of result for theta or theta +1
    found_theta = 0;
    for(j=1;j<=size(result[i]);j++)
    {//iterating through all factors
      for (k = 1; k<=nvars(r) div 2; k++)
      {//iterating through the variables
        if (result[i][j]==theta(k))
        {//the jth entry is theta and can be written as x*y
          thetapos = j;
          thetaIndex = k;
          result[i]= insert(result[i],x(k),j-1);
          j++;
          result[i][j] = y(k);
          found_theta = 1;
          break;
        }//the jth entry is theta and can be written as x*y
        if(result[i][j] == theta(k) +1)
        {
          thetapos = j;
          thetaIndex = k;
          result[i] = insert(result[i],y(k),j-1);
          j++;
          result[i][j] = x(k);
          found_theta = 1;
          break;
        }
      }//iterating through the variables
      if(found_theta)
      {break;}
    }//iterating through all factors
    if (found_theta)
    {//One entry was theta resp. theta +1
      leftpart = result[i];
      leftpart = leftpart[1..thetapos];
      rightpart = result[i];
      rightpart = rightpart[(thetapos+1)..size(rightpart)];
      lparts = list(leftpart);
      rparts = list(rightpart);
      //first deal with the left part
      if (leftpart[thetapos] == x(thetaIndex))
      {
        shift_sign = 1;
        shiftvar = x(thetaIndex);
      }
      else
      {
        shift_sign = -1;
        shiftvar = y(thetaIndex);
      }
      for (j = size(leftpart); j>1;j--)
      {//drip x resp. y
        if (leftpart[j-1]==shiftvar)
        {//commutative
          j--;
          continue;
        }//commutative
        if (leadexp(leftpart[j-1])[thetaIndex + nvars(r) div 2]
            - leadexp(leftpart[j-1])[thetaIndex]!=0)
        {//stop here
          break;
        }//stop here
        //Here, we can only have a a0- part
        leftpart[j] = subst(leftpart[j-1],theta(thetaIndex), theta(thetaIndex) + shift_sign);
        leftpart[j-1] = shiftvar;
        lparts = lparts + list(leftpart);
      }//drip x resp. y
      //and now deal with the right part
      if (rightpart[1] == x(thetaIndex))
      {
        shift_sign = 1;
        shiftvar = x(thetaIndex);
      }
      else
      {
        shift_sign = -1;
        shiftvar = y(thetaIndex);
      }
      for (j = 1 ; j < size(rightpart); j++)
      {
        if (rightpart[j+1] == shiftvar)
        {
          j++;
          continue;
        }
        if (leadexp(rightpart[j+1])[thetaIndex + nvars(r) div 2]
            - leadexp(rightpart[j+1])[thetaIndex]!=0)
        {
          break;
        }
        rightpart[j] = subst(rightpart[j+1], theta(thetaIndex), theta(thetaIndex) - shift_sign);
        rightpart[j+1] = shiftvar;
        rparts = rparts + list(rightpart);
      }
      //And now, we put all possibilities together
      tempadd = list();
      for (j = 1; j<=size(lparts); j++)
      {
        for (k = 1; k<=size(rparts);k++)
        {
          tempadd = tempadd + list(lparts[j]+rparts[k]);
        }
      }
      tempadd = delete(tempadd,1); // The first entry is already in the list
      result = result + tempadd;
      continue; //We can may be not be done already with the ith entry
    }//One entry was theta resp. theta +1
  }//checking every entry of result for theta or theta +1
  dbprint(p,dbprintWhitespace +" Done");
  dbprint(p,dbprintWhitespace + "The new result list is:");
  dbprint(result);
  setring(r);
  ideal finalMapList;
  for(i = 1; i<=nvars(r);i++)
  {
    finalMapList[i] = var(i);
  }
  for (i = 1; i<=nvars(r) div 2; i++)
  {
    finalMapList[i + nvars(r)] = var(i)*var(i + (nvars(r) div 2));
  }
  map finalmap = tempRing,finalMapList;
  list result = finalmap(result);
  for (i=1; i<=size(result);i++)
  {//adding the K factor
    result[i] = k_factor + result[i];
  }//adding the k-factor
  dbprint(p,dbprintWhitespace +" Done");
  dbprint(p,dbprintWhitespace +" Delete double entries in the list.");
  result = delete_duplicates_noteval_and_sort(result);
  dbprint(p,dbprintWhitespace +" Done");
  return(result);
}//proc HomogfacNthWeylAll
/*
  Interesting Test-Polys:
ring R = 0,(x1,x2,x3,d1,d2,d3),dp;
matrix C[6][6] = 1,1,1,1,1,1,
                 1,1,1,1,1,1,
                 1,1,1,1,1,1,
                 1,1,1,1,1,1,
                 1,1,1,1,1,1,
                 1,1,1,1,1,1;
matrix D[6][6] = 0,0,0,1,0,0,
                 0,0,0,0,1,0,
                 0,0,0,0,0,1,
                 -1,0,0,0,0,0,
                 0,-1,0,0,0,0,
                 0,0,-1,0,0,0;
def r = nc_algebra(C,D);
setring(r);
poly h =x1*x2^2*x3^3*d1*d2^2+x2*x3^3*d2;
h = (x1*x2^2*x3 + d1^2*d2*d3^3*x1^3*x2^3*x3^4)*(x1*d1 + x2*d2 + x3*d3);
h = x1^2*d1+x1*x2*d2;
*/


static proc test_homogfacNthWeyl_all()
{//testing homogfacNthWeyl_all
  int result=1;
  ring R = 0,(x,d),dp;
  def r = nc_algebra(1,1);
  setring(r);
  //Test 1: 0
  poly input = 0;
  list expected = list(list(poly(0)));
  list obtained = homogfacNthWeyl_all(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 1 for homogfacNthWeyl_all failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: Any other constant
  input = 1/3;
  expected = list(list(poly(1/3)));
  obtained = homogfacNthWeyl_all(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 2 for homogfacNthWeyl_all failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: one variable first Weyl
  input = 2*x;
  expected = list(list(number(2),x));
  obtained = homogfacNthWeyl_all(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 3 for homogfacNthWeyl_all failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: reducible polynomial first Weyl
  input = (x*d-1)*(x*d + 4);
  expected =
    sortFactorizations(list(list(number(1),x*d-1,x*d+4),
                list(number(1),x*d+4,x*d-1)));
  obtained = homogfacNthWeyl_all(input);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 4 for homogfacNthWeyl_all failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 5: irreducible polynomial first Weyl
  input = (x*d-1);
  expected = list(list(number(1),x*d-1));
  obtained = homogfacNthWeyl_all(input);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 5 for homogfacNthWeyl_all failed.");
    print("Expected:\n");
    print(expected);
    print("or");
    print(expected_alt);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 6: edge case x*d
  input = (x*d);
  expected = list(list(number(1),x,d));
  obtained = homogfacNthWeyl_all(input);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 6 for homogfacNthWeyl_all failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 7: edge case x*d+1
  input = (x*d+1);
  expected = list(list(number(1),d,x));
  obtained = homogfacNthWeyl_all(input);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 7 for homogfacNthWeyl_all failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill R;
  kill r;
  //Test 8: Multivariate irreducible
  ring R = 0,(x(1..4),d(1..4)),lp;
  def r = Weyl();
  setring r;
  poly input = x(1)^2*x(3)^2*d(1)^2*d(3)^2-1;
  list expected = list(list(number(1), x(1)^2*x(3)^2*d(1)^2*d(3)^2-1));
  list obtained = homogfacNthWeyl_all(input);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 8 for homogfacNthWeyl_all failed.");
    print("Expected:\n");
    print(expected);
    print("or");
    print(expected_alt);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 9: Multivariate reducible
  input = (x(1)*d(1)+1)*d(4);
  expected = sortFactorizations(list(list(number(1), d(1),x(1),d(4)),
                     list(number(1), d(1),d(4),x(1)),
                     list(number(1), d(4),d(1),x(1))));
  obtained = homogfacNthWeyl_all(input);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 9 for homogfacNthWeyl_all failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing homogfacNthWeyl_all


proc facWeyl(poly h)
"USAGE: facWeyl(h); h a polynomial in the nth Weyl algebra
RETURN: list
PURPOSE: compute all factorizations of a polynomial in the first Weyl algebra
THEORY: Implements the new algorithm by A. Heinle and V. Levandovskyy, see the thesis of A. Heinle
ASSUME: basering is the nth Weyl algebra, where n in NN.
NOTE: Every entry of the output list is a list with factors for one possible factorization.
The first factor is always a constant (1, if no nontrivial constant could be excluded).
EXAMPLE: example facFirstWeyl; shows examples
SEE ALSO: facSubWeyl, testNCfac, facFirstShift, facFirstWeyl
"{//proc facWeyl
  //Definition of printlevel variable
  int p = printlevel-voice+2;
  int i;
  string dbprintWhitespace = "";
  for (i = 1; i<=voice;i++)
  {dbprintWhitespace = dbprintWhitespace + " ";}
  dbprint(p,dbprintWhitespace +" Checking if the given algebra is a Weyl algebra");
  //Redefine the ring in my standard form
  if (!ncfactor_isWeyl())
  {//Our basering is not the Weyl algebra
    ERROR("Ring was not a Weyl algebra");
    return(list());
  }//Our basering is not the Weyl algebra
  dbprint(p,dbprintWhitespace +" Successful");

  //A last check before we start the real business: Is h maybe just
  //dependable on commutative variables?
  if (isInCommutativeSubRing(h))
  {//h is in a commutative subring
    return(factor_commutative(h));
  }//h is in a commutative subring
  dbprint(p,dbprintWhitespace +" Successful");
  list result = list();
  int j; int k; int l; //counter
  if (!checkIfProperNthWeyl())
  {//The given ring was not a proper nth Weyl algebra
    dbprint(p,dbprintWhitespace +" positions of the variables have to be switched");
    dbprint(p,dbprintWhitespace + "Constructing the the proper ring.");
    def r = basering;
    list tempRingList = ringlist(r);
    tempRingList = delete(tempRingList,6);

    list the_vars;
    for (i = 1; i<=nvars(r); i++)
    {the_vars[i] = var(i);}
    poly tempVariable;
    for (i = 1; i<=size(the_vars) div 2; i++)
    {//Swapping the variables as needed
      if (the_vars[i + size(the_vars) div 2]*the_vars[i]
          -the_vars[i]*the_vars[i + size(the_vars) div 2] == 1)
      {
        i++; continue;
      }
      //If we enter this line, there is a break with our property
      //condition
      for (j = i+1; j<=size(the_vars); j++)
      {
        if (the_vars[j]*the_vars[i]-the_vars[i]*the_vars[j]==1)
        {//In this case, we matched a var x to a respective d
          tempVariable = the_vars[i + size(the_vars) div 2];
          the_vars[i + size(the_vars) div 2] = the_vars[j];
          the_vars[j] = tempVariable;
          break;
        }//In this case, we matched a var x to a respective d
        if (the_vars[i]*the_vars[j]-the_vars[j]*the_vars[i]==1)
        {//In this case, x and d were wrongly positioned
          tempVariable = the_vars[j];
          the_vars[j] = the_vars[i];
          the_vars[i] = tempVariable;
          i = i-1;
          break;
        }//In this case, x and d were wrongly positioned
      }
    }//Swapping the variables as needed
    for (i = 1; i<=size(the_vars); i++)
    {tempRingList[2][i] = string(the_vars[i]);}
    matrix DTemp[nvars(r)][nvars(r)];
    for (i = 1; i<=ncols(DTemp) div 2; i++)
    {
      DTemp[i,i + nvars(r) div 2] = 1;
    }
    tempRingList = tempRingList + list(DTemp);
    def tempRing = ring(tempRingList);
    dbprint(p,dbprintWhitespace + "Done. The altered ring is the following:");
    dbprint(p,tempRing);
    setring(tempRing);
    poly h = imap(r,h);
    dbprint(p,dbprintWhitespace +" Successful");
    list resulttemp = facWeyl(h);
    setring(r);
    result = imap(tempRing,resulttemp);
    return (result);
  }//The given ring was not a proper nth Weyl algebra

  dbprint(p, dbprintWhitespace +" factorization of the polynomial with the routine sfacwaNthWeyl");
  result = sfacwaNthWeyl(h);
  dbprint(p,dbprintWhitespace +" Done");
  if (homogwithorderNthWeyl(h))
  {
    dbprint(p, dbprintWhitespace + " Polynomial was homogeneous, therefore we have
already a complete factorization and do not have to go through the factors recursively.");
    return(result);
  }
  result = normalizeFactors(result);
  result = delete_duplicates_noteval_and_sort(result);
  dbprint(p,dbprintWhitespace + "We have the following intermediate list of inhomogeneous
factorizations:");
  dbprint(p,result);
  dbprint(p,dbprintWhitespace +" recursively check factors for irreducibility");
  list recursivetemp;
  int changedSomething;
  for(i = 1; i<=size(result);i++)
  {//recursively factorize factors
    if(size(result[i])>2)
    {//Nontrivial factorization
      for (j=2;j<=size(result[i]);j++)
      {//Factorize every factor
        recursivetemp = facWeyl(result[i][j]);
        //if(size(recursivetemp)>1)
        //{//we have a nontrivial factorization
        changedSomething = 0;
        for(k=1; k<=size(recursivetemp);k++)
        {//insert factorized factors
          if(size(recursivetemp[k])>2)
          {//nontrivial
            changedSomething = 1;
            result = insert(result,result[i],i);
            for(l = size(recursivetemp[k]);l>=2;l--)
            {
              result[i+1] = insert(result[i+1],recursivetemp[k][l],j);
            }
            result[i+1] = delete(result[i+1],j);
          }//nontrivial
        }//insert factorized factors
        if (changedSomething)
        {
          result = delete(result,i);
        }
        //}//we have a nontrivial factorization
      }//Factorize every factor
    }//Nontrivial factorization
  }//recursively factorize factors
  dbprint(p,dbprintWhitespace +" Done");
  if (size(result)==0)
  {//only the trivial factorization could be found
    result = list(list(1,h));
  }//only the trivial factorization could be found
  list resultWithInterchanges;
  result = delete_duplicates_noteval_and_sort(result);
  dbprint(p,dbprintWhitespace+ "And the result without interchanges with homogeneous factors is:");
  dbprint(p,result);
  for (i = 1; i <= size(result) ; i++)
  {//applying the interchanges to result
    resultWithInterchanges = resultWithInterchanges +
                             checkForHomogInhomogInterchangabilityNthWeyl(result[i],
                                                                          2,
                                                                          size(result[i]));
  }//applying the interchanges to result
  dbprint(p,dbprintWhitespace + "With interchanges, the result is:");
  dbprint(p,resultWithInterchanges);
  //now, refine the possible redundant list
  return( delete_duplicates_noteval_and_sort(resultWithInterchanges) );
}//proc facWeyl
example
{
  "EXAMPLE:";echo=2;
  ring R = 0,(x1,x2,d1,d2),dp;
  matrix C[4][4] = 1,1,1,1,
                  1,1,1,1,
                  1,1,1,1,
                  1,1,1,1;
  matrix D[4][4] = 0,0,1,0,
                  0,0,0,1,
                  -1,0,0,0,
                  0,-1,0,0;
  def r = nc_algebra(C,D);
  setring(r);
  poly h = (d1+1)^2*(d1 + x1*d2);
  facWeyl(h);
}


static proc test_facWeyl()
{//testing facWeyl
  int result = 1;
  ring R = 0,(x,d),dp;
  def r = nc_algebra(1,1);
  setring(r);
  //Test 1: 0
  poly input = 0;
  list expected = list(list(poly(0)));
  list obtained = facWeyl(input);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 1 for facWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: Random, non-zero constant
  input = 50/13;
  expected = list(list(poly(50/13)));
  obtained = facWeyl(input);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 2 for facWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill R;
  kill r;
  //Test 3: Homogeneous polynomial that is large to see if its
  //redirected to homogfac_Weyl
  ring R = 0,(x(1..4),d(1..4)),dp;
  def r = Weyl();
  setring r;
  poly input = (x(1)*d(1) + x(2)*d(2))^15;
  list expected = list(list(number(1),x(1)*d(1) + x(2)*d(2),
                x(1)*d(1) + x(2)*d(2),
                x(1)*d(1) + x(2)*d(2),
                x(1)*d(1) + x(2)*d(2),
                x(1)*d(1) + x(2)*d(2),
                x(1)*d(1) + x(2)*d(2),
                x(1)*d(1) + x(2)*d(2),
                x(1)*d(1) + x(2)*d(2),
                x(1)*d(1) + x(2)*d(2),
                x(1)*d(1) + x(2)*d(2),
                x(1)*d(1) + x(2)*d(2),
                x(1)*d(1) + x(2)*d(2),
                x(1)*d(1) + x(2)*d(2),
                x(1)*d(1) + x(2)*d(2),
                x(1)*d(1) + x(2)*d(2)));
  list obtained = facWeyl(input);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 3 for facWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: Random polynomial with non-trivial content
  input = 5*(x(1)*d(2) + d(4))*(x(4)+d(4)*d(2));
  expected = list(list(number(5),(x(1)*d(2) + d(4)),
               (x(4)+d(4)*d(2))));
  obtained = facWeyl(input);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 4 for facWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  input = (x(1)^2 +x(1)*d(1)+2)*(x(1)+d(1));
  expected = list(list(number(1), x(1)+d(1), x(1)+d(1), x(1)),
                  list(number(1), x(1)^2+x(1)*d(1)+2, x(1)+d(1)));
  obtained = facWeyl(input);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 5 for facWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing facWeyl


proc facFirstWeyl(poly h)
"USAGE: facFirstWeyl(h); h a polynomial in the first Weyl algebra
RETURN: list
PURPOSE: compute all factorizations of a polynomial in the first Weyl algebra
THEORY: This function is a wrapper for facWeyl. It exists to make this library downward-compatible
        with older versions.
ASSUME: basering is the first Weyl algebra
NOTE: Every entry of the output list is a list with factors for one possible factorization.
The first factor is always a constant (1, if no nontrivial constant could be excluded).
EXAMPLE: example facFirstWeyl; shows examples
SEE ALSO: facSubWeyl, testNCfac, facShift"
{//facFirstWeyl
  return(facWeyl(h));
}//facFirstWeyl
example
{
  "EXAMPLE:";echo=2;
  ring R = 0,(x,y),dp;
  def r = nc_algebra(1,1);
  setring(r);
  poly h = (x^2*y^2+x)*(x+1);
  facFirstWeyl(h);
}


//NO TEST NECESSARY, SINCE INSTANT REDIRECTION TO FACWEYL


static proc checkForHomogInhomogInterchangabilityNthWeyl(list factors, posLeft, posRight)
"
INPUT:  A list consisting of factors of a certain polynomial in the nth Weyl
        algebra, factors, and a position from the left and the right, where the last swap was done.
OUTPUT: A list containing lists consisting of factors of a certain polynomial in the nth Weyl
        algebra.
The purpose of this function is to check whether we can interchange certain inhomogeneous factors
with homogeneous ones. If it is possible, this function returns a list of lists
of possible interchanges.

The idea came because of an example, where we need an extra swap in the end, otherwise we would
not capture all factorizations. The example was
h = x4d7+11x3d6+x2d7+x2d6+x3d4+29x2d5+xd6+8xd5+d6+5x2d3+14xd4+13d4+5xd2+d3+d;

ASSUMPTIONS:

- All factors are irreducible
- Our basering is the Nth Weyl algebra; the xs are the first n variables,
  the differential operators are the last n.
- No entry in the list factors is 0.
"
{//checkForHomogInhomogInterchangabilityNthWeyl
  int p = printlevel-voice+2;
  string dbprintWhitespace = "";
  int i; int j; int k; int l;
  for (i = 1; i<=voice;i++)
  {dbprintWhitespace = dbprintWhitespace + " ";}
  if (size(factors) <= 2 || posLeft >= posRight - 1)
  {//easiest case: There is nothing to swap
    return (list(factors));
  }//easiest case: There is nothing to swap
  list result = list(factors);
  poly tempElem;
  int tempLeftBorder;
  int tempRightBorder;
  list tempElemExtracted;
  list tempNewResultEntry;
  for (i=posLeft; i<=posRight; i++)
  {//searching for inhomogeneous elements and filling result with them
    if(!homogwithorderNthWeyl(factors[i]))
    {//found inhomogeneous element
      tempElem = factors[i];
      tempLeftBorder = i;
      tempRightBorder = i;
      for (j=i+1; j<=posRight; j++)
      {//multiplying homogeneous elements from the right
        if(!homogwithorderNthWeyl(factors[j]))
        {break;}
        tempElem = tempElem*factors[j];
        tempRightBorder = j;
      }//multiplying homogeneous elements from the right
      for (j=i-1; j>=posLeft; j--)
      {//multiplying homogeneous elements from the left
    if(!homogwithorderNthWeyl(factors[j]))
    {break;}
    tempElem = factors[j]*tempElem;
    tempLeftBorder = j;
      }//multiplying homogeneous elements from the left
      if (tempLeftBorder == tempRightBorder)
      {
    i++; continue;
      }
      tempElemExtracted = extractHomogeneousDivisorsNthWeyl(tempElem);
      for (j = 1; j<=size(tempElemExtracted);j++)
      {
    tempNewResultEntry = list();
    for (k=1;k<tempLeftBorder;k++)
    {
      tempNewResultEntry = insert(tempNewResultEntry, factors[k],k-1);
    }
    for (k=1; k<=size(tempElemExtracted[j]);k++)
    {
      tempNewResultEntry = insert(tempNewResultEntry,
                  tempElemExtracted[j][k],
                  size(tempNewResultEntry));
    }
    for (k=tempRightBorder + 1;k<=size(factors);k++)
    {
      tempNewResultEntry = insert(tempNewResultEntry, factors[k],size(tempNewResultEntry));
    }
    result = insert(result, tempNewResultEntry);
      }
      result = delete_duplicates_noteval_and_sort(result);
    }//found inhomogeneous element
  }//searching for inhomogeneous elements and filling result with them
  result = delete_duplicates_noteval_and_sort(result);
  return(result);
}//checkForHomogInhomogInterchangabilityNthWeyl


static proc test_checkForHomogInhomogInterchangabilityNthWeyl()
{//testing checkForHomogInhomogInterchangabilityNthWeyl
  int result = 1;
  //Test 1: empty list, left and right is 0
  list input = list();
  int input2 = 0;
  int input3 = 0;
  list expected = list(list());
  list obtained =
    checkForHomogInhomogInterchangabilityNthWeyl(input,input2,input3);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 1 for checkForHomogInhomogInterchangabilityNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: only one element
  ring R = 0,(x(1..4),d(1..4)),dp;
  def r = Weyl();
  setring(r);
  input = list(x(1)*d(2)*x(2)^2+x(4)^3*d(4) + 1);
  input2 = 1;
  input3 = 1;
  expected = list(list(x(1)*d(2)*x(2)^2+x(4)^3*d(4) + 1));
  obtained =
    checkForHomogInhomogInterchangabilityNthWeyl(input,input2,input3);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 2 for checkForHomogInhomogInterchangabilityNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: Two elements trivial case
  input = list(x(1)*d(2)*x(2)^2+x(4)^3*d(4) + 1,d(1));
  input2 = 1;
  input3 = 2;
  expected = list(list(x(1)*d(2)*x(2)^2+x(4)^3*d(4) + 1,d(1)));
  obtained =
    checkForHomogInhomogInterchangabilityNthWeyl(input,input2,input3);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 3 for checkForHomogInhomogInterchangabilityNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: more than two elements, not interchangeable
  input = list(x(1)^2*d(2)*x(2)^2+x(4)^3*d(4) + 1,d(1),d(1));
  input2 = 1;
  input3 = 3;
  expected = list(list(x(1)^2*d(2)*x(2)^2+x(4)^3*d(4) + 1,d(1),d(1)));
  obtained =
    checkForHomogInhomogInterchangabilityNthWeyl(input,input2,input3);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 4 for checkForHomogInhomogInterchangabilityNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 5: More than two elements, interchangeable from right
  input = list(x(1)*d(2)*x(2)^2+x(4)^3*d(4) + 1,d(1),d(1));
  input2 = 1;
  input3 = 3;
  expected = list(list(d(1),
               x(1)*x(2)^2*d(1)*d(2)+x(4)^3*d(1)*d(4)+2*x(1)*x(2)*d(1)
               -x(2)^2*d(2)-2*x(2)+d(1)),
          list(x(1)*d(2)*x(2)^2+x(4)^3*d(4) + 1,d(1),d(1)));
  obtained =
    checkForHomogInhomogInterchangabilityNthWeyl(input,input2,input3);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 5 for checkForHomogInhomogInterchangabilityNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 6: More than two elements, interchangeable from left
  input = list(d(1),d(1),x(1)*d(2)*x(2)^2+x(4)^3*d(4) + 1);
  input2 = 1;
  input3 = 3;
  expected = list(list(d(1),d(1),x(1)*d(2)*x(2)^2+x(4)^3*d(4) + 1),
          list(x(1)*x(2)^2*d(1)*d(2)+x(4)^3*d(1)*d(4)
               +2*x(1)*x(2)*d(1)+2*x(2)^2*d(2)+4*x(2)+d(1),d(1)));
  obtained =
    checkForHomogInhomogInterchangabilityNthWeyl(input,input2,input3);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 6 for checkForHomogInhomogInterchangabilityNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill r; kill R;
  //Test 7: From bug; irreducible with homog from left and right
  ring R = 0,(z,x),dp;
  def r = Weyl();
  setring(r);
  list input = list(1,x,x,z^2*x+1);
  input2 = 2;
  input3 = 4;
  list expected = sortFactorizations(
    list(list(1,x,x,z^2*x+1),
     list(1,x,z2x+2z+1,x))
    );
  list obtained = checkForHomogInhomogInterchangabilityNthWeyl(input,input2,input3);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 7 for checkForHomogInhomogInterchangabilityNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill r; kill R;
  //Test 8: From bug; irreducible with homog from left and right
  ring R = 0,(x(1..2),d(1..2)),dp;
  def r = Weyl();
  setring(r);
  list input =
    list(1,x(1)*x(2)*d(2)+1,x(2)^2*d(2)+x(2)+d(1),d(1),d(2));
  input2 = 2;
  input3 = 5;
  list expected =sortFactorizations(
    list(
      list(1,x(1)*x(2)*d(2)+1,d(1),x(2)^2*d(2)+x(2)+d(1),d(2)),
      list(1,x(1)*x(2)*d(2)+1,x(2)^2*d(2)+x(2)+d(1),d(1),d(2)),
      list(1,x(1)*x(2)*d(2)+1,x(2)^2*d(2)+x(2)+d(1),d(2),d(1))
      ));
  list obtained = checkForHomogInhomogInterchangabilityNthWeyl(input,input2,input3);
  if ((!isListEqual(expected,obtained)) or !testNCfac(obtained))
  {
    print("Test 8 for checkForHomogInhomogInterchangabilityNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing checkForHomogInhomogInterchangabilityNthWeyl


static proc sfacwaNthWeyl(poly h)
"INPUT: A polynomial h in the Nth Weyl algebra
OUTPUT: A list of factorizations, where the factors might still be reducible.
ASSUMPTIONS:
- Our basering is the Nth Weyl algebra; the xs are the first n variables,
  the differential operators are the last n.
"
{//proc sfacwaNthWeyl
  int i; int j; int k;
  int p = printlevel-voice+2;
  string dbprintWhitespace = "";
  number commonCoefficient = content(h);
  for (i = 1; i<=voice;i++)
  {dbprintWhitespace = dbprintWhitespace + " ";}
  dbprint(p,dbprintWhitespace + " Extracting homogeneous left and right factors");
  if(homogwithorderNthWeyl(h))
  {//we are already dealing with a -1,1 homogeneous poly
    dbprint(p,dbprintWhitespace+" Given polynomial is -1,1 homogeneous. Start homog.
fac. and ret. its result");
    return(homogfacNthWeyl_all(h));
  }//we are already dealing with a -1,1 homogeneous poly
  /* return(ncfactor_without_opt(h)); //temp fix for now; soon, a more */
  /*                                  //major refactor follows */
  list extractedHomogeneousFacs =
    extractHomogeneousDivisorsNthWeyl(h/commonCoefficient);
  //resulttemp = resulttemp + list(list(h/commonCoefficient));
  list extractedInhomogeneousFacts =
    sfacwa2NthWeyl(h/commonCoefficient);
  for (j = 1; j<=size(extractedInhomogeneousFacts);j++)
  {//Deleting the leading coefficient since we don't need him
    if (deg(extractedInhomogeneousFacts[j][1],intvec(1:nvars(basering)))==0)
    {
      extractedInhomogeneousFacts[j] = delete(extractedInhomogeneousFacts[j],1);
    }
  }//Deleting the leading coefficient since we don't need him
  list result = list();
  if (size(extractedHomogeneousFacs[1]) > 1)
  {//non-trivial factorization with homogeneous factors encountered
    result = result + extractedHomogeneousFacs;
  }//non-trivial factorization with homogeneous factors encountered
  if (size(extractedInhomogeneousFacts[1]) > 1)
  {//non-trivial factorization with inhomogeneous factors found
    result = result + extractedInhomogeneousFacts;
  }//non-trivial factorization with inhomogeneous factors found
  dbprint(p,dbprintWhitespace +" Done");
  result = delete_duplicates_noteval_and_sort(result);
  for (i = 1; i<=size(result);i++)
  {//Putting the content everywhere
    result[i] = insert(result[i],commonCoefficient);
  }//Putting the content everywhere
  return(result);
}//proc sfacwaNthWeyl


static proc test_sfacwaNthWeyl()
{//testing sfacwaNthWeyl
  int result = 1;
  //Test 1: 0
  ring R = 0,(x(1..4),d(1..4)),dp;
  def r = Weyl();
  setring r;
  poly input = 0;
  list expected = list(list(poly(0)));
  list obtained = sfacwaNthWeyl(input);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 1 for sfacwaNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: any random constant
  input = 9/4;
  expected = list(list(poly(9/4)));
  obtained = sfacwaNthWeyl(input);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 2 for sfacwaNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: homogeneous polynomial with non-trivial content
  input = 4/3*d(1)*x(1);
  expected = list(list(number(4/3),d(1),x(1)));
  obtained = sfacwaNthWeyl(input);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 3 for sfacwaNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: inhomogeneous polynomial with non-trivial content
  input = 4/3*(d(1)*x(1)+d(2))*(d(4) + 3*x(1));
  expected = list(list(number(4/3),(d(1)*x(1)+d(2)),
               (d(4) + 3*x(1))));
  obtained = sfacwaNthWeyl(input);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 4 for sfacwaNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing sfacwaNthWeyl


static proc sfacwa2NthWeyl(poly h)
"
Subprocedure of sfacwa
Assumptions:
- h is not part of a commutative subalgebra of the nth Weyl algebra
- The coefficients are integer values and the gcd of the coefficients
is 1
- the basering is the n-th Weyl algebra, where the x's are the first n
variables, and the d's are the last n variables.
"
{//proc sfacwa2NthWeyl
  int p=printlevel-voice+2; // for dbprint
  int i;
  string dbprintWhitespace = "";
  for (i = 1; i<=voice;i++)
  {dbprintWhitespace = dbprintWhitespace + " ";}
  poly p_max; poly p_min; poly q_max; poly q_min;
  ideal invoIdeal;
  intvec maxDegrees;
  intvec tempIntVec1;
  for (i = 1; i <= nvars(basering); i++)
  {//filling maxDegrees
    tempIntVec1 = 0:nvars(basering);
    tempIntVec1[i] = 1;
    maxDegrees[i] = deg(h,tempIntVec1);
  }//filling maxDegrees
  for (i = 1; i <= nvars(basering); i++)
  {//Filling the mapping rules for the involution map
    if (i <= nvars(basering) div 2)
    {invoIdeal[i] = -var(i);}
    else
    {invoIdeal[i] = var(i);}
  }//Filling the mapping rules for the involution map
  map invo = basering,invoIdeal;
  list calculatedRightFactors;
  if(homogwithorderNthWeyl(h))
  {//Unnecessary how we are using it, but if one wants to use it on its own, we are stating it here
    dbprint(p,dbprintWhitespace+" Given polynomial is -1,1 homogeneous.
Start homog. fac. and ret. its result");
    return(homogfacNthWeyl_all(h));
  }//Unnecessary how we are using it, but if one wants to use it on its own, we are stating it here
  list result = list();
  int j; int k; int l;
  list tempBetweenDegreesP;
  list tempBetweenDegreesQ;
  dbprint(p,dbprintWhitespace+" Computing the degree-limits of the factorization");
  //end finding the limits
  dbprint(p,dbprintWhitespace+" Computing the maximal and the minimal
homogeneous part of the given polynomial");
  list M = computeCombinationsMinMaxHomogNthWeyl(h);
  dbprint(p,dbprintWhitespace+" Done.");
  dbprint(p,dbprintWhitespace+" Filtering invalid combinations in M.");
  for (i = 1 ; i<= size(M); i++)
  {//filter valid combinations
    if (product(M[i]) == h)
    {//We have one factorization
      result = result + divides(M[i][1],h,invo,1);
      dbprint(p,dbprintWhitespace+"Result list updated:");
      dbprint(p,dbprintWhitespace+string(result));
      M = delete(M,i);
      continue;
    }//We have one factorization
  }//filter valid combinations
  dbprint(p,dbprintWhitespace+"Done.");
  dbprint(p,dbprintWhitespace+"The size of M is "+string(size(M)));
  for (i = 1; i<=size(M); i++)
  {//Iterate over all first combinations (p_max + p_min)(q_max + q_min)
    dbprint(p,dbprintWhitespace+" Combination No. "+string(i)+" in M:" );
    p_max = homogDistributionNthWeyl(M[i][1])[2][2];
    p_min = homogDistributionNthWeyl(M[i][1])[1][2];
    q_max = homogDistributionNthWeyl(M[i][2])[2][2];
    q_min = homogDistributionNthWeyl(M[i][2])[1][2];
    dbprint(p,dbprintWhitespace+" pmax = "+string(p_max));
    dbprint(p,dbprintWhitespace+" pmin = "+string(p_min));
    dbprint(p,dbprintWhitespace+" qmax = "+string(q_max));
    dbprint(p,dbprintWhitespace+" qmin = "+string(q_min));
    //Check, whether p_max + p_min or q_max and q_min are already left or right divisors.
    if (divides(p_min + p_max,h,invo))
    {
      dbprint(p,dbprintWhitespace+" Got one result.");
      result = result + divides(p_min + p_max,h,invo,1);
    }
    else
    {
      if (divides(q_min + q_max,h,invo))
      {
        dbprint(p,dbprintWhitespace+" Got one result.");
        result = result + divides(q_min + q_max, h , invo, 1);
      }
    }
    //Now the check, if deg(p_max) = deg(p_min)+1 (and the same with q_max and q_min)

    tempBetweenDegreesP = possibleHomogPartsInBetween(degreeOfNthWeylPoly(p_max),
                                                      degreeOfNthWeylPoly(p_min), maxDegrees);
    tempBetweenDegreesQ = possibleHomogPartsInBetween(degreeOfNthWeylPoly(q_max),
                                                      degreeOfNthWeylPoly(q_min), maxDegrees);
    if (size(tempBetweenDegreesQ)==2 or  size(tempBetweenDegreesP)==2 )
    {//Therefore, p_max + p_min must be a left factor or we can dismiss the combination
      dbprint(p,dbprintWhitespace+" There are no homogeneous parts we can put between
pmax and pmin resp. qmax and qmin.");
      M = delete(M,i);
      continue;
    }//Therefore, p_max + p_min must be a left factor or we can dismiss the combination

    //Done with the Check

    //If we come here, there are still homogeneous parts to be added to p_max + p_min
    //AND to q_max and q_min in
    //order to obtain a real factor
    //We use the procedure determineRestOfHomogParts to find our q.
    dbprint(p,dbprintWhitespace+" Solving for the other homogeneous parts in q");
    calculatedRightFactors = determineRestOfHomogPartsNthWeyl(p_max,p_min,q_max,q_min,h);
    dbprint(p,dbprintWhitespace+" Done with it. Found "+string(size(calculatedRightFactors))
            +" solutions.");
    for (j = 1; j<=size(calculatedRightFactors);j++)
    {//Check out whether we really have right factors of h in calculatedRightFactors
      if (divides(calculatedRightFactors[j],h,invo))
      {
        result = result + divides(calculatedRightFactors[j],h,invo,1);
      }
      else
      {
        dbprint(p,"Solution for max and min homog found, but not a divisor of h");
      }
    }//Check out whether we really have right factors of h in calculatedRightFactors
  }//Iterate over all first combinations (p_max + p_min)(q_max + q_min)

  result = delete_duplicates_noteval_and_sort(result);
  if (size(result) == 0)
  {//no factorization found
    result = list(list(number(1),h));
  }//no factorization found
  return(result);
}//proc sfacwa2NthWeyl


static proc test_sfacwa2NthWeyl()
{//testing sfacwa2NthWeyl
  int result = 1;
  //Test 1: irreducible
  ring R = 0,(x(1..4),d(1..4)),dp;
  def r = Weyl();
  setring r;
  poly input = x(1)+x(2)*d(2);
  list expected = list(list(number(1),x(1)+x(2)*d(2)));
  list obtained = sfacwa2NthWeyl(input);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 1 for sfacwa2NthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: inhomogeneous polynomial that is reducible
  input = (d(1)*x(1)+d(2))*(d(4) + 3*x(1));
  expected = list(list(number(1),(d(1)*x(1)+d(2)),
               (d(4) + 3*x(1))));
  obtained = sfacwa2NthWeyl(input);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 2 for sfacwa2NthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing sfacwa2NthWeyl


static proc determineRestOfHomogPartsNthWeyl(poly pmax, poly pmin, poly qmax, poly qmin, poly h)
"INPUT: Polynomials p_max, p_min, q_max, q_min and h. The maximum homogeneous part h_max of h is
 given by p_max*pmin, the minimum homogeneous part h_min of h is given by p_min*q_min.
OUTPUT: A list of right factors q of h that have q_max and q_min as their maximum respectively
 minimum homogeneous part. Empty list, if those elements are not existent
ASSUMPTIONS:
 - deg(p_max) >_lex deg(p_min) +1
 - deg(q_max) >_lex deg(q_min) +1
 - p_max*q_max = h_max
 - p_min*q_min = h_min
 - The basering is the nth Weyl algebra and has the form, that the first n variables represent
   x1, ..., xn, and the second n variables do represent the d1, ...,
   dn.
 - h does not lie in a commutative subring of the nth Weyl algebra
"
{//proc determineRestOfHomogPartsNthWeyl
  int p=printlevel-voice+2; // for dbprint
  string dbprintWhitespace = "";
  int i;  int j; int k; int l;
  for (i = 1; i<=voice;i++)
  {dbprintWhitespace = dbprintWhitespace + " ";}
  intvec kappa = 0:(nvars(basering) div 2);
  intvec maxDegrees;
  intvec tempIntVec1;
  intvec tempIntVec2;
  for (i = 1; i <= nvars(basering) div 2; i++)
  {//filling kappa
    tempIntVec1 = 0:nvars(basering);
    tempIntVec2 = 0:nvars(basering);
    tempIntVec1[i] = 1;
    tempIntVec2[i + nvars(basering) div 2] = 1;
    kappa[i] = Min(intvec(deg(h,tempIntVec1), deg(h,tempIntVec2)));
  }//filling kappa
  dbprint(p, dbprintWhitespace + "The Kappas for the respective variables are:");
  dbprint(p,kappa);
  for (i = 1; i <= nvars(basering); i++)
  {//filling maxDegrees
    tempIntVec1 = 0:nvars(basering);
    tempIntVec1[i] = 1;
    maxDegrees[i] = deg(h,tempIntVec1);
  }//filling maxDegrees
  def R = basering;
  intvec n1 = degreeOfNthWeylPoly(pmax);
  intvec nk = degreeOfNthWeylPoly(pmin);
  list pBetweenDegrees = possibleHomogPartsInBetween(degreeOfNthWeylPoly(pmax),
                                                     degreeOfNthWeylPoly(pmin),
                                                     maxDegrees);
  int numberHomogPartsP = size(pBetweenDegrees);
  dbprint(p,dbprintWhitespace + "Possible degrees between pmax and pmin:");
  dbprint(p,pBetweenDegrees);
  intvec m1 = degreeOfNthWeylPoly(qmax);
  intvec ml = degreeOfNthWeylPoly(qmin);
  list qBetweenDegrees = possibleHomogPartsInBetween(degreeOfNthWeylPoly(qmax),
                                                     degreeOfNthWeylPoly(qmin),
                                                     maxDegrees);
  int numberHomogPartsQ = size(qBetweenDegrees);
  dbprint(p,dbprintWhitespace + "Possible degrees between qmax and qmin:");
  dbprint(p,qBetweenDegrees);
  ideal mons;

  list hBetweenDegrees = produceHomogListForProduct(pBetweenDegrees,qBetweenDegrees);
  int numberOfHomogPartsH = size(hBetweenDegrees);
  dbprint(p,dbprintWhitespace + "Possible degrees between hmax and hmin:");
  dbprint(p,hBetweenDegrees);

  dbprint(p,dbprintWhitespace+" Extracting zero homog. parts of pmax, qmax, pmin, qmin and h.");
  //Extracting the zero homogeneous part of the given polynomials
  ideal pandqZero = pmax,pmin,qmax,qmin;
  for (i = 1; i<=nvars(basering) div 2; i++)
  {//Extracting zero homogeneous part variable for variable
    if (n1[i] > 0){pandqZero[1] = lift(var(i + nvars(basering) div 2)^n1[i],pandqZero[1])[1,1];}
    else{if (n1[i] < 0){pandqZero[1] = lift(var(i)^(-n1[i]),pandqZero[1])[1,1];}
      /* else{pandqZero[1] = pmax;} */}
    if (nk[i] > 0){pandqZero[2] = lift(var(i + nvars(basering) div 2)^nk[i],pandqZero[2])[1,1];}
    else{if (nk[i] < 0){pandqZero[2] = lift(var(i)^(-nk[i]),pandqZero[2])[1,1];}
      /* else{pandqZero[2] = pmin;} */}
    if (m1[i] > 0){pandqZero[3] = lift(var(i + nvars(basering) div 2)^m1[i],pandqZero[3])[1,1];}
    else{if (m1[i] < 0){pandqZero[3] = lift(var(i)^(-m1[i]),pandqZero[3])[1,1];}
      /* else{pandqZero[3] = qmax;} */}
    if (ml[i] > 0){pandqZero[4] = lift(var(i + nvars(basering) div 2)^ml[i],pandqZero[4])[1,1];}
    else{if (ml < 0){pandqZero[4] = lift(var(i)^(-ml[i]),pandqZero[4])[1,1];}
      /* else{pandqZero[4] = qmin;} */}
  }//Extracting zero homogeneous part variable for variable
  list hZeroinR = homogDistributionNthWeyl(h);
  for (i = 1; i<=size(hZeroinR);i++)
  {//Extracting the zero homogeneous parts of the homogeneous summands of h
    for (j = 1; j<=size(hZeroinR[i][1]); j++)
    {//Iterating through the different variables
      if (hZeroinR[i][1][j] > 0)
      {
        hZeroinR[i][2] =
          lift(var(j + nvars(basering) div 2)^hZeroinR[i][1][j],hZeroinR[i][2])[1,1];
      }
      if (hZeroinR[i][1][j] < 0)
      {
        hZeroinR[i][2] = lift(var(j)^(-hZeroinR[i][1][j]),hZeroinR[i][2])[1,1];
      }
    }//Iterating through the different variables
  }//Extracting the zero homogeneous parts of the homogeneous summands of h
  //Now we need to fill up the space between the h-parts:
  j = size(hZeroinR);
  hBetweenDegrees = reverse(hBetweenDegrees);
  list tempHList;
  for (i = size(hBetweenDegrees); i>0 ;i--)
  {
    tempHList[i] = list(hBetweenDegrees[i],0);
  }
  for (i = 1; i <= size(hZeroinR); i++)
  {
    for (j = 1; j<=size(tempHList);j++)
    {
      if (hZeroinR[i][1] == tempHList[j][1])
      {
        tempHList[j][2] = hZeroinR[i][2];
      }
    }
  }
  hZeroinR = tempHList;
  dbprint(p,dbprintWhitespace+" Done!");
  dbprint(p,dbprintWhitespace+" Moving everything into the ring K[theta]");
  ring KTheta = 0,(x(1..(nvars(basering) div 2)),
                   d(1..(nvars(basering) div 2)),
                   theta(1..(nvars(basering) div 2))),dp;
  setring(KTheta);
  ideal mapList;
  for (i = 1; i<=nvars(R) ; i++)
  {//filling the list of elements we want to map
    mapList[i] = var(i);
  }//filling the list of elements we want to map
  map thetamap = R, mapList;
  poly entry;
  ideal mons;
  ideal pandqZero;
  list hZeroinKTheta;
  intvec lExp;
  setring(R);
  //Starting with p and q
  for (k=1; k<=4; k++)
  {//Transforming pmax(0),qmax(0),pmin(0),qmin(0) in theta-polys
    mons = ideal();
    for(i = 1; i<=size(pandqZero[k]);i++)
    {//Putting the monomials in a list
      mons[size(mons)+1] = pandqZero[k][i];
    }//Putting the monomials in a list
    setring(KTheta);
    mons = thetamap(mons);
    for (i = 1; i<=size(mons);i++)
    {//transforming the monomials as monomials in the theta_i
      entry = leadcoef(mons[i]);
      lExp  = leadexp(mons[i]);
      for (l = 1; l <=nvars(R) div 2; l++)
      {
        for (j = 0; j<lExp[l];j++)
        {
          entry = entry * (theta(l)-j);
        }
      }
      mons[i] = entry;
    }//transforming the monomials as monomials in the theta_i
    pandqZero[size(pandqZero)+1] = sum(mons);
    setring(R);
  }//Transforming pmax(0),qmax(0),pmin(0),qmin(0) in theta-polys

  //Now hZero
  for (k = size(hZeroinR); k>= 1;k--)
  {//Transforming the different homogeneous parts of h into polys in K[theta]
    mons = ideal();
    for(i = 1; i<=size(hZeroinR[k][2]);i++)
    {//Putting the monomials in a list
      mons[size(mons)+1] = hZeroinR[k][2][i];
    }//Putting the monomials in a list
    setring(KTheta);
    mons = thetamap(mons);
    for (i = 1; i<=size(mons);i++)
    {//transforming the monomials as monomials in theta
      entry = leadcoef(mons[i]);
      lExp  = leadexp(mons[i]);
      for (l = 1; l <=nvars(R) div 2; l++)
      {
        for (j = 0; j<lExp[l];j++)
        {
          entry = entry * (theta(l)-j);
        }
      }
      mons[i] = entry;
    }//transforming the monomials as monomials in theta
    hZeroinKTheta = hZeroinKTheta + list(list(hBetweenDegrees[k],sum(mons)));
    setring(R);
  }//Transforming the different homogeneous parts of h into polys in K[theta]
  dbprint(p,dbprintWhitespace+" Done!");
  //Making the solutionRing
  ring solutionRing = 0,(theta(1..nvars(R) div 2),
                         q(0..(product(kappa+1))*(numberHomogPartsQ -2)-1)),lp;
  dbprint(p,dbprintWhitespace+" Our solution ring is given by "+ string(solutionRing));
  //mapping the different ps and qs and HZeros
  dbprint(p,dbprintWhitespace+" Setting up our solution system.");
  list ps;
  ideal pandqZero = imap(KTheta,pandqZero);
  for (i =numberHomogPartsP; i>=1; i--)
  {
    ps[i] = list(pBetweenDegrees[i],0);
  }
  ps[1][2] = pandqZero[2];
  ps[numberHomogPartsP][2] = pandqZero[1];
  list qs;
  for (i = numberHomogPartsQ; i>=1 ; i--)
  {
    qs[i] = list(qBetweenDegrees[i],0);
  }
  qs[1][2] = pandqZero[4];
  qs[numberHomogPartsQ][2] = pandqZero[3];
  qs = reverse(qs);
  ps = reverse(ps);
  pBetweenDegrees = reverse(pBetweenDegrees);
  qBetweenDegrees = reverse(qBetweenDegrees);
  tempIntVec2 = 0:nvars(R);
  for (i = 1; i<=size(kappa); i++)
  {tempIntVec2[i + size(kappa)] = kappa[i];}
  list coefficientIndices = possibleHomogPartsInBetween(kappa,
                                              0:size(kappa),
                                              tempIntVec2);
  poly tempPoly;
  for (i = 2; i<numberHomogPartsQ; i++)
  {
    for (j = 1; j<=size(coefficientIndices); j++)
    {
      tempPoly = 1;
      for (k=1; k <= size(coefficientIndices[j]); k++)
      {tempPoly = tempPoly*theta(k)^coefficientIndices[j][k];}
      qs[i][2] = qs[i][2] + q((i-2)*product(kappa+1)+(j-1))*tempPoly;
    }
  }
  dbprint(p,dbprintWhitespace + "The abstraction for the qs looks like:");
  dbprint(p,qs);
  list hZero = imap(KTheta,hZeroinKTheta);
  //writing and solving the system
  list lhs;
  lhs[1] = list(ps[1][2],1);
  list rhs;
  rhs[numberHomogPartsP] = list(ps[size(ps)][2],1);
  for (i = 2; i<= numberHomogPartsP;i++)
  {
    tempPoly = qs[1][2];
    for (j = 1; j <= nvars(R) div 2; j++)
    {
      tempPoly = subst(tempPoly, theta(j), theta(j) + pBetweenDegrees[i][j]);
    }
    tempPoly = tempPoly * gammaForThetaNthWeyl(ps[i][1],qs[1][1]);
    lhs[i] = list(hZero[i][2],tempPoly);
    tempPoly = qs[size(qs)][2];
    for (j = 1; j <= nvars(R) div 2; j++)
    {
      tempPoly = subst(tempPoly, theta(j), theta(j) + pBetweenDegrees[numberHomogPartsP -i +1][j]);
    }
    tempPoly = tempPoly * gammaForThetaNthWeyl(ps[numberHomogPartsP
                                                  - i +1][1],qs[size(qs)][1]);
    rhs[numberHomogPartsP-i+1] =
      list(hZero[size(hZero)-i+1][2],tempPoly);
    for (j = 1; j<i; j++)
    {
      for (k = 1; k<=size(qs);k++)
      {
        if(ps[j][1]+qs[k][1] == hZero[i][1])
        {
          lhs[i][1] = lhs[i][1]*lhs[j][2];
          lhs[i][2] = lhs[i][2]*lhs[j][2];
          tempPoly = qs[k][2];
          for (l = 1; l <= nvars(R) div 2; l++)
          {
            tempPoly = subst(tempPoly, theta(l), theta(l) + pBetweenDegrees[j][l]);
          }
          tempPoly = tempPoly *
    gammaForThetaNthWeyl(ps[j][1],qs[k][1]);
          lhs[i][1] = lhs[i][1]-lhs[j][1]*tempPoly;
        }
        if(ps[size(ps)-j+1][1] + qs[size(qs) - k +1][1] ==hZero[size(hZero)-i+1][1])
        {
          rhs[size(ps) - i+1][1] = rhs[size(ps)-i+1][1]*rhs[size(ps)- j+1][2];
          rhs[size(ps) - i + 1][2] =
            rhs[size(ps)-i+1][2]*rhs[size(ps)-j+1][2];
          tempPoly = qs[size(qs) - k + 1][2];
          for (l = 1; l <= nvars(R) div 2; l++)
          {
            tempPoly = subst(tempPoly, theta(l), theta(l) +
                             pBetweenDegrees[size(ps)-j + 1][l]);
          }
          tempPoly = tempPoly * gammaForThetaNthWeyl(ps[size(ps) -j
                                                        +1][1],qs[size(qs)-k+1][1]);
          rhs[size(ps) -i+1][1] =
            rhs[size(ps)-i+1][1]-rhs[size(ps)-j+1][1]*tempPoly;
        }
      }
    }
  }
  list eqs;
  poly tempgcd;
  poly templhscoeff;
  poly temprhscoeff;
  for (i = 1; i<=size(rhs);i++)
  {
    if (gcd(rhs[i][2],lhs[i][2]) == 1)
    {
      eqs = eqs + list(lhs[i][1]*rhs[i][2] -rhs[i][1]*lhs[i][2]);
    }
    else
    {
      tempgcd = gcd(rhs[i][2],lhs[i][2]);
      templhscoeff = quotient(rhs[i][2],tempgcd)[1];
      temprhscoeff = quotient(lhs[i][2],tempgcd)[1];
      eqs = eqs + list(lhs[i][1]*templhscoeff -rhs[i][1]*temprhscoeff);
    }
  }
  list newEntries;
  list newEntriesTemp;
  matrix tempCoefMatrix;
  ideal solutionSystemforqs;
  for (i = 1; i<= size(eqs); i++)
  {//filling the ideal solutionSystemforqs
    j = 1;
    tempCoefMatrix = coef(eqs[i],theta(j));
    for (l = 1; l<=ncols(tempCoefMatrix);l++)
    {
      newEntries = newEntries + list(tempCoefMatrix[2,l]);
    }
    while (j< nvars(R) div 2)
    {
      j++;
      newEntriesTemp = list();
      for (k = 1; k<=size(newEntries); k++)
      {
        tempCoefMatrix = coef(newEntries[k],theta(j));
        for (l = 1; l<=ncols(tempCoefMatrix);l++)
        {
          newEntriesTemp = newEntriesTemp + list(tempCoefMatrix[2,l]);
        }
      }
      newEntries = newEntriesTemp;
    }
    for (j = 1; j<=size(newEntries); j++)
    {
      solutionSystemforqs = solutionSystemforqs + newEntries[j];
    }
  }//filling the ideal solutionSystemforqs
  dbprint(p,dbprintWhitespace+" Solution system for the coefficients of q is given by:");
  dbprint(p,solutionSystemforqs);
  option(redSB);
  dbprint(p,dbprintWhitespace+" Calculating reduced Groebner Basis of that system.");
  solutionSystemforqs = slimgb(solutionSystemforqs);
  dbprint(p,dbprintWhitespace+" Done!, the solution for the system is:");
  dbprint(p,dbprintWhitespace+string(solutionSystemforqs));
  ideal theThetas;
  for (i = 1; i<=nvars(R) div 2; i++)
  {//Adding the theta_i to solutionSystemforqs to get vdim neq infty
    theThetas = theThetas + theta(i);
  }//Adding the theta_i to solutionSystemforqs to get vdim neq infty
  int v_s_t=vdim(slimgb(solutionSystemforqs + theThetas));
  if(v_s_t==0)
  {//No solution in this case. Return the empty list
    dbprint(p,dbprintWhitespace+"The Groebner Basis of the solution system was <1>.");
    setring(R);
    return(list());
  }//No solution in this case. Return the empty list
  if(v_s_t==-1)
  {//My conjecture is that this would never happen
    dbprint(p,dbprintWhitespace+"There are infinitely many solution to this system.
We will return the empty list.");
    setring(R);
    return(list());
  }//My conjecture is that this would never happen
  else
  {//We have finitely many solutions
    if(v_s_t==1)
    {//exactly one solution
      for (i = 2; i<= size(qs)-1;i++)
      {
        qs[i][2] = NF(qs[i][2],solutionSystemforqs); //solutionSystemforqs is GB
      }
      setring(R);
      ideal finalMapList;
      for (i = 1; i<=nvars(R) div 2; i++)
      {
        finalMapList[i] = var(i)*var(i + (nvars(R) div 2));
      }
      map backFromSolutionRing = solutionRing,finalMapList;
      list qs = backFromSolutionRing(qs);
      list result = list(0);
      for (i = 1; i<=size(qs); i++)
      {
        for (j= 1; j<=size(qs[i][1]); j++)
        {
          if (qs[i][1][j]>0){qs[i][2] = qs[i][2]*var(j + nvars(R) div 2)^qs[i][1][j];}
          if (qs[i][1][j]<0){qs[i][2] = qs[i][2]*var(j)^(-qs[i][1][j]);}
        }
        result[1] = result[1] + qs[i][2];
      }
      dbprint(p,dbprintWhitespace+"Found one unique solution. Returning the result.");
      return(result);
    }//exactly one solution
    else
    {//We have more than one solution, but finitely many
      def ringForSolveLib = solve(solutionSystemforqs+theThetas, "nodisplay");
      setring ringForSolveLib;
      list valuesForQs = list();
      list tempValues;
      int validSol;
      for (i = 1; i<=size(SOL); i++)
      {//filtering integer solutions
        validSol = 1;
        for (j =1; j<=size(SOL[i]); j++)
        {//Checking every entry if it is integer or not
          if (SOL[i][j] - int(SOL[i][j])!=0)
          {//No integer solution
            validSol = 0;
            break;
          }//No integer solution
        }//Checking every entry if it is integer or not
        if (validSol)
        {
          tempValues = list();
          for (j = 1; j<=size(SOL[i]); j++)
          {//filling the valuesforQs
            tempValues[j]= int(SOL[i][j]);
          }//filling the valuesforQs
          valuesForQs = valuesForQs + list(tempValues);
        }
      }//filtering integer solutions
      setring solutionRing;
      list differentQs = list();
      ideal tempSolutionForQ;
      for (i = 1; i<=size(valuesForQs); i++)
      {
        differentQs[i] = qs;
        tempSolutionForQ = ideal();
        for (j=(nvars(R) div 2)+1; j<=nvars(solutionRing);j++)
        {//filling solution ideal
          tempSolutionForQ[j-(nvars(R) div 2)] = var(j) - valuesForQs[i][j];
        }//filling solution ideal
        for (j=2; j<size(differentQs[i]); j++)
        {
          differentQs[i][j][2] = NF(differentQs[i][j][2],slimgb(tempSolutionForQ));
        }
      }
      setring(R);
      ideal finalMapList;
      for (i = 1; i<=nvars(R) div 2; i++)
      {
        finalMapList[i] = var(i)*var(i + (nvars(R) div 2));
      }
      map backFromSolutionRing = solutionRing,finalMapList;
      list differentQs = backFromSolutionRing(differentQs);
      list result = list();
      for (k = 1; k<=size(differentQs); k++)
      {
        result[k] = 0;
        for (i = 1; i<=size(differentQs[k]); i++)
        {
          for (j= 1; j<=size(differentQs[k][i][1]); j++)
          {
            if (differentQs[k][i][1][j]>0)
            {differentQs[k][i][2] =
                differentQs[k][i][2]*var(j + nvars(R) div 2)^differentQs[k][i][1][j];}
            if (differentQs[k][i][1][j]<0)
            {differentQs[k][i][2] = differentQs[k][i][2]*var(j)^(-differentQs[k][i][1][j]);}
          }
          result[k] = result[k] + differentQs[k][i][2];
        }
      }
      dbprint(p,dbprintWhitespace+"Found multiple solutions. Returning the result.");
      return(result);
    }//We have more than one solution, but finitely many
  }//We have finitely many solutions
}//proc determineRestOfHomogPartsNthWeyl


static proc test_determineRestOfHomogPartsNthWeyl()
{//testing determineRestOfHomogPartsNthWeyl
  int result = 1;
  //Test 1: Example 2.7 from Master's Thesis
  ring R = 0,(x,d),dp;
  def r = nc_algebra(1,1);
  setring(r);
  //poly h = (xdd + xd+1+ (xd+5)*x)*
  //  (((x*d)^2+1)*d + xd+3+ (xd+7)*x);
  poly input1 = xdd;
  poly input2 = (xd+5)*x;
  poly input3 = ((x*d)^2+1)*d;
  poly input4 = (xd+7)*x;
  poly input5 = (xdd + xd+1+ (xd+5)*x)*
    (((x*d)^2+1)*d + xd+3+ (xd+7)*x);
  list expected = list((((x*d)^2+1)*d + xd+3+ (xd+7)*x));
  list obtained = determineRestOfHomogPartsNthWeyl(input1,
                           input2,
                           input3,
                           input4,
                           input5);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 1 for determineRestOfHomogPartsNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test2: right factor has nothing in between.
  input1 = 1;
  input2 = x^3;
  input3 = d*x + 2;
  input4 = x^4;
  input5 = (x^3+x+1)*(x^4+d*x+2);
  expected = list((x^4+d*x+2));
  obtained = determineRestOfHomogPartsNthWeyl(input1,
                          input2,
                          input3,
                          input4,
                          input5);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 2 for determineRestOfHomogPartsNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test3: p and q identical
  input1 = d;
  input2 = x^2;
  input3 = d;
  input4 = x^2;
  input5 = (x^2+d)*(x^2+d);
  expected = list((x^2+d));
  obtained = determineRestOfHomogPartsNthWeyl(input1,
                          input2,
                          input3,
                          input4,
                          input5);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 3 for determineRestOfHomogPartsNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill R;
  kill r;
  //Test 4: More than one solution
  ring R = 0,(x(1..4),d(1..4)),dp;
  def r= Weyl();
  setring r;
  poly input1 = d(1);
  poly input2 = x(1);
  poly input3 = d(1);
  poly input4 = x(1);
  poly input5 =
    x(1)^2+2*x(1)*d(1)+d(1)^2+x(1)*d(2)+d(1)*d(2)+4*x(1)+4*d(1)+4*d(2)+1;
  list expected = list(x(1)+d(1)+d(2),x(1)+d(1)+4);
  list obtained = determineRestOfHomogPartsNthWeyl(input1,
                                                   input2,
                                                   input3,
                                                   input4,
                                                   input5);
  if ((!isListEqual(expected,obtained)))
  {
    print("Test 4 for determineRestOfHomogPartsNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing determineRestOfHomogPartsNthWeyl


static proc gammaForThetaNthWeyl(intvec j1,intvec j2)
"
INPUT: Two integer vectors j1 and j2
OUTPUT: A polynomial in \theta_1,...,\theta_n. It calculates the following function:
The product for i = 1 to n of gamma_{j1_i,j2_i}, where gamma is defined as in the function
gammaForTheta.

ASSUMPTION:
- Ring has at least the variables \theta_1,...,\theta_n, being in position 1,...,n
- both intvectors have length at least n
"
{//gammaForThetaNthWeyl
  //Some stability tests in advance:
  if (size(j1) != size(j2))
  {ERROR("The size of the input vectors does not coincide.");}
  if (size(j1) > nvars(basering))
  {ERROR("The size of the input vectors is bigger than the number of variables.");}
  int i; int j;
  ideal separateGammas;
  poly polyForPositionJ;
  for (j = 1; j <= size(j1); j++)
  {//Iterate through the \theta_j
    if (j1[j]<=0 && j2[j] <=0)
    {
      separateGammas[j] = 1;
      j++; continue;
    }
    if (j1[j]>=0 && j2[j] >=0)
    {
      separateGammas[j] = 1;
      j++; continue;
    }
    if (j1[j]<0 && j2[j]>0)
    {//case 2 or 3 from description above
      if (absValue(j1[j])<=absValue(j2[j]))
      {//Case 2 holds here
        polyForPositionJ = 1;
        for (i = 0;i<absValue(j1[j]);i++)
        {
          polyForPositionJ = polyForPositionJ*(var(j)-i);
        }
        separateGammas[j] = polyForPositionJ;
        j++; continue;
      }//Case 2 holds here
      else
      {//Case 3 holds here
        polyForPositionJ = 1;
        for (i = 0; i<j2; i++)
        {
          polyForPositionJ = polyForPositionJ*(var(1)-i-absValue(j1[j])+absValue(j2[j]));
        }
        separateGammas[j] = polyForPositionJ;
        j++; continue;
      }//Case 3 holds here
    }//case 2 or 3 from description above
    else
    {//Case 4 or 5 from description above hold
      if (absValue(j1[j])<=absValue(j2[j]))
      {//Case 4 holds
        polyForPositionJ = 1;
        for (i = 1; i<=j1[j]; i++)
        {
          polyForPositionJ = polyForPositionJ*(var(j)+i);
        }
        separateGammas[j] = polyForPositionJ;
        j++; continue;
      }//Case 4 holds
      else
      {//Case 5 holds
        polyForPositionJ = 1;
        for (i = 1; i<=absValue(j2[j]); i++)
        {
          polyForPositionJ = polyForPositionJ*(var(j)+i+absValue(j1[j])-absValue(j2[j]));
        }
        separateGammas[j] = polyForPositionJ;
        j++; continue;
      }//Case 5 holds
    }//Case 4 or 5 from description above hold
  }//Iterate through the \theta_j
  return(product(separateGammas));
}//gammaForThetaNthWeyl


static proc test_gammaForThetaNthWeyl()
{//testing gammaForThetaNthWeyl
  int result = 1;
  ring R = 0,(x(1..5),d(1..5)),dp;
  def r = Weyl();
  ring R2 = 0,(theta(1..5)),dp;
  def r2 = R2 + r;
  setring(r2);
  //Test 1: two zeros.
  intvec input1 = 0,0,0,0,0;
  intvec input2 = 0,0,0,0,0;
  poly expected = 1;
  poly obtained = gammaForThetaNthWeyl(input1,input2);
  if (expected!=obtained)
  {
    print("Test 1 for gammaForThetaNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //test 2: the first var set in both
  input1 = 1,0,0,0,0;
  input2 = 1,0,0,0,0;
  expected = 1;
  obtained = gammaForThetaNthWeyl(input1,input2);
  if (expected!=obtained)
  {
    print("Test 2 for gammaForThetaNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //test 3: the last var set in both
  input1 = 0,0,0,0,1;
  input2 = 0,0,0,0,-1;
  expected = theta(5)+1;
  obtained = gammaForThetaNthWeyl(input1,input2);
  if (expected!=obtained)
  {
    print("Test 3 for gammaForThetaNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //test 4: Random setting of all variables
  input1 = -1,2,-3,3,-4;
  input2 = 1,2,3,-3,-1;
  expected = theta(1)*theta(3)*(theta(3)-1)*
    (theta(3)-2)*(theta(4)+3)*(theta(4)+2)*(theta(4)+1);
  obtained = gammaForThetaNthWeyl(input1,input2);
  if (expected!=obtained)
  {
    print("Test 4 for gammaForThetaNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing gammaForThetaNthWeyl


static proc extractHomogeneousDivisorsNthWeyl(poly h)
"INPUT: A polynomial h in the nth Weyl algebra
OUTPUT: If h is homogeneous with respect to the ZZ-grading on the nth Weyl algebra,
 then all factorizations of h are returned.
 If h is inhomogeneous, then a list l is returned whose entries
 are again lists k = [k_1,...,k_n], where k_1*...*k_n = h and there
 exists an i in {1,...,n}, such that k_i is inhomogeneous and there
 is no homogeneous polynomial that divides this k_i neither from the
 left nor from the right. All the other entries in k are homogeneous
 polynomials. (i.e. there are no constants)
GENERAL ASSUMPTIONS:
 - The basering is the nth Weyl algebra and has the form, that the first n variables represent
   x1, ..., xn, and the second n variables do represent the d1, ...,
   dn.
 - h is not a constant.
"
{//extractHomogeneousDivisorsNthWeyl
  int p=printlevel-voice+2; // for dbprint
  string dbprintWhitespace = "";
  int i; int j; int k; int l; int m;
  list result;
  for (i = 1; i<=voice;i++)
  {dbprintWhitespace = dbprintWhitespace + " ";}
  if (homogwithorderNthWeyl(h))
  {//given polynomial was homogeneous already
    dbprint(p,dbprintWhitespace+"Polynomial was homogeneous. Just returning all factorizations.");
    result = homogfacNthWeyl_all(h);
    for (i = 1; i<=size(result);i++)
    {//removing the first entry (coefficient) from the list result
      result[i] = delete(result[i],1);
    }//removing the first entry (coefficient) from the list result
    return(result);
  }//given polynomial was homogeneous already
  list rightDivisionPossibilities =
    extractHomogeneousDivisorsRightNthWeyl(h);
  //Checking if the inhomogeneous divisor has homogeneous factors on
  //the left.
  list tempLeftDiv;
  list tempNewResultEntry;
  for (i=1; i<=size(rightDivisionPossibilities);i++)
  {//checking each inhomogeneous factor for left divisors
    tempLeftDiv =
      extractHomogeneousDivisorsLeftNthWeyl(rightDivisionPossibilities[i][1]);
    for (j = 1; j<= size(tempLeftDiv); j++)
    {
      tempNewResultEntry = list();
      for (k = 1; k<=size(tempLeftDiv[j]);k++)
      {
    tempNewResultEntry = insert(tempNewResultEntry,
                    tempLeftDiv[j][k],
                    size(tempNewResultEntry));
      }
      for (k = 2; k<=size(rightDivisionPossibilities[i]);k++)
      {
    tempNewResultEntry = insert(tempNewResultEntry,
                    rightDivisionPossibilities[i][k],
                    size(tempNewResultEntry));
      }
      result = insert(result, tempNewResultEntry);
    }
  }//checking each inhomogeneous factor for left divisors
  result = delete_duplicates_noteval_and_sort(result);
  //Reaching here, we have a list of the form [k_1...,k_n1,a,k_(n1
  //+1),...,k_n2], where the k_i are homogeneous and a is
  //inhomogeneous. The only not-accounted for possibilities now are
  //interchanges of factors right of a with a towards the left.
  int inhomogPosition;
  list tempResult;
  poly inhomogElement;
  poly tempRightFactor;
  list tempRightLeftExchange;
  list tempRightLeftExchangeElem;
  list rightOfTempRightLeftExchange;
  for (i=1; i<=size(result); i++)
  {//checking for interchanges of right divisors
    tempResult = insert(tempResult,result[i]);
    inhomogPosition = 0;
    //find out where the inhomog element is:
    for (j=1;j<=size(result[i]);j++)
    {//finding the position of the inhomogeneous element
      if (!homogwithorderNthWeyl(result[i][j]))
      {//found it
    inhomogPosition = j;
    break;
      }//found it
    }//finding the position of the inhomogeneous element
    if (inhomogPosition == size(result[i]) || inhomogPosition == 0)
    {// The first case is fine, the second would be weird.
      i++; continue;
    }// The first case is fine, the second would be weird.
    inhomogElement = result[i][inhomogPosition];
    tempRightFactor = 1;
    for (j = inhomogPosition + 1; j<=size(result[i]); j++)
    {//Trying to do some exchanges with right factors
      tempRightFactor = tempRightFactor*result[i][j];
      tempRightLeftExchange =
    extractHomogeneousDivisorsLeftNthWeyl(result[i][inhomogPosition]*tempRightFactor);
      for (k = 1; k<=size(tempRightLeftExchange); k++)
      {//checking if there was some exchange happening
    if (size(tempRightLeftExchange[k])>1)
    {//Bingo, here is an element
      rightOfTempRightLeftExchange =
        extractHomogeneousDivisorsRightNthWeyl(
      tempRightLeftExchange[k][size(tempRightLeftExchange[k])]);
      tempRightLeftExchange[k] =
        delete(tempRightLeftExchange[k],size(tempRightLeftExchange[k]));
      tempRightLeftExchangeElem = tempRightLeftExchange[k];
      for (m=1;m<=size(rightOfTempRightLeftExchange);m++)
      {
        for (l = 1; l<=size(rightOfTempRightLeftExchange[m]);l++)
        {
          tempRightLeftExchange[k] =
        insert(tempRightLeftExchange[k],
               rightOfTempRightLeftExchange[m][l],
               size(tempRightLeftExchange[k]));
        }
        tempNewResultEntry = list();
        for (l = 1; l<inhomogPosition; l++)
        {
          tempNewResultEntry =
        insert(tempNewResultEntry,result[i][l],size(tempNewResultEntry));
        }
        for (l=1;l<=size(tempRightLeftExchange[k]); l++)
        {
          tempNewResultEntry = insert(tempNewResultEntry,
                      tempRightLeftExchange[k][l],
                      size(tempNewResultEntry));
        }
        for (l = j+1; l<=size(result[i]);l++)
        {
          tempNewResultEntry =
        insert(tempNewResultEntry,result[i][l],size(tempNewResultEntry));
        }
        tempResult = insert(tempResult,tempNewResultEntry);
      }
    }//Bingo, here is an element
      }//checking if there was some exchange happening
      tempResult = delete_duplicates_noteval_and_sort(tempResult);
    }//Trying to do some exchanges with right factors
  }//checking for interchanges of right divisors
  result = tempResult;
  result = delete_duplicates_noteval_and_sort(result);
  return(result);
}//extractHomogeneousDivisorsNthWeyl


static proc test_extractHomogeneousDivisorsNthWeyl()
{//testing extractHomogeneousDivisorsNthWeyl
  int result = 1;
  ring R = 0,(x(1..4),d(1..4)),dp;
  def r = Weyl();
  setring(r);
  //Test 1: homogeneous polynomial
  poly input =x(1)*d(1);
  list expected = list(list(x(1),d(1)));
  list obtained = extractHomogeneousDivisorsNthWeyl(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 1 for extractHomogeneousDivisorsNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: homogeneous right divisor
  input = (x(1)*d(2) + 1)*x(2);
  expected = list(list(x(1)*d(2) + 1,x(2)));
  obtained = extractHomogeneousDivisorsNthWeyl(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 2 for extractHomogeneousDivisorsNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: homogeneous right divisor
  input = x(2)*(x(1)*d(2) + 1);
  expected = list(list(x(2),x(1)*d(2) + 1));
  obtained = extractHomogeneousDivisorsNthWeyl(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 3 for extractHomogeneousDivisorsNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: homogeneous divisor on both sides
  input = x(2)*(x(1)*d(2) + 1)*d(1);
  expected = list(list(x(2),x(1)*d(2) + 1,d(1)));
  obtained = extractHomogeneousDivisorsNthWeyl(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 4 for extractHomogeneousDivisorsNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 5: More than one homogeneous divisor on both sides
  input = x(1)*x(4)*(d(4)+ d(1)+1)*x(4)*x(1);
  expected = sortFactorizations(list(
    list(x(1),x(4),(d(4)+ d(1)+1),x(4),x(1)),
    list(x(1),x(4),(d(4)+ d(1)+1),x(1),x(4)),
    list(x(4),x(1),(d(4)+ d(1)+1),x(4),x(1)),
    list(x(4),x(1),(d(4)+ d(1)+1),x(1),x(4))
                  ));
  obtained = sortFactorizations(extractHomogeneousDivisorsNthWeyl(input));
  if (!isListEqual(expected,obtained))
  {
    print("Test 5 for extractHomogeneousDivisorsNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 6: From bug:
  input =
    x(1)*x(2)^2*d(1)^2*d(2)+x(4)^3*d(1)^2*d(4)+2*x(1)*x(2)*d(1)^2+d(1)^2;
  expected = sortFactorizations(list(
    list(d(1),x(1)*x(2)^2*d(1)*d(2)+x(4)^3*d(1)*d(4)+2*x(1)*x(2)*d(1)-x(2)^2*d(2)-2*x(2)+d(1)),
    list(x(1)*x(2)^2*d(2)+x(4)^3*d(4)+2*x(1)*x(2)+1,d(1),d(1))
                  ));
  obtained =
    sortFactorizations(extractHomogeneousDivisorsNthWeyl(input));
  if (!isListEqual(expected,obtained))
  {
    print("Test 6 for extractHomogeneousDivisorsNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing extractHomogeneousDivisorsNthWeyl


static proc extractHomogeneousDivisorsLeftNthWeyl(poly h)
"INPUT: A polynomial h in the nth Weyl algebra
OUTPUT: If h is homogeneous with respect to the ZZ grading on the nth Weyl algebra,
 then all factorizations of h are returned.
 If h is inhomogeneous, then a list l is returned whose entries
 are again lists k = [k_1,...,k_n], where k_1*...*k_n = h.
 The entry k_n is inhomogeneous and has no other homogeneous
 left divisors any more.
 All the other entries in k are homogeneous
 polynomials.

GENERAL ASSUMPTIONS:
 - The basering is the nth Weyl algebra and has the form, that the first n variables represent
   x1, ..., xn, and the second n variables do represent the d1, ..., dn.
"
{//extractHomogeneousDivisorsLeftNthWeyl
  int p=printlevel-voice+2; // for dbprint
  string dbprintWhitespace = "";
  int i;int j; int k;
  list result;
  poly hath;
  list recResult;
  ideal invoIdeal;
  for (i = 1; i <= nvars(basering); i++)
  {//Filling the mapping rules for the involution map
    if (i <= nvars(basering) div 2)
    {invoIdeal[i] = -var(i);}
    else
    {invoIdeal[i] = var(i);}
  }//Filling the mapping rules for the involution map
  map invo = basering,invoIdeal;
  for (i = 1; i<=voice;i++)
  {dbprintWhitespace = dbprintWhitespace + " ";}
  if (homogwithorderNthWeyl(h))
  {//given polynomial was homogeneous already
    dbprint(p,dbprintWhitespace+"Polynomial was homogeneous. Just returning all factorizations.");
    result = homogfacNthWeyl_all(h);
    for (i = 1; i<=size(result);i++)
    {//removing the first entry (coefficient) from the list result
      result[i] = delete(result[i],1);
    }//removing the first entry (coefficient) from the list result
    return(result);
  }//given polynomial was homogeneous already
  list hlist = homogDistributionNthWeyl(h);
  dbprint(p,dbprintWhitespace+ " Computing factorizations of all homogeneous summands.");
  for (i = 1; i<= size(hlist); i++)
  {
    hlist[i] = homogfacNthWeyl_all(hlist[i][2]);
    if (size(hlist[i][1])==1)
    {//One homogeneous part just has a trivial factorization
      if(hlist[i][1][1] == 0)
      {
        hlist = delete(hlist,i);
        continue;
      }
      else
      {
        return(list(list(h)));
      }
    }//One homogeneous part just has a trivial factorization
  }
  dbprint(p,dbprintWhitespace+ " Done.");
  dbprint(p,dbprintWhitespace+ " Trying to find Left divisors");
  list alreadyConsideredCandidates;
  poly candidate;
  int isCandidate;
  for (i = 1; i<=size(hlist[1]);i++)
  {//Finding candidates for homogeneous left divisors of h
    candidate = hlist[1][i][2];
    isCandidate = 0;
    for (j=1;j<=size(alreadyConsideredCandidates);j++)
    {
      if(alreadyConsideredCandidates[j] == candidate)
      {
        isCandidate =1;
        break;
      }
    }
    if(isCandidate)
    {
      i++;
      continue;
    }
    else
    {
      alreadyConsideredCandidates = alreadyConsideredCandidates + list(candidate);
    }
    dbprint(p,dbprintWhitespace+"Checking if "+string(candidate)+" is a homogeneous left divisor");
    for (j = 2; j<=size(hlist);j++)
    {//Iterating through the other homogeneous parts
      isCandidate = 0;
      for(k=1; k<=size(hlist[j]);k++)
      {
        if(hlist[j][k][2]==candidate)
        {
          isCandidate = 1;
          break;
        }
      }
      if(!isCandidate)
      {
        break;
      }
    }//Iterating through the other homogeneous parts
    if(isCandidate)
    {//candidate was really a left divisor
      dbprint(p,dbprintWhitespace+string(candidate)+" is a homogeneous left divisor");
      hath = involution(lift(involution(candidate,invo),involution(h,invo))[1,1],invo);
      recResult = extractHomogeneousDivisorsLeftNthWeyl(hath);
      for (j = 1; j<=size(recResult); j++)
      {
        recResult[j] = insert(recResult[j],candidate);
      }
      result = result + recResult;
    }//Candidate was really a left divisor
  }//Finding candidates for homogeneous left divisors of h
  if (size(result)==0)
  {
    return(list(list(h)));
  }
  return(result);
}//extractHomogeneousDivisorsLeftNthWeyl


static proc test_extractHomogeneousDivisorsLeftNthWeyl()
{//testing extractHomogeneousDivisorsLeftNthWeyl
  int result = 1;
  ring R = 0,(x(1..4),d(1..4)),dp;
  def r = Weyl();
  setring(r);
  //Test 1: homogeneous polynomial
  poly input =x(1)*d(1);
  list expected = list(list(x(1),d(1)));
  list obtained = extractHomogeneousDivisorsLeftNthWeyl(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 1 for extractHomogeneousDivisorsLeftNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: homogeneous left divisor
  input = x(2)*(x(1)*d(2) + 1);
  expected = list(list(x(2),x(1)*d(2) + 1));
  obtained = extractHomogeneousDivisorsLeftNthWeyl(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 2 for extractHomogeneousDivisorsLeftNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: homogeneous divisor on both sides
  input = x(2)*(x(1)*d(2) + 1)*d(1);
  expected = list(list(x(2),(x(1)*d(2) + 1)*d(1)));
  obtained = extractHomogeneousDivisorsLeftNthWeyl(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 3 for extractHomogeneousDivisorsLeftNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: More than one homogeneous divisor on both sides
  input = x(1)*x(4)*(d(4)+ d(1)+1)*x(4)*x(1);
  expected = sortFactorizations(
    list(
      list(x(1),x(4),(d(4)+ d(1)+1)*x(4)*x(1)),
      list(x(4),x(1),(d(4)+ d(1)+1)*x(1)*x(4))
      ));
  obtained = sortFactorizations(extractHomogeneousDivisorsLeftNthWeyl(input));
  if (!isListEqual(expected,obtained))
  {
    print("Test 4 for extractHomogeneousDivisorsLeftNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 5: Small example first Weyl
  input = x(1)*(d(1) + x(1));
  expected = sortFactorizations(
    list(
      list(x(1),d(1) + x(1))
      ));
  obtained = sortFactorizations(extractHomogeneousDivisorsLeftNthWeyl(input));
  if (!isListEqual(expected,obtained))
  {
    print("Test 5 for extractHomogeneousDivisorsLeftNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 6: only irreducible polynomial
  input = x(1)*d(2) + x(3)*d(3);
  expected = sortFactorizations(
    list(
      list(x(1)*d(2) + x(3)*d(3))
      ));
  obtained = sortFactorizations(extractHomogeneousDivisorsLeftNthWeyl(input));
  if (!isListEqual(expected,obtained))
  {
    print("Test 6 for extractHomogeneousDivisorsLeftNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 7: Non-trivial example third Weyl
  input = x(1)*x(2)*d(2)^2+x(2)^2*d(2)*d(3)+x(1)*d(2)+2*x(2)*d(3);
  expected = sortFactorizations(
    list(
      list(d(2),x(2),x(1)*d(2)+x(2)*d(3))
      ));
  obtained = sortFactorizations(extractHomogeneousDivisorsLeftNthWeyl(input));
  if (!isListEqual(expected,obtained))
  {
    print("Test 7 for extractHomogeneousDivisorsLeftNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing extractHomogeneousDivisorsLeftNthWeyl


static proc extractHomogeneousDivisorsRightNthWeyl(poly h)
"INPUT: A polynomial h in the nth Weyl algebra
OUTPUT: If h is homogeneous with respect to the ZZ grading on the nth Weyl algebra,
 then all factorizations of h are returned.
 If h is inhomogeneous, then a list l is returned whose entries
 are again lists k = [k_1,...,k_n], where k_1*...*k_n = h.
 The entry k_1 is inhomogeneous and has no other homogeneous
 right divisors any more.
 All the other entries in k are homogeneous
 polynomials.
GENERAL ASSUMPTIONS:
 - The basering is the nth Weyl algebra and has the form, that the first n variables represent
   x1, ..., xn, and the second n variables do represent the d1, ..., dn.
"
{//extractHomogeneousDivisorsRightNthWeyl
  int p=printlevel-voice+2; // for dbprint
  string dbprintWhitespace = "";
  int i;int j; int k;
  list result;
  poly hath;
  list recResult;
  for (i = 1; i<=voice;i++)
  {dbprintWhitespace = dbprintWhitespace + " ";}
  if (homogwithorderNthWeyl(h))
  {//given polynomial was homogeneous already
    dbprint(p,dbprintWhitespace+"Polynomial was homogeneous. Just returning all factorizations.");
    result = homogfacNthWeyl_all(h);
    for (i = 1; i<=size(result);i++)
    {//removing the first entry (coefficient) from the list result
      result[i] = delete(result[i],1);
    }//removing the first entry (coefficient) from the list result
    return(result);
  }//given polynomial was homogeneous already
  list hlist = homogDistributionNthWeyl(h);
  dbprint(p,dbprintWhitespace+ " Computing factorizations of all homogeneous summands.");
  for (i = 1; i<= size(hlist); i++)
  {
    hlist[i] = homogfacNthWeyl_all(hlist[i][2]);
    if (size(hlist[i][1])==1)
    {//One homogeneous part just has a trivial factorization
      if(hlist[i][1][1] == 0)
      {
        hlist = delete(hlist,i);
        continue;
      }
      else
      {
        return(list(list(h)));
      }
    }//One homogeneous part just has a trivial factorization
  }
  dbprint(p,dbprintWhitespace+ " Done.");
  dbprint(p,dbprintWhitespace+ " Trying to find right divisors");
  list alreadyConsideredCandidates;
  poly candidate;
  int isCandidate;
  for (i = 1; i<=size(hlist[1]);i++)
  {//Finding candidates for homogeneous left divisors of h
    candidate = hlist[1][i][size(hlist[1][i])];
    isCandidate = 0;
    for (j=1;j<=size(alreadyConsideredCandidates);j++)
    {
      if(alreadyConsideredCandidates[j] == candidate)
      {
        isCandidate =1;
        break;
      }
    }
    if(isCandidate)
    {
      i++;
      continue;
    }
    else
    {
      alreadyConsideredCandidates = alreadyConsideredCandidates + list(candidate);
    }
    dbprint(p,dbprintWhitespace+"Checking if "+string(candidate)+" is a homogeneous r-divisor");
    for (j = 2; j<=size(hlist);j++)
    {//Iterating through the other homogeneous parts
      isCandidate = 0;
      for(k=1; k<=size(hlist[j]);k++)
      {
        if(hlist[j][k][size(hlist[j][k])]==candidate)
        {
          isCandidate = 1;
          break;
        }
      }
      if(!isCandidate)
      {
        break;
      }
    }//Iterating through the other homogeneous parts
    if(isCandidate)
    {//candidate was really a left divisor
      dbprint(p,dbprintWhitespace+string(candidate)+" is a homogeneous right divisor");
      hath = lift(candidate,h)[1,1];
      recResult = extractHomogeneousDivisorsRightNthWeyl(hath);
      for (j = 1; j<=size(recResult); j++)
      {
        recResult[j] = insert(recResult[j],candidate,size(recResult[j]));
      }
      result = result + recResult;
    }//Candidate was really a left divisor
  }//Finding candidates for homogeneous left divisors of h
  if (size(result)==0)
  {
    result = list(list(h));
  }
  return(delete_duplicates_noteval_and_sort(result));
}//extractHomogeneousDivisorsRightNthWeyl


static proc test_extractHomogeneousDivisorsRightNthWeyl()
{//testing extractHomogeneousDivisorsRightNthWeyl
  int result = 1;
    ring R = 0,(x(1..4),d(1..4)),dp;
  def r = Weyl();
  setring(r);
  //Test 1: homogeneous polynomial
  poly input =x(1)*d(1);
  list expected = list(list(x(1),d(1)));
  list obtained = extractHomogeneousDivisorsRightNthWeyl(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 1 for extractHomogeneousDivisorsRightNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: homogeneous right divisor
  input = (x(1)*d(2) + 1)*x(2);
  expected = list(list(x(1)*d(2) + 1,x(2)));
  obtained = extractHomogeneousDivisorsRightNthWeyl(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 2 for extractHomogeneousDivisorsRightNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: homogeneous divisor on both sides
  input = x(2)*(x(1)*d(2) + 1)*d(1);
  expected = list(list(x(2)*(x(1)*d(2) + 1),d(1)));
  obtained = extractHomogeneousDivisorsRightNthWeyl(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 3 for extractHomogeneousDivisorsRightNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: More than one homogeneous divisor on both sides
  input = x(1)*x(4)*(d(4)+ d(1)+1)*x(4)*x(1);
  expected = sortFactorizations(
    list(
      list(x(1)*x(4)*(d(4)+ d(1)+1),x(4),x(1)),
      list(x(4)*x(1)*(d(4)+ d(1)+1),x(1),x(4))
      ));
  obtained = sortFactorizations(extractHomogeneousDivisorsRightNthWeyl(input));
  if (!isListEqual(expected,obtained))
  {
    print("Test 4 for extractHomogeneousDivisorsRightNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 5: Small example first Weyl
  input = (d(1) + x(1))*x(1);
  expected = sortFactorizations(
    list(
      list(d(1) + x(1),x(1))
      ));
  obtained = sortFactorizations(extractHomogeneousDivisorsRightNthWeyl(input));
  if (!isListEqual(expected,obtained))
  {
    print("Test 5 for extractHomogeneousDivisorsRightNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 6: only irreducible polynomial
  input = x(1)*d(2) + x(3)*d(3);
  expected = sortFactorizations(
    list(
      list(x(1)*d(2) + x(3)*d(3))
      ));
  obtained = sortFactorizations(extractHomogeneousDivisorsRightNthWeyl(input));
  if (!isListEqual(expected,obtained))
  {
    print("Test 6 for extractHomogeneousDivisorsRightNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 7: Non-trivial example third Weyl, no homogeneous right divisors
  input = x(1)*x(2)*d(2)^2+x(2)^2*d(2)*d(3)+x(1)*d(2)+2*x(2)*d(3);
  expected = sortFactorizations(
    list(
      list(d(2)*x(2)*(x(1)*d(2)+x(2)*d(3)))
      ));
  obtained = sortFactorizations(extractHomogeneousDivisorsRightNthWeyl(input));
  if (!isListEqual(expected,obtained))
  {
    print("Test 7 for extractHomogeneousDivisorsRightNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing extractHomogeneousDivisorsRightNthWeyl


static proc computeCombinationsMinMaxHomogNthWeyl(poly h)
"Input: A polynomial h in the nth Weyl Algebra
Output: Combinations of the form (p_max + p_min)(q_max + q_min), such that p_max, p_min,
 q_max and q_min are homogeneous and p_max*q_max equals the maximal homogeneous
 part in h, and p_max * q_max equals the minimal homogeneous part in h.
GENERAL ASSUMPTIONS:
- h is not homogeneous.
"{//proc computeCombinationsMinMaxHomogNthWeyl
  int p=printlevel-voice+2; // for dbprint
  string dbprintWhitespace = "";
  int i;
  int j;
  for (i = 1; i<=voice;i++)
  {dbprintWhitespace = dbprintWhitespace + " ";}
  list hList = homogDistributionNthWeyl(h);
  dbprint(p,dbprintWhitespace + "Computing maximal and minimal homogeneous part of h");
  poly maxh = hList[size(hList)][2];
  poly minh = hList[1][2];
  dbprint(p,dbprintWhitespace + "Done. They are:");
  dbprint(p,string(maxh) + ", " + string(minh));
  dbprint(p, dbprintWhitespace + "Computing their respective homogeneous factorizations");
  list f1 = homogfacNthWeyl_all(maxh);
  list f2 = homogfacNthWeyl_all(minh);
  dbprint(p,dbprintWhitespace + "Done.");
  list result = list();
  list pqmax = list();
  list pqmin = list();
  list tempList = list();
  //First, we are going to deal with our most hated guys: The Coefficients.
  dbprint(p,dbprintWhitespace + "We get all combinations for the coefficient of the
maximal homogeneous part");
  list coeffTuplesMax = getAllCoeffTuplesComb(factorizeInt(number(f1[1][1])));
  //We can assume without loss of generality, that p_max has a
  //nonnegative leading coefficient
  for (i = 1; i<=size(coeffTuplesMax);i++)
  {//Deleting all tuples with negative entries for p_max
    if (coeffTuplesMax[i][1]<0)
    {
      coeffTuplesMax = delete(coeffTuplesMax,i);
      continue;
    }
  }//Deleting all tuples with negative entries for p_max
  dbprint(p,dbprintWhitespace + "Done. The Combinations are:");
  dbprint(p,coeffTuplesMax);
  dbprint(p,dbprintWhitespace + "We get all combinations for the coefficient of the
minimal homogeneous part");
  list coeffTuplesMin = getAllCoeffTuplesComb(factorizeInt(number(f2[1][1])));
  dbprint(p,dbprintWhitespace + "Done. The Combinations are:");
  dbprint(p,coeffTuplesMin);
  //Now, we will be actually dealing with the Combinations.
  //Let's start with the pqmax
  if (size(f1[1]) == 1)
  {//the maximal homogeneous factor is a constant
    dbprint(p,dbprintWhitespace + "the maximal homogeneous factor is a constant.");
    pqmax = coeffTuplesMax;
  }//the maximal homogeneous factor is a constant
  else
  {//the maximal homogeneous factor is not a constant
    dbprint(p,dbprintWhitespace + "Deleting the first list entry in each list (constant factor).");
    for (i = 1; i<=size(f1); i++)
    {//We can forget about the first coefficient now. Therefore we will delete him from the list.
      f1[i] = delete(f1[i],1);
      if(size(f1[i])==1)
      {//trivial thing
        for (j = 1; j<=size(coeffTuplesMax); j++)
        {
          pqmax = pqmax + list(list(coeffTuplesMax[j][1],coeffTuplesMax[j][2]*f1[i][1]));
          pqmax = pqmax + list(list(coeffTuplesMax[j][1]*f1[i][1],coeffTuplesMax[j][2]));
        }
        f1 = delete(f1,i);
        continue;
      }//trivial thing
    }//We can forget about the first coefficient now. Therefore we will delete him from the list.
    dbprint(p,dbprintWhitespace + "Done.");
    dbprint(p,dbprintWhitespace + "Putting all possible pre-coefficients
 besides the entries in pqmax.");
    if (size(f1)>0)
    {
      tempList = getAllCombOfHomogFact(f1);
      for (i = 1; i<=size(tempList); i++)
      {//Every combination combined with the coefficient possibilities
        for (j = 1; j<=size(coeffTuplesMax); j++)
        {//iterating through the possible coefficient choices
          pqmax = pqmax + list(list(coeffTuplesMax[j][1]*tempList[i][1],
                                    coeffTuplesMax[j][2]*tempList[i][2]));
        }//iterating through the possible coefficient choices
      }//Every combination combined with the coefficient possibilities
      for (i = 1; i<=size(coeffTuplesMax); i++)
      {
        pqmax = pqmax + list(list(coeffTuplesMax[i][1],maxh/coeffTuplesMax[i][1]));
        pqmax = pqmax + list(list(maxh/coeffTuplesMax[i][2],coeffTuplesMax[i][2]));
      }
    }
    dbprint(p,dbprintWhitespace + "Done.");
  }//the maximal homogeneous factor is not a constant
  dbprint(p, dbprintWhitespace + "Doing the same for f2");
  //Now we go to pqmin
  if (size(f2[1]) == 1)
  {//the minimal homogeneous factor is a constant
    pqmin = coeffTuplesMin;
  }//the minimal homogeneous factor is a constant
  else
  {//the minimal homogeneous factor is not a constant
    for (i = 1; i<=size(f2); i++)
    {//We can forget about the first coefficient now. Therefore we will delete him from the list.
      f2[i] = delete(f2[i],1);
      if(size(f2[i])==1)
      {//trivial thing
        for (j = 1; j<=size(coeffTuplesMin); j++)
        {
          pqmin = pqmin + list(list(coeffTuplesMin[j][1],coeffTuplesMin[j][2]*f2[i][1]));
          pqmin = pqmin + list(list(coeffTuplesMin[j][1]*f2[i][1],coeffTuplesMin[j][2]));
        }
        f2 = delete(f2,i);
        continue;
      }
    }//We can forget about the first coefficient now. Therefore we will delete him from the list.
    if(size(f2)>0)
    {
      tempList = getAllCombOfHomogFact(f2);
      for (i = 1; i<=size(tempList); i++)
      {//Every combination combined with the coefficient possibilities
        for (j = 1; j<=size(coeffTuplesMin); j++)
        {//iterating through the possible coefficient choices
          pqmin = pqmin + list(list(coeffTuplesMin[j][1]*tempList[i][1],
                                    coeffTuplesMin[j][2]*tempList[i][2]));
        }//iterating through the possible coefficient choices
      }//Every combination combined with the coefficient possibilities
      for (i = 1; i<=size(coeffTuplesMin); i++)
      {
        pqmin = pqmin + list(list(coeffTuplesMin[i][1],minh/coeffTuplesMin[i][1]));
        pqmin = pqmin + list(list(minh/coeffTuplesMin[i][2],coeffTuplesMin[i][2]));
      }
    }
  }//the minimal homogeneous factor is not a constant
  dbprint(p,dbprintWhitespace + "Done.");
  //and now we combine them together to obtain all possibilities.
  for (i = 1; i<=size(pqmax); i++)
  {//iterate over the maximal homogeneous combination possibilities
    for (j = 1; j<=size(pqmin); j++)
    {//iterate over the minimal homogeneous combiniation possibilities
      if (degreeOfNthWeylPoly(pqmax[i][1])>=degreeOfNthWeylPoly(pqmin[j][1])
          and degreeOfNthWeylPoly(pqmax[i][2])>=degreeOfNthWeylPoly(pqmin[j][2]))
      {
        if (pqmax[i][1]+pqmin[j][1]!=0 and pqmax[i][2]+pqmin[j][2]!=0)
        {
          if (h-(pqmax[i][1]+pqmin[j][1])*(pqmax[i][2]+pqmin[j][2])==0)
          {
            /*REMARK:
              This part here is different from factoring the first Weyl algebra. As the output of
              degreeOfNthWeylPoly is in general an intvec instead of an int, we cannot say
              deg(0)=-1; Therefore, we need to catch the 0-case at this point, i.e.
              min and max homog are combined equal to h.
             */
            result = result +list(list(pqmax[i][1]+pqmin[j][1],pqmax[i][2]+pqmin[j][2]));
            j++;continue;
          }
          if (degreeOfNthWeylPoly(h)<=
              degreeOfNthWeylPoly(h-(pqmax[i][1]+pqmin[j][1])*(pqmax[i][2]+pqmin[j][2])))
          {
            j++;
            continue;
          }
          if (degreeOfNthWeylPolyInverted(h)<=
              degreeOfNthWeylPolyInverted(h-(pqmax[i][1]+pqmin[j][1])*(pqmax[i][2]+pqmin[j][2])))
          {
            j++;
            continue;
          }
          result = result +list(list(pqmax[i][1]+pqmin[j][1],pqmax[i][2]+pqmin[j][2]));
        }
      }
    }//iterate over the minimal homogeneous combiniation possibilities
  }//iterate over the maximal homogeneous combination possibilities
  //Now deleting double entries
  result = delete_duplicates_noteval_and_sort(result);
  return(result);
}//proc computeCombinationsMinMaxHomogNthWeyl


static proc test_computeCombinationsMinMaxHomogNthWeyl()
{//testing computeCombinationsMinMaxHomogNthWeyl
  int result = 1;
  //Test 1: Irreducible max and min homog
  ring R = 0,(x(1..4),d(1..4)),dp;
  def r = Weyl();
  setring r;
  poly input = d(1) + x(1);
  list expected = sortFactorizations(list(list(d(1) + 1,1+ x(1)),
                      list(1 + x(1),d(1) + 1),
                      list(d(1)-1, 1-x(1)),
                      list(1-x(1),d(1)-1)));
  list obtained =
    sortFactorizations(computeCombinationsMinMaxHomogNthWeyl(input));
  if (!isListEqual(expected,obtained))
  {
    print("Test 1 for computeCombinationsMinMaxHomogNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: reducible max and irreducible min homog
  input = d(1)*d(2) + x(1);
  expected = sortFactorizations(
    list(list(d(1) + x(1),d(2) + 1),
     list(d(1) + 1,d(2) + x(1)),
     list(d(2) + x(1),d(1) + 1),
     list(d(2) + 1, d(1) + x(1)),
     list(d(1)*d(2) + 1, 1 + x(1)),
     list(1 + x(1),d(1)*d(2) + 1),
     list(d(1) - x(1),d(2) - 1),
     list(d(1) - 1,d(2) - x(1)),
     list(d(2) - x(1),d(1) - 1),
     list(d(2) - 1, d(1) - x(1)),
     list(d(1)*d(2) - 1, 1 - x(1)),
     list(1 - x(1),d(1)*d(2) - 1)
      ));
  obtained =
    sortFactorizations(computeCombinationsMinMaxHomogNthWeyl(input));
  if (!isListEqual(expected,obtained))
  {
    print("Test 2 for computeCombinationsMinMaxHomogNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: irreducible max and reducible min homog
  input = d(1) + x(1)*x(2);
  expected = sortFactorizations(
    list(list(d(1) + x(1), 1 + x(2)),
     list(d(1) + 1, 1 + x(1)*x(2)),
     list(d(1) + x(2), 1 + x(1)),
     list(1 + x(1), d(1)+ x(2)),
     list(1 + x(1)*x(2), d(1) + 1),
     list(1 + x(2), d(1)+ x(1)),
     list(d(1) - x(1), 1 - x(2)),
     list(d(1) - 1, 1 - x(1)*x(2)),
     list(d(1) - x(2), 1 - x(1)),
     list(1 - x(1), d(1)- x(2)),
     list(1 - x(1)*x(2), d(1) - 1),
     list(1 - x(2), d(1)- x(1))
      ));
  obtained =
    sortFactorizations(computeCombinationsMinMaxHomogNthWeyl(input));
  if (!isListEqual(expected,obtained))
  {
    print("Test 3 for computeCombinationsMinMaxHomogNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: irreducible max and reducible min homog
  input = d(1)*d(2) + x(1)*x(2);
  expected = sortFactorizations(
    list(list(d(1) + x(1), d(2) + x(2)),
     list(d(1) + 1, d(2) + x(1)*x(2)),
     list(d(1) + x(2), d(2) + x(1)),
     list(d(1) + x(1)*x(2), d(2) +1),
     list(d(2) + x(1), d(1)+ x(2)),
     list(d(2) + x(1)*x(2), d(1) + 1),
     list(d(2) + x(2), d(1)+ x(1)),
     list(d(2) + 1, d(1)+ x(1)*x(2)),
     list(d(1)*d(2) + x(1), 1 + x(2)),
     list(d(1)*d(2) + 1, 1 + x(1)*x(2)),
     list(d(1)*d(2) + x(2), 1 + x(1)),
     list(1 + x(1), d(1)*d(2)+ x(2)),
     list(1 + x(1)*x(2), d(1)*d(2) + 1),
     list(1 + x(2), d(1)*d(2)+ x(1)),
     list(d(1) - x(1), d(2) - x(2)),
     list(d(1) - 1, d(2) - x(1)*x(2)),
     list(d(1) - x(2), d(2) - x(1)),
     list(d(2) - x(1), d(1)- x(2)),
     list(d(2) - x(1)*x(2), d(1) - 1),
     list(d(2) - x(2), d(1)- x(1)),
     list(d(1)*d(2) - x(1), 1 - x(2)),
     list(d(1)*d(2) - 1, 1 - x(1)*x(2)),
     list(d(1)*d(2) - x(2), 1 - x(1)),
     list(1 - x(1), d(1)*d(2)- x(2)),
     list(1 - x(1)*x(2), d(1)*d(2) - 1),
     list(1 - x(2), d(1)*d(2)- x(1)),
     list(d(2) - 1, d(1)- x(1)*x(2)),
     list(d(1) - x(1)*x(2), d(2) -1)
      ));
  obtained =
    sortFactorizations(computeCombinationsMinMaxHomogNthWeyl(input));
  if (!isListEqual(expected,obtained))
  {
    print("Test 4 for computeCombinationsMinMaxHomogNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 5: Non-trivial coefficients
  input = 6*d(1) + 4*x(1);
  expected = sortFactorizations(
    list(
      list(6*d(1) + 4, 1 + x(1)  ),
      list(6*d(1) + 2, 1 + 2*x(1)),
      list(6*d(1) + 1, 1 + 4*x(1)),
      list(3*d(1) + 4, 2 + x(1)  ),
      list(3*d(1) + 2, 2 + 2*x(1)),
      list(3*d(1) + 1, 2 + 4*x(1)),
      list(2*d(1) + 4, 3 + x(1)  ),
      list(2*d(1) + 2, 3 + 2*x(1)),
      list(2*d(1) + 1, 3 + 4*x(1)),
      list(d(1)   + 4, 6 + x(1)  ),
      list(d(1)   + 2, 6 + 2*x(1)),
      list(d(1)   + 1, 6 + 4*x(1)),
      list(1 + x(1)  ,6*d(1) + 4),
      list(1 + 2*x(1),6*d(1) + 2),
      list(1 + 4*x(1),6*d(1) + 1),
      list(2 + x(1)  ,3*d(1) + 4),
      list(2 + 2*x(1),3*d(1) + 2),
      list(2 + 4*x(1),3*d(1) + 1),
      list(3 + x(1)  ,2*d(1) + 4),
      list(3 + 2*x(1),2*d(1) + 2),
      list(3 + 4*x(1),2*d(1) + 1),
      list(6 + x(1)  ,d(1)   + 4),
      list(6 + 2*x(1),d(1)   + 2),
      list(6 + 4*x(1),d(1)   + 1),
      list(6*d(1) - 4, 1 - x(1)  ),
      list(6*d(1) - 2, 1 - 2*x(1)),
      list(6*d(1) - 1, 1 - 4*x(1)),
      list(3*d(1) - 4, 2 - x(1)  ),
      list(3*d(1) - 2, 2 - 2*x(1)),
      list(3*d(1) - 1, 2 - 4*x(1)),
      list(2*d(1) - 4, 3 - x(1)  ),
      list(2*d(1) - 2, 3 - 2*x(1)),
      list(2*d(1) - 1, 3 - 4*x(1)),
      list(d(1)   - 4, 6 - x(1)  ),
      list(d(1)   - 2, 6 - 2*x(1)),
      list(d(1)   - 1, 6 - 4*x(1)),
      list(1 - x(1)  ,6*d(1) - 4),
      list(1 - 2*x(1),6*d(1) - 2),
      list(1 - 4*x(1),6*d(1) - 1),
      list(2 - x(1)  ,3*d(1) - 4),
      list(2 - 2*x(1),3*d(1) - 2),
      list(2 - 4*x(1),3*d(1) - 1),
      list(3 - x(1)  ,2*d(1) - 4),
      list(3 - 2*x(1),2*d(1) - 2),
      list(3 - 4*x(1),2*d(1) - 1),
      list(6 - x(1)  ,d(1)   - 4),
      list(6 - 2*x(1),d(1)   - 2),
      list(6 - 4*x(1),d(1)   - 1)
      ));
  obtained =
    sortFactorizations(computeCombinationsMinMaxHomogNthWeyl(input));
  if (!isListEqual(expected,obtained))
  {
    print("Test 5 for computeCombinationsMinMaxHomogNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing computeCombinationsMinMaxHomogNthWeyl


static proc getAllCombOfHomogFact(list l)
"Gets called in computeCombinationsMinMaxHomog. It gets a list of different homogeneous
factorizations of
one homogeneous polynomial and returns the possibilities to combine them into two factors.
Assumptions:
- The list does not contain the first coefficient.
- The list contains at least one list with two elements."
{//proc getAllCombOfHomogFact
  list result;
  list leftAndRightHandSides;
  int i; int j;
  list tempset;
  if (size(l)==1 and size(l[1])==2)
  {
    result = result + list(list(l[1][1],l[1][2]));
    return(result);
  }
  leftAndRightHandSides = getPossibilitiesForRightSides(l);
  for (i = 1; i<=size(leftAndRightHandSides); i++)
  {
    result =result+list(list(leftAndRightHandSides[i][1],product(leftAndRightHandSides[i][2][1])));
    //tidy up the right hand sides, because, if it is just one irreducible factor, we are done
    for (j = 1; j<=size(leftAndRightHandSides[i][2]);j++)
    {//Tidy up right hand sides
      if (size(leftAndRightHandSides[i][2][j])<2)
      {//Element can be dismissed
        leftAndRightHandSides[i][2] = delete(leftAndRightHandSides[i][2],j);
        continue;
      }//Element can be dismissed
    }//Tidy up right hand sides
    if (size(leftAndRightHandSides[i][2])>0)
    {
      tempset = getAllCombOfHomogFact(leftAndRightHandSides[i][2]);
      for (j = 1; j<=size(tempset);j++)
      {//multiplying the first factor with the left hand side
        result = result + list(list(leftAndRightHandSides[i][1]*tempset[j][1],tempset[j][2]));
      }//multiplying the first factor with the left hand side
    }
  }
  return(delete_duplicates_noteval_and_sort(result));
}//proc getAllCombOfHomogFact


static proc test_getAllCombOfHomogFact()
{//testing getAllCombOfHomogFact
  int result = 1;
  ring R = 0,(x(1..4),d(1..4)),dp;
  def r = Weyl();
  setring r;
  //Test 1: One list in the list, trivial elements
  list input = list(list(x(1),d(1)));
  list expected = list(list(x(1),d(1)));
  list obtained = getAllCombOfHomogFact(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 1 for getAllCombOfHomogFact failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: One factorization, more than two elements
  input = list(list(x(1),d(1)+5,x(1)));
  expected = sortFactorizations(
    list(list(x(1)*(d(1)+5),x(1)),
     list(x(1),(d(1)+5)*x(1))));
  obtained = getAllCombOfHomogFact(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 2 for getAllCombOfHomogFact failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: More than one factorization
  input = list(
    list(d(2),x(1)*d(1)+3,x(2),d(2),x(2)),
    list(d(2),x(2),d(2),x(1)*d(1)+3,x(2)),
    list(d(2),x(2),d(2),x(2),x(1)*d(1)+3),
    list(d(2),x(2),x(1)*d(1)+3,d(2),x(2)),
    list(x(1)*d(1)+3,d(2),x(2),d(2),x(2))
    );
  expected = delete_duplicates_noteval_and_sort(
    list(
      list(d(2),(x(1)*d(1)+3)*x(2)*d(2)*x(2)),
      list(x(1)*d(1)+3,d(2)*x(2)*d(2)*x(2)),
      list(d(2)*(x(1)*d(1)+3),x(2)*d(2)*x(2)),
      list(d(2)*x(2),d(2)*(x(1)*d(1)+3)*x(2)),
      list((x(1)*d(1)+3)*d(2),x(2)*d(2)*x(2)),
      list(d(2)*(x(1)*d(1)+3)*x(2),d(2)*x(2)),
      list(d(2)*x(2)*d(2),(x(1)*d(1)+3)*x(2)),
      list(d(2)*x(2)*(x(1)*d(1)+3),d(2)*x(2)),
      list((x(1)*d(1)+3)*d(2)*x(2),d(2)*x(2)),
      list(d(2)*(x(1)*d(1)+3)*x(2)*d(2),x(2)),
      list(d(2)*x(2)*d(2)*x(2),x(1)*d(1)+3))
      );
  obtained =getAllCombOfHomogFact(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 3 for getAllCombOfHomogFact failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing getAllCombOfHomogFact


static proc getPossibilitiesForRightSides(list l)
"Given a list of different factorizations l, this function returns a list of the form
(a,{(a_2,...,a_n)| (a,a_2,...,a_n) in A})"
{//getPossibilitiesForRightSides
  list templ = l;
  list result;
  poly firstElement;
  list rightSides;
  list tempRightSide;
  int i; int j;
  while (size(templ)>0)
  {
    firstElement = templ[1][1];
    rightSides = list();
    for (i = 1; i<= size(templ); i++)
    {
      if (templ[i][1] == firstElement)
      {//save the right sides
        tempRightSide = list();
        for (j = 2; j<=size(templ[i]);j++)
        {
          tempRightSide = tempRightSide + list(templ[i][j]);
        }
        if (size(tempRightSide)!=0)
        {
          rightSides = rightSides + list(tempRightSide);
        }
        templ = delete(templ,i);
        continue;
      }//save the right sides
    }
    result = result + list(list(firstElement,rightSides));
  }
  return(result);
}//getPossibilitiesForRightSides


static proc test_getPossibilitiesForRightSides()
{//testing getPossibilitiesForRightSides
  int result = 1;
  ring R = 0,(x(1..4),d(1..4)),dp;
  def r = Weyl();
  setring r;
  //Test 1: One list in the list, trivial elements
  list input = list(list(x(1),d(1)));
  list expected = list(list(x(1),list(list(d(1)))));
  list obtained = getPossibilitiesForRightSides(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 1 for getPossibilitiesForRightSides failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
    //Test 2: One factorization, more than two elements
  input = list(list(x(1),d(1)+5,x(1)));
  expected = sortFactorizations(
    list(
      list(x(1),list(list(d(1)+5,x(1)))))
    );
  obtained = sortFactorizations(
    getPossibilitiesForRightSides(input));
  if (!isListEqual(expected,obtained))
  {
    print("Test 2 for getPossibilitiesForRightSides failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: More than one factorization
  input = list(
    list(d(2),x(1)*d(1)+3,x(2),d(2),x(2)),
    list(d(2),x(2),d(2),x(1)*d(1)+3,x(2)),
    list(d(2),x(2),d(2),x(2),x(1)*d(1)+3),
    list(d(2),x(2),x(1)*d(1)+3,d(2),x(2)),
    list(x(1)*d(1)+3,d(2),x(2),d(2),x(2))
    );
  expected = delete_duplicates_noteval_and_sort(
    list(list(d(2),list(
        list(x(1)*d(1)+3,x(2),d(2),x(2)),
        list(x(2),d(2),x(1)*d(1)+3,x(2)),
        list(x(2),d(2),x(2),x(1)*d(1)+3),
        list(x(2),x(1)*d(1)+3,d(2),x(2))
        )),
     list(x(1)*d(1)+3,list(list(d(2),x(2),d(2),x(2))))
      )
      );
  obtained = sortFactorizations(
    getPossibilitiesForRightSides(input));
  if (!isListEqual(expected,obtained))
  {
    print("Test 3 for getPossibilitiesForRightSides failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing getPossibilitiesForRightSides


static proc homogDistributionNthWeyl(poly h)
"
INPUT: A polynomial in the n-th Weyl algebra
OUTPUT: A two-dimensional list of the following form. Every sublist contains exactly two entries.
   One for the Z^n-degree of the corresponding homogeneous part (intvec), and the homogeneous
   polynomial itself, and those sublists are oredered by ascending degree using lexicographical
   ordering on Z^n. Different from homogDistribution, the 0-summands between the maximum and
   minimum homogeneous degree are not displayed.
   For example a call of homogDistribution(x1+d2+1) would have the output (ring is the second
   weyl algebra with variables x1,x2,d1,d2).
     [1]:
       [1]:
         [0,1]
       [2]:
         d2
     [2]:
       [1]:
         [0,0]
       [2]:
         1
     [3]:
       [1]:
         [-1,0]
       [2]:
         x1

GENERAL ASSUMPTIONS:
 - The basering is the nth Weyl algebra and has the form, that the first n variables represent
   x1, ..., xn, and the second n variables do represent the d1, ..., dn.
"
{//proc homogDistributionNthWeyl
  if (h == 0)
  {//trivial case where input is 0
    return(list(list(0:(nvars(basering) div 2),0)));
  }//trivial case where input is 0
  list result;
  poly tempH = h;
  intvec degVec;
  poly leadPoly;
  while(tempH != 0)
  {//tempH is not equal to zero ==> We have still unconsidered homogeneous summands
    leadPoly = extractLeadingTermOfNthWeylPoly(tempH);
    degVec   = degreeOfNthWeylPoly(tempH);
    result = insert(result,list(degVec,leadPoly));
    tempH = tempH - leadPoly;
  }//tempH is not equal to zero ==> We have still unconsidered homogeneous summands
  return(result);
}//proc homogDistributionNthWeyl


static proc test_homogDistributionNthWeyl()
{//testing homogDistributionNthWeyl
  int result = 1;
  ring R = 0,(x(1..5),d(1..5)),dp;
  //Test 1: 0
  poly input = 0;
  list expected = list(list(0:5,0));
  list obtained = homogDistributionNthWeyl(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 1 for homogDistributionNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: Any constant
  input = 5/8;
  expected = list(list(0:5,poly(5/8)));
  obtained = homogDistributionNthWeyl(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 2 for homogDistributionNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: one operator, monomial
  input = x(1)^5;
  expected = list(list(intvec(-5,0,0,0,0),x(1)^5));
  obtained = homogDistributionNthWeyl(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 3 for homogDistributionNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: one operator, polynomial
  input = x(5)^5 + d(5)^2 + 1;
  expected = list(list(intvec(0,0,0,0,-5),x(5)^5),
          list(0:5,poly(1)),
          list(intvec(0,0,0,0,2),d(5)^2));
  obtained = homogDistributionNthWeyl(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 4 for homogDistributionNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 5: Multivariate Polynomial ring, polynomial
  input = x(1)^5 + x(2)*d(4)^3 - 1 - x(3)^2*x(1)*d(3)^2;
  expected = list(list(intvec(-5,0,0,0,0),x(1)^5),
          list(intvec(-1,0,0,0,0),- x(3)^2*x(1)*d(3)^2),
          list(intvec(0,-1,0,3,0),x(2)*d(4)^3),
          list(0:5,poly(-1))
    );
  obtained = homogDistributionNthWeyl(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 5 for homogDistributionNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing homogDistributionNthWeyl


static proc extractLeadingTermOfNthWeylPoly(poly h)
"
INPUT:  A polynomial h in the nth Weyl algebra.
OUTPUT: A polynomial p representing the homogeneous leading polynomial of h with respect
        to the -1,1 grading on the polynomial nth weyl algebra.

GENERAL ASSUMPTIONS:
 - The ring given is the nth Weyl algebra and has the form, that the first n variables represent
   x1, ..., xn, and the second n variables do represent the d1, ..., dn.
"
{//extractLeadingTermOfNthWeylPoly
  poly result = 0;
  intvec leadDeg = degreeOfNthWeylPoly(h);
  int i; int j;
  int isPart = 0;
  intvec lExp;
  for (i = 1; i <=size(h); i++)
  {//iterating through the terms of h
    isPart = 1;
    lExp = leadexp(h[i]);
    for (j = 1; j<=nvars(basering) div 2; j++)
    {//checking if the term is part of the leading polynomial
      if(lExp[j + nvars(basering) div 2] - lExp[j] != leadDeg[j])
      {//Summand was not part of leading polynomial
        isPart = 0;
        break;
      }//Summand was not part of leading polynomial
    }//checking if the term is part of the leading degree
    if (!isPart)
    {i++; continue;}
    else
    {//In this case, h[i] was part of the leading polynomial
      result = result + h[i];
    }//In this case, h[i] was part of the leading polynomial
  }//iterating through the terms of h
  return(result);
}//extractLeadingTermOfNthWeylPoly


static proc test_extractLeadingTermOfNthWeylPoly()
{//testing extractLeadingTermOfNthWeylPoly
  int result = 1;
  ring R = 0,(x(1..3),d(1..3)),dp;
  def r = Weyl();
  setring(r);
  //Test 1: 0
  poly input = 0;
  poly expected = 0;
  poly obtained = extractLeadingTermOfNthWeylPoly(input);
  if (expected!=obtained)
  {
    print("Test 1 for extractLeadingTermOfNthWeylPoly failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: Monomial
  input = x(3);
  expected = x(3);
  obtained = extractLeadingTermOfNthWeylPoly(input);
  if (expected!=obtained)
  {
    print("Test 2 for extractLeadingTermOfNthWeylPoly failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: Random polynomial
  input = x(1)*x(2)*d(1)*d(2) +
    x(1)^4*x(2)^2*x(3)^3*d(1)^4*d(2)^2*d(3)^3 + 1 +
    x(1) + x(2) + x(3);
  expected =
    x(1)^4*x(2)^2*x(3)^3*d(1)^4*d(2)^2*d(3)^3+x(1)*x(2)*d(1)*d(2)+1;
  obtained = extractLeadingTermOfNthWeylPoly(input);
  if (expected!=obtained)
  {
    print("Test 3 for extractLeadingTermOfNthWeylPoly failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: Another random polynomial
  input = (x(1)*d(1))^5;
  expected
  =x(1)^5*d(1)^5+10*x(1)^4*d(1)^4+25*x(1)^3*d(1)^3+
    15*x(1)^2*d(1)^2+x(1)*d(1);
  obtained = extractLeadingTermOfNthWeylPoly(input);
  if (expected!=obtained)
  {
    print("Test 4 for extractLeadingTermOfNthWeylPoly failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing extractLeadingTermOfNthWeylPoly


static proc degreeOfNthWeylPoly(poly h)
"
INPUT: A polynomial h in the nth Weyl algebra
OUTPUT: An intvector of size n, representing the degree of h with respect to
        the lexicographical ordering on ZZ^n by considering the -1,1 grading
        on the nth Weyl algebra.

GENERAL ASSUMPTIONS:
 - The ring given is the nth Weyl algebra and has the form, that the first n variables represent
   x1, ..., xn, and the second n variables do represent the d1, ..., dn.
"
{//degreeOfNthWeylPoly
  intvec result = 0:(nvars(basering) div 2);
  int i; int j; int k;
  int alreadySmaller;
  intvec expVec;
  intvec posUpdated= 0:(nvars(basering) div 2);
  for(i = 1; i<=nvars(basering) div 2; i++)
  {//Going through every variable to determine the max. term
    for (j = 1; j <= size(h); j++)
    {//Iterating over every term in h
      alreadySmaller = 0;
      for (k = 1; k<i; k++)
      {//checking if h[j] is already smaller considering the higher order variables
        expVec = leadexp(h[j]);
        if (expVec[k+nvars(basering) div 2] - expVec[k] < result[k])
        {//This monomial has no chance to be part of the leading monomial
          alreadySmaller = 1;
          break;
        }//This monomial has no chance to be part of the leading monomial
      }//checking if h[j] is already smaller considering the higher order variables
      if (alreadySmaller)
      {j++; continue;}
      expVec = leadexp(h[j]);
      k = expVec[nvars(basering) div 2 + i] - expVec[i];
      if(!posUpdated[i])
      {//update of result
        result[i] = k;
        posUpdated[i] = 1;
      }//update of result
      else
      {//update the result only if position is smaller
        if (result[i]<k)
        {//We have a new maximal entry
          result[i] = k;
        }//We have a new maximal entry
      }//update the result only if position is smaller
    }//Iterating over every term in h
  }//Going through every variable to determine the max. term
  return(result);
}//degreeOfNthWeylPoly


static proc test_degreeOfNthWeylPoly()
{//testing degreeOfNthWeylPoly
  int result = 1;
  ring R = 0,(x1,x2,x3,d1,d2,d3),dp;
  def r = Weyl();
  setring r;
  //Test 1: 0
  poly input = 0;
  intvec expected = 0:3;
  intvec obtained = degreeOfNthWeylPoly(input);
  if (expected!=obtained)
  {
    print("Test 1 for degreeOfNthWeylPoly failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: Random wild polynomial
  input = x1^5 + d1 + x1*d2 + d1*d2;
  expected = intvec(1,1,0);
  obtained = degreeOfNthWeylPoly(input);
  if (expected!=obtained)
  {
    print("Test 2 for degreeOfNthWeylPoly failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: 1
  input = 1;
  expected = 0:3;
  obtained = degreeOfNthWeylPoly(input);
  if (expected!=obtained)
  {
    print("Test 3 for degreeOfNthWeylPoly failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: monomial deg 0, first var
  input = x1*d1;
  expected = 0:3;
  obtained = degreeOfNthWeylPoly(input);
  if (expected!=obtained)
  {
    print("Test 4 for degreeOfNthWeylPoly failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 5: monomial deg 0, second var
  input = x2*d2;
  expected = 0:3;
  obtained = degreeOfNthWeylPoly(input);
  if (expected!=obtained)
  {
    print("Test 5 for degreeOfNthWeylPoly failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 6: monomial deg 0, last var
  input = x3*d3;
  expected = 0:3;
  obtained = degreeOfNthWeylPoly(input);
  if (expected!=obtained)
  {
    print("Test 5 for degreeOfNthWeylPoly failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing degreeOfNthWeylPoly

/*
h = x3*d3;
degreeOfNthWeylPoly(h);
==> 0,0,0
 */

static proc degreeOfNthWeylPolyInverted(poly h)
"
INPUT: A polynomial h in the nth Weyl algebra
OUTPUT: An intvector of size n, representing the degree of h with respect to
        the lexicographical ordering on ZZ^n by considering the 1,-1 grading
        on the nth Weyl algebra.

GENERAL ASSUMPTIONS:
 - The ring given is the nth Weyl algebra and has the form, that the first n variables represent
   x1, ..., xn, and the second n variables do represent the d1, ..., dn.
"
{//degreeOfNthWeylPolyInverted
  intvec result = 0:(nvars(basering) div 2);
  int i; int j; int k;
  int alreadySmaller;
  intvec expVec;
  intvec posUpdated= 0:(nvars(basering) div 2);
  for(i = 1; i<=nvars(basering) div 2; i++)
  {//Going through every variable to determine the max. term
    for (j = 1; j <= size(h); j++)
    {//Iterating over every term in h
      alreadySmaller = 0;
      for (k = 1; k<i; k++)
      {//checking if h[j] is already smaller considering the higher order variables
        expVec = leadexp(h[j]);
        if (-expVec[k+nvars(basering) div 2] + expVec[k] < result[k])
        {//This monomial has no chance to be part of the leading monomial
          alreadySmaller = 1;
          break;
        }//This monomial has no chance to be part of the leading monomial
      }//checking if h[j] is already smaller considering the higher order variables
      if (alreadySmaller)
      {j++; continue;}
      expVec = leadexp(h[j]);
      k = -expVec[nvars(basering) div 2 + i] + expVec[i];
      if(!posUpdated[i])
      {//update of result
        result[i] = k;
        posUpdated[i] = 1;
      }//update of result
      else
      {//update the result only if position is smaller
        if (result[i]<k)
        {//We have a new maximal entry
          result[i] = k;
        }//We have a new maximal entry
      }//update the result only if position is smaller
    }//Iterating over every term in h
  }//Going through every variable to determine the max. term
  return(result);
}//degreeOfNthWeylPolyInverted


static proc test_degreeOfNthWeylPolyInverted()
{//testing degreeOfNthWeylPolyInverted
  int result = 1;
  ring R = 0,(x1,x2,x3,d1,d2,d3),dp;
  def r = Weyl();
  setring r;
  //Test 1: 0
  poly input = 0;
  intvec expected = 0:3;
  intvec obtained = degreeOfNthWeylPolyInverted(input);
  if (expected!=obtained)
  {
    print("Test 1 for degreeOfNthWeylPolyInverted failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: Random wild polynomial
  input = x1^5 + d1 + x1*d2 + d1*d2;
  expected = intvec(5,0,0);
  obtained = degreeOfNthWeylPolyInverted(input);
  if (expected!=obtained)
  {
    print("Test 2 for degreeOfNthWeylPolyInverted failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: 1
  input = 1;
  expected = 0:3;
  obtained = degreeOfNthWeylPolyInverted(input);
  if (expected!=obtained)
  {
    print("Test 3 for degreeOfNthWeylPolyInverted failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: monomial deg 0, first var
  input = x1*d1;
  expected = 0:3;
  obtained = degreeOfNthWeylPolyInverted(input);
  if (expected!=obtained)
  {
    print("Test 4 for degreeOfNthWeylPolyInverted failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 5: monomial deg 0, second var
  input = x2*d2;
  expected = 0:3;
  obtained = degreeOfNthWeylPolyInverted(input);
  if (expected!=obtained)
  {
    print("Test 5 for degreeOfNthWeylPolyInverted failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 6: monomial deg 0, last var
  input = x3*d3;
  expected = 0:3;
  obtained = degreeOfNthWeylPolyInverted(input);
  if (expected!=obtained)
  {
    print("Test 5 for degreeOfNthWeylPolyInverted failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing degreeOfNthWeylPolyInverted


static proc homogwithorderNthWeyl(poly h)
"
INPUT: A polynomial h in the nth Weyl algebra
OUTPUT: Determines whether the given polynomial is homogeneous with respect to
        the -1,1 order on the nth Weyl algebra. If so, the function returns 1,
        if not, it returns 0.

GENERAL ASSUMPTIONS:
 - The basering is the nth Weyl algebra and has the form, that the first n variables represent
   x1, ..., xn, and the second n variables do represent the d1, ..., dn.
"
{//homogwithorderNthWeyl
  poly temp = extractLeadingTermOfNthWeylPoly(h);
  if (h!=temp)
  {//In this case, h has more than one homogeneous summand
    return(0);
  }//In this case, h has more than one homogeneous summand
  else
  {//Our polynomial was homogeneous
    return(1);
  }//Our polynomial was homogeneous
}//homogwithorderNthWeyl


static proc test_homogwithorderNthWeyl()
{//testing homogwithorderNthWeyl
  int result = 1;
  ring R = 0,(f,g,h,z,d,w),dp;
  def r = Weyl();
  setring r;
  //Test 1: 0
  poly input = 0;
  int expected = 1;
  int obtained = homogwithorderNthWeyl(input);
  if (expected!=obtained)
  {
    print("Test 1 for homogwithorderNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: Random constant
  input = 7893/239073;
  expected = 1;
  obtained = homogwithorderNthWeyl(input);
  if (expected!=obtained)
  {
    print("Test 2 for homogwithorderNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: Single variable
  input = z;
  expected = 1;
  obtained = homogwithorderNthWeyl(input);
  if (expected!=obtained)
  {
    print("Test 3 for homogwithorderNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: homogeneous
  input = z*f + 5*g*d + 1;
  expected = 1;
  obtained = homogwithorderNthWeyl(input);
  if (expected!=obtained)
  {
    print("Test 4 for homogwithorderNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 5: inhomogeneous
  input = f + g + h + z+ d+ w;
  expected = 0;
  obtained = homogwithorderNthWeyl(input);
  if (expected!=obtained)
  {
    print("Test 5 for homogwithorderNthWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing homogwithorderNthWeyl


static proc isInWeylSubAlg(poly h)
"USAGE: isinWeylSubAlg(h); h is a polynomial.
RETURN: bool
PURPOSE: This function figures out if there is a subalgebra of the
         current ring that resembles a Weyl algebra, and if h depends
     only on the variables of the Weyl algebra.
SEE ALSO: facSubWeyl, ncfactor
"{//proc isInWeylSubAlg
  int p=printlevel-voice+2; // for dbprint
  string dbprintWhitespace = "";
  int i;
  int j;
  for (i = 1; i<=voice;i++)
  {dbprintWhitespace = dbprintWhitespace + " ";}
  dbprint(p,dbprintWhitespace+"Checking if given ring is commutative.");
  if (size(ring_list(basering))<=4)
  {//basering was commutative
    return(0);
  }//basering was commutative
  dbprint(p,dbprintWhitespace+"Given ring was non-commutative.");
  dbprint(p,dbprintWhitespace+"Checking if h is in subalgebra that is Weyl.");
  ideal depVars = variables(h);
  int isXorD;
  for (i =1; i<=size(depVars); i++)
  {//Going through all dependent variables
    isXorD = 0;
    for (j=1;j<=nvars(basering);j++)
    {//checking if commuting rule exists
      if ((depVars[i]*var(j) - var(j)*depVars[i]==1) ||
      (depVars[i]*var(j) - var(j)*depVars[i]==-1))
      {//depVars[i] is part of some weyl relation
    isXorD = 1;
    break;
      }//depVars[i] is part of some weyl relation
    }//checking if commuting rule exists
    if (!isXorD)
    {//there was a variable that was neither an x nor a d
      return(0);
    }//there was a variable that was neither an x nor a d
  }//Going through all dependent variables
  return(1);
}//proc isInWeylSubAlg


static proc test_isInWeylSubAlg()
{//testing isInWeylSubAlg
  int result = 1;
  //Test 1: Commutative ring
  ring R = 0,(x,d),dp;
  poly input = x^2*d + d^2*x + 4;
  int expected = 0;
  int obtained = isInWeylSubAlg(input);
  if (expected!=obtained)
  {
    print("Test 1 for isInWeylSubAlg failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill R;
  //Test 2: First Weyl
  ring R = 0,(x,d),dp;
  def r = Weyl();
  setring r;
  poly input = x^2*d + d^2*x + 4;
  expected = 1;
  obtained = isInWeylSubAlg(input);
  if (expected!=obtained)
  {
    print("Test 2 for isInWeylSubAlg failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill R; kill r;
  //Test 3: First Weyl
  ring R = 0,(x,d),dp;
  def r = Weyl();
  setring r;
  poly input = x^2*d + d^2*x + 4;
  expected = 1;
  obtained = isInWeylSubAlg(input);
  if (expected!=obtained)
  {
    print("Test 3 for isInWeylSubAlg failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill R; kill r;
  //Test 4: third weyl
  ring R = 0,(k,p,m,g,d,a),dp;
  def r = Weyl();
  setring r;
  poly input = a*d^2+5*g*m^3+2;
  expected = 1;
  obtained = isInWeylSubAlg(input);
  if (expected!=obtained)
  {
    print("Test 4 for isInWeylSubAlg failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill R; kill r;
  //Test 5: third weyl with other ring, input in weyl sub
  ring R = 0,(k,p,m,g,d,a),dp;
  def r = Weyl();
  ring R2 = 0,(s,n),dp;
  def r2 = nc_algebra(1,s);
  def W = r + r2;
  setring W;
  poly input = a*d^2+5*g*m^3+2;
  expected = 1;
  obtained = isInWeylSubAlg(input);
  if (expected!=obtained)
  {
    print("Test 5 for isInWeylSubAlg failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill R; kill r; kill R2; kill r2; kill W;
  //Test 6: third weyl with other ring, input not in weyl sub
  ring R = 0,(k,p,m,g,d,a),dp;
  def r = Weyl();
  ring R2 = 0,(s,n),dp;
  def r2 = nc_algebra(1,s);
  def W = r + r2;
  setring W;
  poly input = a*d^2+5*g*m^3+2*s;
  expected = 0;
  obtained = isInWeylSubAlg(input);
  if (expected!=obtained)
  {
    print("Test 6 for isInWeylSubAlg failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill R; kill r; kill R2; kill r2; kill W;
  return(result);
}//testing isInWeylSubAlg


proc facSubWeyl(poly h, list #)
"USAGE: facSubWeyl(h,[x_1,...,x_n,d_1,...,d_n]); h is a polynomial,
        x_i, d_i are variables in the basering for i in {1,...,n}
RETURN: list(list)
ASSUME: x_i, d_i are variables of a basering with d_i*x_i = x_i*d_i+1
        for i in {1,...,n}.
@* That is,  they generate the copy of the first Weyl algebra in a basering.
@* Moreover, h is a polynomial in the x_i,d_i only.
@* If the list of variables is ommitted, this function will try to
   figure out itself if h is in a subalgebra that resembles the Weyl
   algebra.
@* This function produces an error if the conditions on the variables
   do not line up or if the variables contained in h do not belong to
   a subalgebra of the basering that resembles the Weyl algebra.
PURPOSE: compute factorizations of the polynomial, depending on x_i
         and d_i.
EXAMPLE: example facSubWeyl; shows examples
SEE ALSO: facFirstWeyl, testNCfac, facFirstShift
"{
  int p=printlevel-voice+2; // for dbprint
  string dbprintWhitespace = "";
  int i;
  int j;
  for (i = 1; i<=voice;i++)
  {dbprintWhitespace = dbprintWhitespace + " ";}
  dbprint(p," Start initial Checks of the input.");
  // basering can be anything having a Weyl algebra as subalgebra
  def @r = basering;
  list inpList;
  list sortedInp;
  //We begin to check the input for assumptions
  if (size(#)>0)
  {//User provided list of variables
    dbprint(p,dbprintWhitespace + "The user provided the list of
variables. Performing sanity checks on the list:");
    dbprint(p,dbprintWhitespace+"Is list of even length?");
    if (size(#)%2!=0)
    {//size of provided variables was not even, error.
      ERROR("list of provided variables was not even.");
    }//size of provided variables was not even, error.
    dbprint(p,dbprintWhitespace+"Yes, it is.");
    dbprint(p,dbprintWhitespace+"Does it contain variables that have
the desired non-commutative relations?");
    for(i=1;i<=size(#);i++)
    {//checking each list entry if it is a variable in the basering
      if(size(variables(#[i]))>1 || size(#[i])!=1 || deg(#[i])!=1)
      {//The provided list contained a non-variable
    ERROR("The provided list of variables contained non-variable entries.");
      }//The provided list contained a non-variable
    }//checking each list entry if it is a variable in the basering
    list tempInpList = #;
    int isXorD =0;
    for (i = 1; i<=size(tempInpList);i++)
    {//checking if the commutation rule is fulfilled
      isXorD=0;
      for (j=i+1;j<=size(tempInpList);j++)
      {
    if((tempInpList[i]*tempInpList[j]-tempInpList[j]*tempInpList[i]==1)||
       (tempInpList[j]*tempInpList[i]-tempInpList[i]*tempInpList[j]==1))
    {
      if(tempInpList[i]*tempInpList[j]-tempInpList[j]*tempInpList[i]==1)
      {
        inpList = insert(inpList,tempInpList[i],size(inpList)
                 div 2);
        inpList = insert(inpList,tempInpList[j],0);
      }
      if(tempInpList[j]*tempInpList[i]-tempInpList[i]*tempInpList[j]==1)
      {
        inpList = insert(inpList,tempInpList[j],size(inpList)
                 div 2);
        inpList = insert(inpList,tempInpList[i],0);
      }
      tempInpList = delete(tempInpList,j);
      tempInpList = delete(tempInpList,i);
      isXorD = 1;
      break;
    }
      }
      if(!isXorD)
      {
    ERROR("Variable "+string(tempInpList[i])+" does not have any
other variable in the list, for which a Weyl commutation
rule holds.");
      }
      continue;
    }//checking if the commutation rule is fulfilled
    dbprint(p,dbprintWhitespace+"Yes, it is.");
    dbprint(p,dbprintWhitespace+"Last check: Is h only dependent on
 the variables in the list?");
    sortedInp = sort(#)[1];
    ideal depVars = variables(h);
    for (i = 1; i<=size(depVars); i++)
    {//checking if each dependent variables is in the sortedInp list
      if (binarySearch(sortedInp,depVars[i])==0)
      {//h depended on a variable that was not in the dependency list
        ERROR("h depended on a variable that was not in the provided list");
      }//h depended on a variable that was not in the dependency list
    }//checking if each dependent variables is in the sortedInp list
    dbprint(p,dbprintWhitespace+"Yes it is. The input is fine then.");
//    inpList = #;
  }//User provided list of variables
  else
  {//User did not provide list of variables
    dbprint("The user did not provide a list of variables. Trying to
determine if h lies in a subalgebra that resembles the Weyl
algebra.");
    ideal depVars = variables(h);
    int isXorD = 0;
    for (i = 1; i<=size(depVars); i++)
    {//each of the depvars is checked if it has a Weyl counterpart
      isXorD = 0;
      for (j = 1; j<=nvars(@r); j++)
      {//checking each variable in the basering for a noncommutative relation.
    if ((depVars[i]*var(j) - var(j)*depVars[i]==1) ||
        (depVars[i]*var(j) - var(j)*depVars[i]==-1))
    {//depVars[i] is part of some weyl relation
      sortedInp = sort(inpList)[1];
      if (binarySearch(sortedInp,var(j))==0)
      {//not yet included
        if (depVars[i]*var(j) - var(j)*depVars[i]==1)
        {//d*x
          inpList = insert(inpList,depVars[i],(size(inpList) div 2));
          inpList = insert(inpList, var(j),0);
        }//d*x
        else
        {//x*d
          inpList = insert(inpList,var(j),(size(inpList) div 2));
          inpList = insert(inpList, depVars[i],0);
        }//x*d
      }//not yet included
      isXorD = 1;
      break;
    }//depVars[i] is part of some weyl relation
      }//checking each variable in the basering for a noncommutative relation.
      if (!isXorD)
      {
    ERROR("One of the variables did not have a proper
 non-commutative relation with the given variables.");
      }
    }//each of the depvars is checked if it has a Weyl counterpart
    dbprint(p,dbprintWhitespace+"h lies in Weyl subalgebra.");
  }//User did not provide list of variables
  // Input sanity check done.
  dbprint(p,"Input check successful.");
  if (deg(h)<1)
  {
    dbprint(p,dbprintWhitespace + "h was just a constant; right away
 returning it");
    return(list(list(h)));
  }
  list rlist;
  rlist = insert(rlist,ringlist(@r)[1]);
  rlist = insert(rlist,list(),1);
  for (i=1;i<=size(inpList);i++)
  {
    rlist[2]=insert(rlist[2],string(inpList[i]),i-1);
  }
  rlist = insert(rlist,list(),2);
  rlist[3] = insert(rlist[3],list());
  rlist[3] = insert(rlist[3],list());
  rlist[3][1][1]= "dp";
  rlist[3][1][2]= 1:size(inpList);
  rlist[3][2][1]="C";
  rlist[3][2][2]=intvec(0);
  rlist = insert(rlist,ideal(0),3);
  def @r2 = ring(rlist);
  setring(@r2);
  def @r3 = Weyl();
  setring(@r3);
  poly h = imap(@r,h);
  list result = facWeyl(h);
  setring(@r);
  list result = imap(@r3,result);
  return(result);
}//proc facSubWeyl
example
{
  "EXAMPLE:";echo=2;
  ring r = 0,(x,y,z),dp;
  matrix D[3][3]; D[1,3]=-1;
  def R = nc_algebra(1,D); // x,z generate Weyl subalgebra
  setring R;
  poly h = (x^2*z^2+x)*x;
  list fact1 = facSubWeyl(h,x,z);
  // compare with facFirstWeyl:
  ring s = 0,(z,x),dp;
  def S = nc_algebra(1,1); setring S;
  poly h = (x^2*z^2+x)*x;
  list fact2 = facFirstWeyl(h);
  map F = R,x,0,z;
  list fact1 = F(fact1); // it is identical to list fact2
  testNCfac(fact1); // check the correctness again
}


static proc test_facSubWeyl()
{//testing facSubWeyl
  int result = 1;
  //Test 1: 0
  ring r = 0,(x,y,z),dp;
  matrix D[3][3]; D[1,3]=-1;
  def R = nc_algebra(1,D); // x,z generate Weyl subalgebra
  setring R;
  poly input = 0;
  list expected = list(list(poly(0)));
  list obtained = facSubWeyl(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 1 for facSubWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: Poly from example
  input = (x^2*z^2+x)*x;
  expected = sortFactorizations(
    list(list(number(1),x,(x*z^2+1),x),
            list(number(1),x,x,xz2-2z+1))
    );
  obtained = facSubWeyl(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 2 for facSubWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: Poly from example with provided variables
  input = (x^2*z^2+x)*x;
  expected = sortFactorizations(
    list(list(number(1),x,(x*z^2+1),x),
            list(number(1),x,x,xz2-2z+1))
    );
  obtained = facSubWeyl(input,z,x);
  if (!isListEqual(expected,obtained))
  {
    print("Test 3 for facSubWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill r; kill R;
  //Test 4: More than first Weyl, no provided variables
  ring R = 0,(x1,x2,d1,d2),dp;
  def r= Weyl();
  ring S = 0,(f,e,h),dp;
  def s = makeUsl2();
  def w = s + r;
  setring w;
  poly input = (x1*x2+d1*d2+5)*d2*(x1+1);
  list expected = sortFactorizations(
    list(
      list(number(1),(x1*x2+d1*d2+5),d2,(x1+1)),
      list(number(1),(x1*x2+d1*d2+5),(x1+1),d2)
      ));
  list obtained = facSubWeyl(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 4 for facSubWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 5: More than first Weyl, no provided variables
  input = (x1*x2+d1*d2+5)*d2*(x1+1);
  expected = sortFactorizations(
    list(
      list(number(1),(x1*x2+d1*d2+5),d2,(x1+1)),
      list(number(1),(x1*x2+d1*d2+5),(x1+1),d2)
      ));
  obtained = facSubWeyl(input,x1,x2,d1,d2);
  if (!isListEqual(expected,obtained))
  {
    print("Test 5 for facSubWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing facSubWeyl


//////////////////////////////////////////////////
//************SHIFT ALGEBRA PART******************
//////////////////////////////////////////////////


proc facFirstShift(poly h)
"USAGE: facFirstShift(h); h a polynomial in the first shift algebra
RETURN: list
PURPOSE: compute all factorizations of a polynomial in the first shift algebra
THEORY: This function is a wrapper for facShift. It exists to make this library downward-compatible
        with older versions.
ASSUME: basering is the first shift algebra
NOTE: Every entry of the output list is a list with factors for one possible factorization.
EXAMPLE: example facFirstShift; shows examples
SEE ALSO: testNCfac, facFirstWeyl, facSubWeyl
"{//facFirstShift
  return(ncfactor(h));
}//facFirstShift
example
{
  "EXAMPLE:";echo=2;
  ring R = 0,(x,s),dp;
  def r = nc_algebra(1,s);
  setring(r);
  poly h = (s^2*x+x)*s;
  facFirstShift(h);
}


//NO TESTS NECESSARY, SINCE REDIRECTION TO FACSHIFT


proc facShift(poly h)
"USAGE: facShift(h); h a polynomial in the n'th shift algebra
RETURN: list
PURPOSE: compute all factorizations of a polynomial in the nth shift
         algebra
THEORY: Currently, we do not have a specialized algorithm for the
        shift algebra in this library that takes advantage of the graded
        structure, hence this function is mapping to the general factorization
        algorithm for G-Algebras
NOTE: Every entry of the output list is a list with factors for one possible factorization.
EXAMPLE: example facFirstShift; shows examples
SEE ALSO: testNCfac, facFirstWeyl, facSubWeyl
"{//facShift
  return(ncfactor(h));
}//facShift
example
{
  "EXAMPLE:";echo=2;
  ring R = 0,(x1,x2,s1,s2),dp;
  matrix C[4][4] = 1,1,1,1,
    1,1,1,1,
    1,1,1,1,
    1,1,1,1;
  matrix D[4][4] = 0,0,s1,0,
    0,0,0,s2,
    -s1,0,0,0,
    0,-s2,0,0;
  def r = nc_algebra(C,D);
  setring(r);
  poly h = x1*(x1+1)*s1^2-2*x1*(x1+100)*s1+(x1+99)*(x1+100);
  facShift(h);
}


static proc test_facShift()
{//testing facShift
  int result = 1;
  ring R = 0,(x1,x2,s1,s2),dp;
  matrix C[4][4] = 1,1,1,1,
    1,1,1,1,
    1,1,1,1,
    1,1,1,1;
  matrix D[4][4] = 0,0,s1,0,
    0,0,0,s2,
    -s1,0,0,0,
    0,-s2,0,0;
  def r = nc_algebra(C,D);
  setring(r);
  //Test 1: 0
  poly input = 0;
  list expected = list(list(poly(0)));
  list obtained = facShift(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 1 for facShift failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: Random constant
  input = 346/2352;
  expected = list(list(poly(346/2352)));
  obtained = facShift(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 2 for facShift failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: monomial
  input = 3*s1^3*x1*s2;
  expected= delete_duplicates_noteval_and_sort(
    list(
      list(number(3),s1,s1,s1,x1,s2),
      list(number(3),s1,s1,s1,s2,x1),
      list(number(3),s1,s1,s2,s1,x1),
      list(number(3),s1,s2,s1,s1,x1),
      list(number(3),s2,s1,s1,s1,x1),
      list(number(3),s1,s1,s1,x1,s2),
      list(number(3),s1,s1,x1+1,s1,s2),
      list(number(3),s1,x1+2,s1,s1,s2),
      list(number(3),x1+3,s1,s1,s1,s2),
      list(number(3),s1,s1,s1,s2,x1),
      list(number(3),s1,s1,s2,s1,x1),
      list(number(3),s1,s1,s2,x1+1,s1),
      list(number(3),s1,s1,x1+1,s2,s1),
      list(number(3),s1,x1+2,s1,s2,s1),
      list(number(3),x1+3,s1,s1,s2,s1),
      list(number(3),s1,s2,s1,s1,x1),
      list(number(3),s1,s2,s1,x1+1,s1),
      list(number(3),s1,s2,x1+2,s1,s1),
      list(number(3),s1,x1+2,s2,s1,s1),
      list(number(3),x1+3,s1,s2,s1,s1),
      list(number(3),s2,s1,s1,s1,x1),
      list(number(3),s2,s1,s1,x1+1,s1),
      list(number(3),s2,s1,x1+2,s1,s1),
      list(number(3),s2,x1+3,s1,s1,s1),
      list(number(3),x1+3,s2,s1,s1,s1)
      ));
  obtained = facShift(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 3 for facShift failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: regular polynomial
  input = 5*(s1*x2 + 4)*(s2 + 3*x2);
  expected= delete_duplicates_noteval_and_sort(
    list(
      list(number(5),(s1*x2 + 4),(s2 + 3*x2))
      ));
  obtained = facShift(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 4 for facShift failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing facShift


//////////////////////////////////////////////////
//************Q-WEYL-SECTION**********************
//////////////////////////////////////////////////


proc homogfacFirstQWeyl(poly h)
"USAGE: homogfacFirstQWeyl(h); h is a homogeneous polynomial in the
 first q-Weyl algebra with respect to the weight vector [-1,1]
RETURN: list
PURPOSE: Computes a factorization of a homogeneous polynomial h with
  respect to the weight vector [-1,1] in the first q-Weyl algebra
THEORY: This function is a wrapper for homogfacNthQWeyl. It exists to make this
        library downward-compatible with older versions.
SEE ALSO: homogfacFirstQWeyl_all
"{//proc homogfacFirstQWeyl
  return(homogfacNthQWeyl(h));
}//proc homogfacFirstQWeyl
example
{
  "EXAMPLE:";echo=2;
  ring R = (0,q),(x,d),dp;
  def r = nc_algebra (q,1);
  setring(r);
  poly h = q^25*x^10*d^10+q^16*(q^4+q^3+q^2+q+1)^2*x^9*d^9+
    q^9*(q^13+3*q^12+7*q^11+13*q^10+20*q^9+26*q^8+30*q^7+
    31*q^6+26*q^5+20*q^4+13*q^3+7*q^2+3*q+1)*x^8*d^8+
    q^4*(q^9+2*q^8+4*q^7+6*q^6+7*q^5+8*q^4+6*q^3+
     4*q^2+2q+1)*(q^4+q^3+q^2+q+1)*(q^2+q+1)*x^7*d^7+
    q*(q^2+q+1)*(q^5+2*q^4+2*q^3+3*q^2+2*q+1)*(q^4+q^3+q^2+q+1)*(q^2+1)*(q+1)*x^6*d^6+
    (q^10+5*q^9+12*q^8+21*q^7+29*q^6+33*q^5+31*q^4+24*q^3+15*q^2+7*q+12)*x^5*d^5+
    6*x^3*d^3+24;
  homogfacFirstQWeyl(h);
}


// NO TESTS NEEDED SINCE CALL TO HOMOGFACNTHQWEYL


proc homogfacFirstQWeyl_all(poly h)
"USAGE: homogfacFirstQWeyl_all(h); h is a homogeneous polynomial in the first q-Weyl algebra
 with respect to the weight vector [-1,1]
RETURN: list
PURPOSE: Computes all factorizations of a homogeneous polynomial h with respect
  to the weight vector [-1,1] in the first q-Weyl algebra
THEORY: This function is a wrapper for homogFacNthQWeyl_all. It exists to make this library
        downward-compatible with older versions.
SEE ALSO: homogfacFirstQWeyl
"{//proc HomogfacFirstQWeylAll
  return(homogfacNthQWeyl_all(h));
}//proc HomogfacFirstQWeylAll
example
{
  "EXAMPLE:";echo=2;
  ring R = (0,q),(x,d),dp;
  def r = nc_algebra (q,1);
  setring(r);
  poly h = q^25*x^10*d^10+q^16*(q^4+q^3+q^2+q+1)^2*x^9*d^9+
    q^9*(q^13+3*q^12+7*q^11+13*q^10+20*q^9+26*q^8+30*q^7+
    31*q^6+26*q^5+20*q^4+13*q^3+7*q^2+3*q+1)*x^8*d^8+
    q^4*(q^9+2*q^8+4*q^7+6*q^6+7*q^5+8*q^4+6*q^3+
    4*q^2+2q+1)*(q^4+q^3+q^2+q+1)*(q^2+q+1)*x^7*d^7+
    q*(q^2+q+1)*(q^5+2*q^4+2*q^3+3*q^2+2*q+1)*(q^4+q^3+q^2+q+1)*(q^2+1)*(q+1)*x^6*d^6+
    (q^10+5*q^9+12*q^8+21*q^7+29*q^6+33*q^5+31*q^4+24*q^3+15*q^2+7*q+12)*x^5*d^5+
    6*x^3*d^3+24;
  homogfacFirstQWeyl_all(h);
}


//NO TESTS NEEDED SINCE CALL TO HOMOGFACNTHQWEYL_ALL

proc homogfacNthQWeyl(poly h)
"USAGE: homogfacNthQWeyl(h); h is a homogeneous polynomial in the
 n'th q-Weyl algebra with respect to the weight vector
@ [-1,...,-1,1,...,1].
@  \__  __/  \__  __/
@     \/        \/
@     n/2       n/2
RETURN: list
PURPOSE: Computes a factorization of a homogeneous polynomial h
in the n'th q-Weyl algebra
THEORY:@code{homogfacNthQWeyl} returns a list with a factorization of the given,
 [-1,1]-homogeneous polynomial. For every i in 1..n: If the degree of the polynomial
 in [d_i,x_i] is k with k positive, the last entries in the output list are the second
 variable. If k is positive, the last k entries will be x_i. The other
 entries will be irreducible polynomials of degree zero or 1 resp. -1. resp. other variables

GENERAL ASSUMPTIONS:
 - The basering is the nth Weyl algebra and has the form, that the first n variables represent
   x1, ..., xn, and the second n variables do represent the d1, ...,
   dn.
 - We have n parameters q_1,..., q_n given.

SEE ALSO: homogfacFirstQWeyl, homogfacFirstQWeyl_all, homogfacNthQWeyl_all
"
{//proc homogfacNthQWeyl
  int p = printlevel-voice+2;//for dbprint
  poly hath = h;
  def r = basering;
  int i; int j; int k;
  string dbprintWhitespace = "";
  for (i = 1; i<=voice;i++)
  {dbprintWhitespace = dbprintWhitespace + " ";}
  intvec ivm11 = intvec(-1,1);
  if(!checkIfProperNthQWeyl())
  {//checking whether the given ring is proper q-Weyl
    ERROR("Assumptions on the ring structure not met.");
    return(list());
  }//checking whether the given ring is proper q-Weyl
  if (!homogwithorderNthWeyl(h))
  {//The given polynomial is not homogeneous
    ERROR("Given polynomial was not [-1,...,-1,1,...,1]-homogeneous");
    return(list());
  }//The given polynomial is not homogeneous
  if (deg(h)<=0)
  {
    return(list(h));
  }
  list result;
  intvec m = degreeOfNthWeylPoly(h);
  dbprint(p,dbprintWhitespace +" Splitting the polynomial in Q_0 and Q_k-Part");
  dbprint(p,dbprintWhitespace + "Its [-1,...,-1,1,...,1] degree is "+string(m));
  for (j = 1; j<=nvars(basering) div 2; j++)
  {//extracting the respective variable for every position
    dbprint(p,dbprintWhitespace + "Considering variables x_"+string(j)+" and d" + string(j));
    if (m[j]!=0)
    {//The degree is not zero
      if (m[j] <0)
      {//There are more x than d
        hath = lift(var(j)^(-m[j]),hath)[1,1];
        for (i = 1; i<=-m[j]; i++)
        {
          result = result + list(var(j));
        }
      }//There are more x than d
      else
      {//There are more d than x
        hath = lift(var(nvars(basering) div 2 + j)^m[j],hath)[1,1];
        for (i = 1; i<=m[j];i++)
        {
          result = result + list(var(nvars(basering) div 2 + j));
        }
      }//There are more d than x
    }//The degree is not zero
  }//extracting the respective variable for every position
  dbprint(p,dbprintWhitespace+" Done");
  //beginning to factor the zero-homogeneous part
  list mons;
  dbprint(p,dbprintWhitespace+" Putting the monomials in the Q_0-part in a list.");
  for(i = 1; i<=size(hath);i++)
  {//Putting the monomials in a list
    mons = mons+list(hath[i]);
  }//Putting the monomials in a list
  dbprint(p,dbprintWhitespace+" Done");
  dbprint(p,dbprintWhitespace+" Mapping these monomials to K[theta_1,... , theta_n]");
  list parameterNames;
  for (i = 1; i<=(nvars(basering) div 2); i++)
  {//saving the names of the parameters
    parameterNames[i] = ringlist(basering)[1][2][i];
  }//saving the names of the parameters
  ring tempRingPre = (0,q(1..(nvars(basering) div 2))),
                    (x(1..(nvars(basering) div 2)),
                     d(1..(nvars(basering) div 2)),
                     theta(1..(nvars(basering) div 2))),dp;
  list ringListTempRingPre = ringlist(tempRingPre);
  for (i = 1; i<=size(ringListTempRingPre[1][2]); i++)
  {//setting the same name for the parameters
    ringListTempRingPre[1][2][i] = parameterNames[i];
  }//setting the same name for the parameters
  def tempRing = ring(ringListTempRingPre);
  setring(tempRing);
  ideal mapList;
  for (i = 1; i<=nvars(r) ; i++)
  {//filling the list of elements we want to map
    mapList[i] = var(i);
  }//filling the list of elements we want to map
  map thetamap = r,mapList;
  list mons = thetamap(mons);
  poly entry;
  intvec lExp;
  poly tempSummand;
  for (i = 1; i<=size(mons);i++)
  {//transforming the monomials as monomials in theta
    entry = leadcoef(mons[i]);
    lExp  = leadexp(mons[i]);
    for (k = 1; k<=nvars(r) div 2; k++)
    {//iterating over the pairs x_kd_k
      for (j = 0; j<lExp[k];j++)
      {
        tempSummand = (par(k)^j-1)/(par(k)-1);
        entry = entry * (theta(k)-tempSummand);
      }
      entry = entry* par(k)^(-triangNum(leadexp(mons[i])[k]-1));
    }//iterating over the pairs x_kd_k
    mons[i] = entry;
  }//transforming the monomials as monomials in theta
  dbprint(p,dbprintWhitespace+" Done");
  dbprint(p,dbprintWhitespace+" Factorize the Q_0-Part in K[theta]");
  list azeroresult = factorize(sum(mons));
  dbprint(p,dbprintWhitespace+" Successful");
  list azeroresult_return_form;
  for (i = 1; i<=size(azeroresult[1]);i++)
  {//rewrite the result of the commutative factorization
    for (j = 1; j <= azeroresult[2][i];j++)
    {
      azeroresult_return_form = azeroresult_return_form + list(azeroresult[1][i]);
    }
  }//rewrite the result of the commutative factorization
  dbprint(p,dbprintWhitespace+" Mapping back to Q_0.");
  setring(r);
  ideal finalMapList;
  for(i = 1; i<=nvars(r);i++)
  {
    finalMapList[i] = var(i);
  }
  for (i = 1; i<=nvars(r) div 2; i++)
  {
    finalMapList[i + nvars(r)] = var(i)*var(i + (nvars(r) div 2));
  }
  map finalmap = tempRing,finalMapList;
  list tempresult = finalmap(azeroresult_return_form);
  dbprint(p,dbprintWhitespace+"Successful.");
  for (k = 1; k<=nvars(r) div 2; k++)
  {
    for (i = 1; i<=size(tempresult);i++)
    {//factorizations of theta resp. theta +1
      if(tempresult[i]==var(k)*var(k + nvars(r) div 2))
      {
        tempresult = insert(tempresult,var(k),i-1);
        i++;
        tempresult[i]=var(k +nvars(r) div 2);
      }
      if(tempresult[i]==var(k + nvars(r) div 2)*var(k))
      {
        tempresult = insert(tempresult,var(k + nvars(r) div 2),i-1);
        i++;
        tempresult[i]=var(k);
      }
    }//factorizations of theta resp. theta +1
  }
  result = tempresult+result;
  //normalization of factors
  for (i=2; i<=size(result); i++)
  {//Iterating through all respective factors
    if (content(result[i])!=number(1))
    {//Got one where the content is not equal to 1
      result[1] = result[1] * content(result[i]);
      result[i] = result[i] / content(result[i]);
    }//Got one where the content is not equal to 1
  }//Iterating through all respective factors
  return(result);
}//proc homogfacNthQWeyl
example
{
  "EXAMPLE:";echo=2;
  ring R = (0,q1,q2,q3),(x1,x2,x3,d1,d2,d3),dp;
  matrix C[6][6] = 1,1,1,q1,1,1,
    1,1,1,1,q2,1,
    1,1,1,1,1,q3,
    1,1,1,1,1,1,
    1,1,1,1,1,1,
    1,1,1,1,1,1;
  matrix D[6][6] = 0,0,0,1,0,0,
    0,0,0,0,1,0,
    0,0,0,0,0,1,
    -1,0,0,0,0,0,
    0,-1,0,0,0,0,
    0,0,-1,0,0,0;
  def r = nc_algebra(C,D);
  setring(r);
  poly h =x1*x2^2*x3^3*d1*d2^2+x2*x3^3*d2;
  homogfacNthQWeyl(h);
}


static proc test_homogfacNthQWeyl()
{//testing homogfacNthQWeyl
  int result = 1;
  ring R = (0,q1,q2,q3,q4),(x1,x2,x3,x4,d1,d2,d3,d4),dp;
  matrix C[8][8] =
    1,1,1,1,q1,1,1,1,
    1,1,1,1,1,q2,1,1,
    1,1,1,1,1,1,q3,1,
    1,1,1,1,1,1,1,q4,
    1,1,1,1,1,1,1,1,
    1,1,1,1,1,1,1,1,
    1,1,1,1,1,1,1,1,
    1,1,1,1,1,1,1,1;
  matrix D[8][8] = 0,0,0,0,1,0,0,0,
    0,0,0,0,0,1,0,0,
    0,0,0,0,0,0,1,0,
    0,0,0,0,0,0,0,1,
    -1,0,0,0,0,0,0,0,
    0,-1,0,0,0,0,0,0,
    0,0,-1,0,0,0,0,0,
    0,0,0,-1,0,0,0,0;
  def r = nc_algebra(C,D);
  setring(r);
  //Test 1: 0
  poly input = 0;
  list expected = list(poly(0));
  list obtained = homogfacNthQWeyl(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 1 for homogfacNthQWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: Random constant
  input = 3904/12;
  expected = list(poly(3904/12));
  obtained = homogfacNthQWeyl(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 2 for homogfacNthQWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: monomial
  input = 5*d1*x1*d2*x2^2*d3*x3*d4^2*x4;
  expected = list(poly(5),d1,x1,d2,x2,
          d3,x3,q4^2*x4*d4+q4+1,x2,d4);
  obtained = homogfacNthQWeyl(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 3 for homogfacNthQWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: Zero dimensional
  input = ((x4*d4)^4 + 3/2*(x2*d2) + 5)*((x3*d3)^2+(x4*d4)^2+4);
  expected = list(poly(1/2),2*(x4*d4)^4 + 3*(x2*d2) + 10,((x3*d3)^2+(x4*d4)^2+4));
  obtained = homogfacNthQWeyl(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 4 for homogfacNthQWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 5: Non-zero-dim, no changes
  input = ((x4*d4)^4 + 3/2*(x2*d2) + 5)*((x3*d3)^2+(x4*d4)^2+4)*d1*x2*d3*x4;
  expected = list(poly(1/2),2*(x4*d4)^4 + 3*(x2*d2) + 10,((x3*d3)^2+(x4*d4)^2+4,d1,x2,d3,x4));
  obtained = homogfacNthQWeyl(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 5 for homogfacNthQWeyl failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing homogfacNthQWeyl


proc homogfacNthQWeyl_all(poly h)
"USAGE: homogfacNthQWeyl_all(h); h is a homogeneous polynomial in the
 n'th q-Weyl algebra with respect to the weight vector
@ [-1,...,-1,1,...,1].
@  \__  __/  \__  __/
@     \/        \/
@     n/2       n/2
RETURN: list
PURPOSE: Computes all factorizations of a homogeneous polynomial h
in the n'th q-Weyl algebra
THEORY: @code{homogfacNthQWeyl} returns a list with lists representing
each a factorization of the given,
 [-1,...,-1,1,...,1]-homogeneous polynomial.

GENERAL ASSUMPTIONS:
 - The basering is the nth Weyl algebra and has the form, that the first n variables represent
   x1, ..., xn, and the second n variables do represent the d1, ..., dn.
 - We have n parameters q_1,..., q_n given.

SEE ALSO: homogfacNthWeyl, homogfacFirstQWeyl, homogfacFirstQWeyl_all
"
{//proc homogfacNthQWeyl_all
  int p=printlevel-voice+2;//for dbprint
  intvec iv11= 1:nvars(basering);
  if (deg(h,iv11) <= 0 )
  {//h is a constant
    dbprint(p,"Given polynomial was constant");
    return(list(list(h)));
  }//h is a constant
  def r = basering;
  list one_hom_fac; //stands for one homogeneous factorization
  int i; int j; int k; int l;
  string dbprintWhitespace = "";
  for (i = 1; i<=voice;i++)
  {dbprintWhitespace = dbprintWhitespace + " ";}
  dbprint(p,dbprintWhitespace +" Calculate one homogeneous factorization using homogfacNthWeyl");
  //Compute again a homogeneous factorization
  one_hom_fac = homogfacNthQWeyl(h);
  dbprint(p,dbprintWhitespace +"Successful");
  if (size(one_hom_fac) == 0)
  {//there is no homogeneous factorization or the polynomial was not homogeneous
    return(list());
  }//there is no homogeneous factorization or the polynomial was not homogeneous
  //divide list in A0-Part and a list of x_i's resp. y_i's
  list list_not_azero = list();
  list list_azero;
  list k_factor;
  int is_list_not_azero_empty = 1;
  int is_list_azero_empty = 1;
  k_factor = list(number(one_hom_fac[1]));
  dbprint(p, dbprintWhitespace + "Determine whether there is an A0
part or not.");
  int absValueOfDegree = 0;
  intvec degVecH = degreeOfNthWeylPoly(h);
  intvec lExp;
  for (i = 1; i<=size(degVecH); i++)
  {//adding up the absolute values of the degrees of the respective variables
    absValueOfDegree = absValueOfDegree + absValue(degVecH[i]);
  }//adding up the absolute values of the degrees of the respective variables
  if (absValueOfDegree < size(one_hom_fac) - 1)
  {//There is a nontrivial A0 part
    list_azero = one_hom_fac[2..(size(one_hom_fac)-absValueOfDegree)];
    is_list_azero_empty = 0;
  }//There is a nontrivial A0 part
  dbprint(p,dbprintWhitespace +" Combine x_i,d_i to x_id_i in the
factorization again.");
  dbprint(p,dbprintWhitespace + " The corresponding list of A0
    factors is: " + string(list_azero));
  for (i = 1; i<size(list_azero);i++)
  {//in homogfacFirstWeyl, we factorized the theta_i, and this will be
   //made undone
    for (j = 1; j<=nvars(basering) div 2; j++)
    {//iterating through the variables
      if (list_azero[i] == var(j))
      {
        if (list_azero[i+1]==var(j + nvars(basering) div 2))
        {
          list_azero[i] = var(j)*var(j + nvars(basering) div 2);
          list_azero = delete(list_azero,i+1);
        }
      }
      if (list_azero[i] == var(j + nvars(basering) div 2))
      {
        if (list_azero[i+1]==var(j))
        {
          list_azero[i] = var(j + nvars(basering) div 2)*var(j);
          list_azero = delete(list_azero,i+1);
        }
      }
    }//iterating through the variables
  }//in homogfacFirstWeyl, we factorized theta_i, and this will be
   //made undone
  dbprint(p,dbprintWhitespace +" Done");
  dbprint(p, dbprintWhitespace + "The new list is: " +
          string(list_azero));
  if (degVecH != 0:(nvars(basering) div 2))
  {//list_not_azero is not empty
    list_not_azero = one_hom_fac[(size(one_hom_fac) -
                                  absValueOfDegree +1)..size(one_hom_fac)];
    is_list_not_azero_empty = 0;
  }//list_not_azero is not empty
  dbprint(p,dbprintWhitespace+" Mapping list_azero to K[theta_1, ... ,theta_n]");
  list parameterNames;
  for (i = 1; i<=(nvars(basering) div 2); i++)
  {//saving the names of the parameters
    parameterNames[i] = ringlist(basering)[1][2][i];
  }//saving the names of the parameters
  ring tempRingPre = (0,q(1..(nvars(basering) div 2))),
                    (x(1..(nvars(basering) div 2)),
                     d(1..(nvars(basering) div 2)),
                     theta(1..(nvars(basering) div 2))),dp;
  list ringListTempRingPre = ringlist(tempRingPre);
  for (i = 1; i<=size(ringListTempRingPre[1][2]); i++)
  {//setting the same name for the parameters
    ringListTempRingPre[1][2][i] = parameterNames[i];
  }//setting the same name for the parameters
  def tempRing = ring(ringListTempRingPre);
  setring tempRing;
  poly entry;
  ideal mapList;
  for (i = 1; i<=nvars(r) ; i++)
  {//filling the list of elements we want to map
    mapList[i] = var(i);
  }//filling the list of elements we want to map
  map thetamap = r,mapList;
  if(!is_list_not_azero_empty)
  {//Mapping in Singular is only possible, if the list before
    //contained at least one element of the other ring
    list list_not_azero = thetamap(list_not_azero);
  }//Mapping in Singular is only possible, if the list before
  //contained at least one element of the other ring
  if(!is_list_azero_empty)
  {//Mapping in Singular is only possible, if the list before
    //contained at least one element of the other ring
    list list_azero= thetamap(list_azero);
  }//Mapping in Singular is only possible, if the list before
  //contained at least one element of the other ring
  list k_factor = thetamap(k_factor);
  list tempmons;
  dbprint(p,dbprintWhitespace +" Done");
  poly tempSummand;
  for(i = 1; i<=size(list_azero);i++)
  {//rewrite the polynomials in A1 as polynomials in K[theta]
    tempmons = list();
    for (j = 1; j<=size(list_azero[i]);j++)
    {
      tempmons = tempmons + list(list_azero[i][j]);
    }
    for (j = 1 ; j<=size(tempmons);j++)
    {
      entry = leadcoef(tempmons[j]);
      lExp  = leadexp(tempmons[j]);
      for (l = 1; l<=nvars(r) div 2; l++)
      {
        for (k = 0; k < lExp[l];k++)
        {
          tempSummand = (par(l)^k-1)/(par(l)-1);
          entry = entry*(theta(l)-tempSummand);
        }
        entry =  entry* par(l)^(-triangNum(lExp[l]-1));
      }
      tempmons[j] = entry;
    }
    list_azero[i] = sum(tempmons);
  }//rewrite the polynomials in A1 as polynomials in K[theta]
  //Compute all permutations of the A0-part
  dbprint(p, dbprintWhitespace + "The polynomials rewritten in
K[theta_1, ... , theta_n] look like:");
  dbprint(p,list_azero);
  dbprint(p,dbprintWhitespace +" Compute all permutations of the A_0-part with the first resp.
the snd. variable");
  list result;
  intvec shift = 0:(nvars(r) div 2);
  if (size(list_not_azero)!=0)
  {//Compute all possibilities to permute the x's resp. the y's in the list
    result = permpp(list_azero + list_not_azero);
    for (i = 1; i<= size(result); i++)
    {//adjust the a_0-parts
      shift = 0:(nvars(r) div 2);
      for (j=1; j<=size(result[i]);j++)
      {//iterating through each factor
        if (deg(result[i][j],(1:nvars(r),0:(nvars(r) div 2))) !=0)
        {//the factor is a single variable
          for(k = 1; k<=nvars(r); k++)
          {//Iterating through the variables to find the variable
            if (result[i][j]==var(k))
            {//found it!
              if (k<=nvars(r) div 2)
              {shift[k] = shift[k] + 1;}
              else
              {shift[k -(nvars(r) div 2)] = shift[k -(nvars(r) div
                                                      2)] -1;
              }
              break;
            }//found it!
          }//Iterating through the variables to find the variable
        }//the factor is a single variable
        else
        {//factor was a theta poly
          for (k= 1; k <= nvars(r) div 2;k++)
          {
            if (shift[k]<0)
            {
              result[i][j] = subst(result[i][j],theta(k),
                                   1/par(k)*((theta(k)-1)/(par(k)^(absValue(shift[k])-1))
                                             - (par(k)^(shift[k]+2)-par(k))/(1-par(k))));
            }
            else
            {
              if (shift[k]>0)
              {
                result[i][j] =
                  subst(result[i][j],theta(k),par(k)^(shift[k])*theta(k)
                        +(1-par(k)^(shift[k]))/(1-par(k)));
              }
            }
          }
        }//factor was a theta poly
      }//iterating through each factor
    }//adjust the a_0-parts
  }//Compute all possibilities to permute the x's resp. the y's in the list
  else
  {//The result is just all the permutations of the a_0-part
    result = permpp(list_azero);
  }//The result is just all the permutations of the a_0 part
  if (size(result)==0)
  {
    return(normalizeFactors(result));
  }
  dbprint(p,dbprintWhitespace +" Done");
  dbprint(p, dbprintWhitespace + "The factorization list is now:");
  dbprint(p,result);
  dbprint(p, dbprintWhitespace + "Checking whether the
        intermediate result is correct or not");
  dbprint(p,testNCfac(result));
  dbprint(p,dbprintWhitespace +" Searching for theta resp. theta+1 in
  the list and fact. them");
  //Now we are going deeper and search for theta resp. theta + 1, substitute
  //them by xy resp. yx and go on permuting
  int found_theta;
  int thetapos;
  int shift_sign;
  int thetaIndex;
  poly shiftvar;
  list leftpart;
  list rightpart;
  list lparts;
  list rparts;
  list tempadd;
  for (i = 1; i<=size(result) ; i++)
  {//checking every entry of result for theta or theta +1
    found_theta = 0;
    for(j=1;j<=size(result[i]);j++)
    {//iterating through all factors
      for (k = 1; k<=nvars(r) div 2; k++)
      {//iterating through the variables
        if (result[i][j]==theta(k))
        {//the jth entry is theta and can be written as x*y
          thetapos = j;
          thetaIndex = k;
          result[i]= insert(result[i],x(k),j-1);
          j++;
          result[i][j] = d(k);
          found_theta = 1;
          break;
        }//the jth entry is theta and can be written as x*y
        if(1/leadcoef(result[i][j])*result[i][j] == theta(k) +1/par(k))
        {
          thetapos = j;
          thetaIndex = k;
          result[i] = insert(result[i],d(k),j-1);
          j++;
          result[i][j] = x(k);
          found_theta = 1;
          break;
        }
      }//iterating through the variables
      if(found_theta)
      {break;}
    }//iterating through all factors
    if (found_theta)
    {//One entry was theta resp. theta +1
      leftpart = result[i];
      leftpart = leftpart[1..thetapos];
      rightpart = result[i];
      rightpart = rightpart[(thetapos+1)..size(rightpart)];
      lparts = list(leftpart);
      rparts = list(rightpart);
      //first deal with the left part
      if (leftpart[thetapos] == x(thetaIndex))
      {
        shift_sign = 1;
        shiftvar = x(thetaIndex);
      }
      else
      {
        shift_sign = -1;
        shiftvar = d(thetaIndex);
      }
      for (j = size(leftpart); j>1;j--)
      {//drip x resp. y
        if (leftpart[j-1]==shiftvar)
        {//commutative
          j--;
          continue;
        }//commutative
        if (leadexp(leftpart[j-1])[thetaIndex + nvars(r) div 2]
            - leadexp(leftpart[j-1])[thetaIndex]!=0)
        {//stop here
          break;
        }//stop here
        //Here, we can only have a a0- part
        if (shift_sign<0)
        {
          leftpart[j] = subst(leftpart[j-1],theta(thetaIndex),
                              1/par(thetaIndex)*(theta(thetaIndex)+shift_sign));
        }
        else
        {
          if (shift_sign>0)
          {
            leftpart[j] = subst(leftpart[j-1],theta(thetaIndex),
                                par(thetaIndex)*theta(thetaIndex)+shift_sign);
          }
        }
        leftpart[j-1] = shiftvar;
        lparts = lparts + list(leftpart);
      }//drip x resp. y
      //and now deal with the right part
      if (rightpart[1] == x(thetaIndex))
      {
        shift_sign = 1;
        shiftvar = x(thetaIndex);
      }
      else
      {
        shift_sign = -1;
        shiftvar = d(thetaIndex);
      }
      for (j = 1 ; j < size(rightpart); j++)
      {
        if (rightpart[j+1] == shiftvar)
        {
          j++;
          continue;
        }
        if (leadexp(rightpart[j+1])[thetaIndex + nvars(r) div 2]
            - leadexp(rightpart[j+1])[thetaIndex]!=0)
        {
          break;
        }
        if (shift_sign<0)
        {
          rightpart[j] = subst(rightpart[j+1], theta(thetaIndex),
                               par(thetaIndex)*theta(thetaIndex)+1);
        }
        else
        {
          if (shift_sign > 0)
          {
            rightpart[j] = subst(rightpart[j+1], theta(thetaIndex),
                                 1/par(thetaIndex)*(theta(thetaIndex)-1));
          }
        }
        rightpart[j+1] = shiftvar;
        rparts = rparts + list(rightpart);
      }
      //And now, we put all possibilities together
      tempadd = list();
      for (j = 1; j<=size(lparts); j++)
      {
        for (k = 1; k<=size(rparts);k++)
        {
          tempadd = tempadd + list(lparts[j]+rparts[k]);
        }
      }
      tempadd = delete(tempadd,1); // The first entry is already in the list
      result = result + tempadd;
      continue; //We can may be not be done already with the ith entry
    }//One entry was theta resp. theta +1
  }//checking every entry of result for theta or theta +1
  dbprint(p,dbprintWhitespace +" Done");
  dbprint(p,dbprintWhitespace + "The new result list is:");
  dbprint(result);
  setring(r);
  ideal finalMapList;
  for(i = 1; i<=nvars(r);i++)
  {
    finalMapList[i] = var(i);
  }
  for (i = 1; i<=nvars(r) div 2; i++)
  {
    finalMapList[i + nvars(r)] = var(i)*var(i + (nvars(r) div 2));
  }
  map finalmap = tempRing,finalMapList;
  list result = finalmap(result);
  for (i=1; i<=size(result);i++)
  {//adding the K factor
    result[i] = k_factor + result[i];
  }//adding the k-factor
  dbprint(p,dbprintWhitespace +" Done");
  dbprint(p,dbprintWhitespace +" Delete double entries in the list.");
  result = delete_duplicates_noteval_and_sort(result);
  dbprint(p,dbprintWhitespace +" Done");
  result = normalizeFactors(result);
  return(delete_duplicates_noteval_and_sort(result));
}//proc homogfacNthQWeyl_all
example
{
  "EXAMPLE:";echo=2;
  ring R = (0,q1,q2,q3),(x1,x2,x3,d1,d2,d3),dp;
  matrix C[6][6] = 1,1,1,q1,1,1,
    1,1,1,1,q2,1,
    1,1,1,1,1,q3,
    1,1,1,1,1,1,
    1,1,1,1,1,1,
    1,1,1,1,1,1;
  matrix D[6][6] = 0,0,0,1,0,0,
    0,0,0,0,1,0,
    0,0,0,0,0,1,
    -1,0,0,0,0,0,
    0,-1,0,0,0,0,
    0,0,-1,0,0,0;
  def r = nc_algebra(C,D);
  setring(r);
  poly h =x1*x2^2*x3^3*d1*d2^2+x2*x3^3*d2;
  homogfacNthQWeyl_all(h);
}


static proc test_homogfacNthQWeyl_all()
{//testing homogfacNthQWeyl_all
  int result = 1;
  ring R = (0,q1,q2,q3,q4),(x1,x2,x3,x4,d1,d2,d3,d4),dp;
  matrix C[8][8] =
    1,1,1,1,q1,1,1,1,
    1,1,1,1,1,q2,1,1,
    1,1,1,1,1,1,q3,1,
    1,1,1,1,1,1,1,q4,
    1,1,1,1,1,1,1,1,
    1,1,1,1,1,1,1,1,
    1,1,1,1,1,1,1,1,
    1,1,1,1,1,1,1,1;
  matrix D[8][8] = 0,0,0,0,1,0,0,0,
    0,0,0,0,0,1,0,0,
    0,0,0,0,0,0,1,0,
    0,0,0,0,0,0,0,1,
    -1,0,0,0,0,0,0,0,
    0,-1,0,0,0,0,0,0,
    0,0,-1,0,0,0,0,0,
    0,0,0,-1,0,0,0,0;
  def r = nc_algebra(C,D);
  setring(r);
  //Test 1: 0
  poly input = 0;
  list expected = list(list(poly(0)));
  list obtained = homogfacNthQWeyl_all(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 1 for homogfacNthQWeyl_all failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: Random constant
  input = 3904/12;
  expected = list(list(poly(3904/12)));
  obtained = homogfacNthQWeyl_all(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 2 for homogfacNthQWeyl_all failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: monomial
  input = 5*d1*x1*d2;
  expected =sortFactorizations(
    list(list(number(5),d1,x1,d2),
     list(number(5),d1,d2,x1),
     list(number(5),d2,d1,x1)));
  obtained = homogfacNthQWeyl_all(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 3 for homogfacNthQWeyl_all failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: Zero dimensional
  input = ((x4*d4)^4 + 3/2*(x2*d2) + 5)*((x3*d3)^2+(x4*d4)^2+4);
  expected =sortFactorizations(
    list(
      list(number(1/2),2*(x4*d4)^4 + 3*(x2*d2) +
       10,((x3*d3)^2+(x4*d4)^2+4)),
      list(number(1/2),((x3*d3)^2+(x4*d4)^2+4),2*(x4*d4)^4 + 3*(x2*d2) +
       10)
      ));
  obtained = homogfacNthQWeyl_all(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 4 for homogfacNthQWeyl_all failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }

  return(result);
}//testing homogfacNthQWeyl_all



//==================================================
//***********General G-Algebra Part*****************
//==================================================

proc ncfactor(poly h)
"USAGE: ncfactor(h); h is a polynomial in a non-commutative polynomial
        algebra over a field k.
RETURN: list(list)
PURPOSE: Compute all factorizations of h.
THEORY: Implements an ansatz-driven factorization method as outlined
by Bell, Heinle and Levandovskyy in \"On Noncommutative Finite
Factorization Domains\".
ASSUME:
- k is a ring, such that factorize can factor any univariate and
  multivariate commutative polynomial over k.
- There exists at least one variable in the ring.
NOTE:
- works for both PLURAL and LETTERPLACE subsystems
- Every entry of the output list is a list with factors for one possible factorization.
  The first factor is always a constant (1, if no nontrivial constant
  could be excluded).
SEE ALSO: facWeyl, facSubWeyl, testNCfac
"{//proc ncfactor
  int p = printlevel-voice+2;
  int i;
  string dbprintWhitespace = "";
  for (i = 1; i<=voice;i++)
  {dbprintWhitespace = dbprintWhitespace + " ";}
  dbprint(p,dbprintWhitespace + "Checking if the field fulfills\
 everything we assume.");
  if (nvars(basering)<1)
  {ERROR("Ring does not have any variables.");return list(list());}
  if (char(basering)!=0)
  {
    if (minpoly !=0)
    {
      ERROR("factorize does not support fields of type (p^n,a) yet");
      return list(list());
    }
  }
  dbprint(p,dbprintWhitespace + "Everything seems to be alright with\
 the ground field.");
  if (deg(h)<=0)
  {
    dbprint(p,dbprintWhitespace + "h is a constant. Returning\
 immediately");
    return(list(list(h)));
  }
  dbprint(p,dbprintWhitespace+"Checking if a more improved algorithm\
 is available other than the naive ansatz-method.");
  dbprint(p,dbprintWhitespace+"1. Checking if h in commutative (sub)-ring");
  if (isInCommutativeSubRing(h))
  {//h is in a commutative subring
    return(factor_commutative(h));
  }//h is in a commutative subring
  dbprint(p,dbprintWhitespace+"h was not in a commutative\
 (sub)-ring.");
  dbprint(p,dbprintWhitespace+"2. Checking if h was in a letterplace ring");
  if ( attrib(basering, "isLetterplaceRing") >= 1 )
  {
    dbprint(p,dbprintWhitespace+
            "We are indeed in a letterplace ring. Forwarding the computation " +
            "to ncfactor-without-opt-letterplace");
    return(ncfactor_without_opt_letterplace(h));
  }
  dbprint(p,dbprintWhitespace+"2. Checking if h is in Weyl-Algebra over QQ");
  if (ncfactor_isWeyl()&&npars(basering)==0&&char(basering)==0)
  {
    dbprint(p,dbprintWhitespace +
            "We are indeed in a Weyl algebra. Forwarding computation to facWeyl");
    return(facWeyl(h));
  }
  dbprint(p,dbprintWhitespace+"Our ring is not a Weyl algebra over QQ.");
  dbprint(p,dbprintWhitespace+"3. Checking if we are in a q-Weyl algebra over QQ.");
  if (ncfactor_isQWeyl()&&char(basering)==0)
  {
    dbprint(p,dbprintWhitespace + "We are indeed in a q-Weyl\
 algebra over QQ. Checking if homogeneous.");
    if(homogwithorderNthWeyl(h))
    {
      dbprint(p,dbprintWhitespace+"h was homogeneous. Forwarding\
 computation to homogfacqweyl.");
      return(homogfacNthQWeyl_all(h));
    }
  }
  dbprint(p,dbprintWhitespace+"Our ring is not a q-Weyl algebra.");
  dbprint(p,dbprintWhitespace+"4. Checking if h is in a subalgebra\
 that resembles the Weyl algebra");
  if(isInWeylSubAlg(h)&&npars(basering)==0&&char(basering)==0)
  {
    dbprint(p,dbprintWhitespace+"We are indeed in a subalgebra that is\
 isomorphic to a Weyl algebra. Forwarding to facSubWeyl.");
    return(facSubWeyl(h));
  }
  dbprint(p,dbprintWhitespace+"No optimized algorithm available. Going \
 for the ansatz method without optimization.");
  return(ncfactor_without_opt(h));
}//proc ncfactor
example
{
  "EXAMPLE:";echo=2;
  // first, an example with PLURAL
  def R = makeUsl2();
  setring(R);
  poly p = e^3*f+e^2*f^2-e^3+e^2*f+2*e*f^2-3*e^2*h-2*e*f*h-8*e^2
           +e*f+f^2-4*e*h-2*f*h-7*e+f-h;
  ncfactor(p);
  kill R;
  // an example with LETTERPLACE
  LIB "freegb.lib";
  ring r = 0,(x,y),Dp;
  def R = freeAlgebra(r,5); setring(R);
  poly p = x*y*x - x;
  ncfactor(p);
}


static proc test_ncfactor()
{//testing ncfactor
  int result = 1;
  ring R = 0,(e,f,h),dp;
  def r = makeUsl2();
  setring r;
  //Test 1: 0
  poly input = 0;
  list expected = list(list(poly(0)));
  list obtained = ncfactor(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 1 for ncfactor failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: random constant
  input = 32095/235023;
  expected = list(list(poly(32095/235023)));
  obtained = ncfactor(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 2 for ncfactor failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: monomial
  input = 5*f*e*h;
  expected = sortFactorizations(
    list(
      list(number(5),f,e,h),
      list(number(5),f,h-2,e),
      list(number(5),h,f,e)
      ));
  obtained = ncfactor(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 3 for ncfactor failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4 polynomial in USL2
  input = (f*e + 4*h + 2)*(e*h^2 + f + 1);
  expected = sortFactorizations(
    list(
      list(number(1),(f*e + 4*h + 2),(e*h^2 + f + 1))

      ));
  obtained = ncfactor(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 4 for ncfactor failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill R; kill r;
  //Test 5: polynomial in Nth Weyl Algebra
  ring R = 0,(x(1..4),d(1..4)),dp;
  def r= Weyl();
  setring r;
  poly input = 4*(x(1)*d(2) + d(1))*(x(4)+x(2));
  list expected = list(
    list(number(4),(x(1)*d(2) + d(1)),(x(4)+x(2)))
    );
  list obtained = ncfactor(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 5 for ncfactor failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill r; kill R;
  //Test 6: polynomial in Nth Shift Algebra
  ring R = 0,(x1,x2,s1,s2),dp;
  matrix C[4][4] = 1,1,1,1,
    1,1,1,1,
    1,1,1,1,
    1,1,1,1;
  matrix D[4][4] = 0,0,s1,0,
    0,0,0,s2,
    -s1,0,0,0,
    0,-s2,0,0;
  def r = nc_algebra(C,D);
  setring(r);
  poly input = 4*(x1*s2 + s1)*(x1+s2);
  list expected = list(
    list(number(4),(x1*s2 + s1),(x1+s2))
    );
  list obtained = ncfactor(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 6 for ncfactor failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill r; kill R;
  //Test 7: homogeneous polynomial in Nth q-Weyl algebra
  ring R = (0,q1,q2,q3),(x1,x2,x3,d1,d2,d3),dp;
  matrix C[6][6] = 1,1,1,q1,1,1,
    1,1,1,1,q2,1,
    1,1,1,1,1,q3,
    1,1,1,1,1,1,
    1,1,1,1,1,1,
    1,1,1,1,1,1;
  matrix D[6][6] = 0,0,0,1,0,0,
    0,0,0,0,1,0,
    0,0,0,0,0,1,
    -1,0,0,0,0,0,
    0,-1,0,0,0,0,
    0,0,-1,0,0,0;
  def r = nc_algebra(C,D);
  setring(r);
  poly input = 4*(x1*d1 + 3*(x2*d2)^2)*(x3*d3 + 1);
  list expected = sortFactorizations(
    list(
      list(number(4),(x3*d3 + 1),(x1*d1 + 3*(x2*d2)^2)),
      list(number(4),(x1*d1 + 3*(x2*d2)^2),(x3*d3 + 1))
      ));
  list obtained = ncfactor(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 7 for ncfactor failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 8: Inhomogeneous polynomial nth q-Weyl
  input = 4*(x1*d1 + 3*(x2*d2)+q1*x1)*(x3*d3 + 1+q3*d2);
  expected = sortFactorizations(
    list(
      list(number(4),(x1*d1 + 3*(x2*d2)+q1*x1),(x3*d3 + 1+q3*d2))
      ));
  obtained = ncfactor(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 8 for ncfactor failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill r; kill R;
  //Test 9: SubWeyl Algebra
  ring R= 0,(x,y,z,f,a,b),dp;
  matrix C[6][6] =
    1,1,1,1,1,1,
    1,1,1,1,1,1,
    1,1,1,1,1,1,
    1,1,1,1,1,1,
    1,1,1,1,1,1,
    1,1,1,1,1,1;
  matrix D[6][6] =
    0,0,0,0,0,0,
    0,0,0,0,0,0,
    0,0,0,1,0,0,
    0,0,0,0,0,0,
    0,0,0,0,0,0,
    0,0,0,0,0,0;
  def r = nc_algebra(C,D);
  setring r;
  poly input = (4*z*f + 1)*((z*f)^2 + 4z*f - 3);
  list expected = list(
    list(number(1),(4*z*f + 1),((z*f)^2 + 4z*f - 3)),
    list(number(1),((z*f)^2 + 4z*f - 3),(4*z*f + 1))
    );
  list obtained = ncfactor(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 9 for ncfactor failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill r; kill R;
  //Test 10: Another random G-Algebra
  def r =makeUg2();
  setring r;
  poly input = (x(1) + Hb)*(Ha + 2*x(5));
  list expected = list(
    list(number(1),(x(1) + Hb),(Ha + 2*x(5)))
    );
  list obtained = ncfactor(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 10 for ncfactor failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill r;
  //Test 11: Generic Letterplace example
  ring r = 0,(x,y,z),dp;
  int d =4; // degree bound
  def R = makeLetterplaceRing(d);
  setring R;
  poly f1 = 6*x*y*x + 9*x;
  list obtained = ncfactor(f1);
  list expected = sortFactorizations(
    list(
      list(number(3), x, 2*y*x + 3),
      list(number(3), 2*x*y + 3, x)
      ));
  if (!isListEqual(expected,obtained))
  {
    print("Test 11 for ncfactor failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return (result);
}//testing ncfactor


static proc ncfactor_without_opt(poly h)
"USAGE: ncfactor_without_opt(h); h is a polynomial in a
        non-commutative polynomial algebra over a field k.
RETURN: list(list)
PURPOSE: Compute all factorizations of h, without making any
         sanity-checks
THEORY: Implements an ansatz-driven factorization method as outlined
by Bell, Heinle and Levandovskyy in \"On Noncommutative Finite
Factorization Domains\".
ASSUME:
- k is a ring, such that factorize can factor any univariate and
  multivariate commutative polynomial over k.
- There exists at least one variable in the ring.
- h is not a constant or 0.
NOTE:
- Every entry of the output list is a list with factors for one possible factorization.
  The first factor is always a constant (1, if no nontrivial constant
  could be excluded).
SEE ALSO: facWeyl, facSubWeyl, testNCfac, ncfactor
"{//proc ncfactor_without_opt
  int p = printlevel-voice+2;
  int i; int j; int k; int l;
  string dbprintWhitespace = "";
  for (i = 1; i<=voice;i++)
  {dbprintWhitespace = dbprintWhitespace + " ";}
  number commonCoefficient = content(h);
  poly hath = h/commonCoefficient;
  dbprint(p,dbprintWhitespace + "Calculating all possibilities of h as
 a combination of two factors.");
  list result = factorize_nc_s(hath);
  result = delete_duplicates_noteval_and_sort(result);
  dbprint(p,dbprintWhitespace + "Done. The result is:");
  dbprint(p,result);
  dbprint(p,dbprintWhitespace+"Recursively check factors for
 irreducibility");
  list recursivetemp;
  int changedSomething;
  for(i = 1; i<=size(result);i++)
  {//recursively factorize factors
    if(size(result[i])>1)
    {//Nontrivial factorization
      for (j=1;j<=size(result[i]);j++)
      {//Factorize every factor
        recursivetemp = factorize_nc_s(result[i][j]);
        recursivetemp = delete_duplicates_noteval(recursivetemp);
        changedSomething = 0;
        for(k=1; k<=size(recursivetemp);k++)
        {//insert factorized factors
          if(size(recursivetemp[k])>1)
          {//nontrivial
            changedSomething = 1;
            result = insert(result,result[i],i);
            for(l = size(recursivetemp[k]);l>=1;l--)
            {
              result[i+1] = insert(result[i+1],recursivetemp[k][l],j);
            }
            result[i+1] = delete(result[i+1],j);
          }//nontrivial
        }//insert factorized factors
        if (changedSomething)
        {break;}
      }//Factorize every factor
      if(changedSomething)
      {
        result = delete(result,i);
        continue;
      }
    }//Nontrivial factorization
  }//recursively factorize factors
  dbprint(p,dbprintWhitespace +" Done");
  dbprint(p,dbprintWhitespace + "Removing duplicates from the list");
  result = delete_duplicates_noteval_and_sort(result);
  for (i = 1; i<=size(result);i++)
  {//Putting the content everywhere
    result[i] = insert(result[i],commonCoefficient);
  }//Putting the content everywhere
  result = normalizeFactors(result);
  result = delete_duplicates_noteval_and_sort(result);
  dbprint(p,dbprintWhitespace +" Done");
  return(result);
}//proc ncfactor_without_opt


static proc test_ncfactor_without_opt()
{//testing ncfactor_without_opt
  int result = 1;
  ring R = 0,(e,f,h),dp;
  def r = makeUsl2();
  setring r;
  //Test 1: monomial
  poly input = 5*f*e*h;
  list expected = sortFactorizations(
    list(
      list(number(5),f,e,h),
      list(number(5),f,h-2,e),
      list(number(5),h,f,e)
      ));
  list obtained = ncfactor_without_opt(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 1 for ncfactor_without_opt failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2 polynomial in USL2
  input = (f*e + 4*h + 2)*(e*h^2 + f + 1);
  expected = sortFactorizations(
    list(
      list(number(1),(f*e + 4*h + 2),(e*h^2 + f + 1))

      ));
  obtained = ncfactor_without_opt(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 2 for ncfactor_without_opt failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill R; kill r;
  //Test 3: polynomial in Nth Weyl Algebra
  ring R = 0,(x(1..4),d(1..4)),dp;
  def r= Weyl();
  setring r;
  poly input = 4*(x(1)*d(2) + d(1))*(x(4)+x(2));
  list expected = list(
    list(number(4),(x(1)*d(2) + d(1)),(x(4)+x(2)))
    );
  list obtained = ncfactor_without_opt(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 3 for ncfactor_without_opt failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill r; kill R;
  //Test 4: polynomial in Nth Shift Algebra
  ring R = 0,(x1,x2,s1,s2),dp;
  matrix C[4][4] = 1,1,1,1,
    1,1,1,1,
    1,1,1,1,
    1,1,1,1;
  matrix D[4][4] = 0,0,s1,0,
    0,0,0,s2,
    -s1,0,0,0,
    0,-s2,0,0;
  def r = nc_algebra(C,D);
  setring(r);
  poly input = 4*(x1*s2 + s1)*(x1+s2);
  list expected = list(
    list(number(4),(x1*s2 + s1),(x1+s2))
    );
  list obtained = ncfactor_without_opt(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 4 for ncfactor_without_opt failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill r; kill R;
  //Test 5: homogeneous polynomial in Nth q-Weyl algebra
  ring R = (0,q1,q2,q3),(x1,x2,x3,d1,d2,d3),dp;
  matrix C[6][6] = 1,1,1,q1,1,1,
    1,1,1,1,q2,1,
    1,1,1,1,1,q3,
    1,1,1,1,1,1,
    1,1,1,1,1,1,
    1,1,1,1,1,1;
  matrix D[6][6] = 0,0,0,1,0,0,
    0,0,0,0,1,0,
    0,0,0,0,0,1,
    -1,0,0,0,0,0,
    0,-1,0,0,0,0,
    0,0,-1,0,0,0;
  def r = nc_algebra(C,D);
  setring(r);
  poly input = 4*(x1*d1 + 3*(x2*d2))*(x3*d3 + 1);
  list expected = sortFactorizations(
    list(
      list(number(4),(x3*d3 + 1),(x1*d1 + 3*(x2*d2))),
      list(number(4),(x1*d1 + 3*(x2*d2)),(x3*d3 + 1))
      ));
  list obtained = ncfactor_without_opt(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 5 for ncfactor_without_opt failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 6: Inhomogeneous polynomial nth q-Weyl
  input = 4*(x1*d1 + 3*(x2*d2)+q1*x1)*(x3*d3 + 1+q3*d2);
  expected = sortFactorizations(
    list(
      list(number(4),(x1*d1 + 3*(x2*d2)+q1*x1),(x3*d3 + 1+q3*d2))
      ));
  obtained = ncfactor_without_opt(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 6 for ncfactor_without_opt failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill r; kill R;
  //Test 7: SubWeyl Algebra
  ring R= 0,(x,y,z,f,a,b),dp;
  matrix C[6][6] =
    1,1,1,1,1,1,
    1,1,1,1,1,1,
    1,1,1,1,1,1,
    1,1,1,1,1,1,
    1,1,1,1,1,1,
    1,1,1,1,1,1;
  matrix D[6][6] =
    0,0,0,0,0,0,
    0,0,0,0,0,0,
    0,0,0,1,0,0,
    0,0,0,0,0,0,
    0,0,0,0,0,0,
    0,0,0,0,0,0;
  def r = nc_algebra(C,D);
  setring r;
  poly input = (4*z*f + 1)*((z*f)^2 + 4z*f - 3);
  list expected = list(
    list(number(1),(4*z*f + 1),((z*f)^2 + 4z*f - 3)),
    list(number(1),((z*f)^2 + 4z*f - 3),(4*z*f + 1))
    );
  list obtained = ncfactor_without_opt(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 7 for ncfactor_without_opt failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill r; kill R;
  //Test 8: Another random G-Algebra
  def r =makeUg2();
  setring r;
  poly input = (x(1) + Hb)*(Ha + 2*x(5));
  list expected = list(
    list(number(1),(x(1) + Hb),(Ha + 2*x(5)))
    );
  list obtained = ncfactor_without_opt(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 8 for ncfactor_without_opt failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return (result);
}//testing ncfactor_without_opt


static proc factorize_nc_s(poly h)
"USAGE: factorize_nc_s(h); h is a polynomial in an arbitrary
G-algebra G. Restrictions on the underlying field: only implemented for
fields for which factorize is implemented.
RETURN: list of lists
PURPOSE: Computes all factorizations of the polynomial h in G into two
factors a*b.
THEORY: G-Algebras are proven to be finite factorization
domains. Hence, an ansatz method will yield a zero-dimensional ideal,
whose zeros can be extracted.
NOTE: Ground field cannot be real or a Galois extension (factorize
does not work there).
ASSUMPTIONS:
- h is monic
"{//factorize_nc_s
  int p=printlevel-voice+2;//for dbprint
  int i; int j; int k; int l;
  string dbprintWhitespace = "";
  for (i = 1; i<=voice;i++)
  {dbprintWhitespace = dbprintWhitespace + " ";}
  list result;
  // Producing the set M of the paper (permutation of the variables in
  // the leading monomial)
  dbprint(p,dbprintWhitespace + "Generating the set M.");
  def r = basering;
  intvec maxDegrees = getMaxDegreeVec(h);
  intvec expVec = leadexp(h);
  dbprint(p,dbprintWhitespace + "Leading exponent vector of polynomial
  is " +string(expVec));
  list listToPermute = list();
  for (i = 1;i<=nvars(r);i++)
  {//filling an initial list
    for(j=1; j<=expVec[i];j++)
    {//different powers of the respective variable at position i
      listToPermute = listToPermute + list(var(i));
    }//different powers of the respective variable at position i
  }//filling an initial list
  dbprint(p,dbprintWhitespace + "Initial list to permute is "+
  string(listToPermute));
  list M = permpp(listToPermute);
  dbprint(p,dbprintWhitespace+"The set M is "+string(M));
  list list_UpToA;
  list list_UpToB;
  list clearSlateRingList = ringlist(r);
  clearSlateRingList[2] = list();
  clearSlateRingList[3] = list();
  clearSlateRingList = delete(clearSlateRingList, 6);
  clearSlateRingList = delete(clearSlateRingList, 5);
  list tempSringlist;
  intvec tempIntVec;
  def S; def W;
  list MEntry;
  poly tempA;
  poly tempB;
  int filterFlag;
  for(i=1; i<=size(M);i++)
  {//iterating over everything in M
    for (j = 1; j<size(M[i]); j++)
    {//picking combinations of leading coefficients for a and b
      MEntry = M[i];
      tempA = product(MEntry[1..j]);
      tempB = product(MEntry[(j+1)..(size(MEntry))]);
      dbprint(p,dbprintWhitespace + "The potential leading combination
 of a is " + string(tempA));
      dbprint(p,dbprintWhitespace + "The potential leading combination
 of b is " + string(tempB));
      list_UpToA = monsSmallerThan(leadmonom(tempA),
                                   maxDegrees - getMaxDegreeVec(tempB));
      list_UpToB = monsSmallerThan(leadmonom(tempB),
                                   maxDegrees - getMaxDegreeVec(tempA));
      //we need to filter out lm(tempA) and lm(tempB);
      for (k = size(list_UpToA); k>0; k--)
      {//removing the leading monomial from list_UpToA and invalid parts
        if (list_UpToA[k] == leadmonom(tempA))
        {//found it
          list_UpToA = delete(list_UpToA,k);
          continue;
        }//found it
        if(deg(h,1:(nvars(basering)))<deg(list_UpToA[k],1:(nvars(basering))))
        {//total degree exceeds
          list_UpToA = delete(list_UpToA,k);
          continue;
        }//total degree exceeds
      }//removing the leading monomial from list_UpToA and invalid parts
      for (k = size(list_UpToB); k>0; k--)
      {//removing the leading monomial from list_UpToA
        if (list_UpToB[k] == leadmonom(tempB))
        {//found it
          list_UpToB = delete(list_UpToB,k);
          continue;
        }//found it
        if(deg(h,1:(nvars(basering)))<deg(list_UpToB[k],1:(nvars(basering))))
        {//total degree exceeds
          list_UpToB = delete(list_UpToB,k);
          continue;
        }//total degree exceeds
      }//removing the leading monomial from list_UpToA
      // creating the coefficient ring S
      tempSringlist = clearSlateRingList;
      for (k = size(list_UpToB)+1; k>=0; k--)
      {//fill in b-coefficients as variables
        tempSringlist[2] = insert(tempSringlist[2],"b("+string(k)+")");
      }//fill in b-coefficients as variables
      for (k = size(list_UpToA); k>=0; k--)
      {//fill in a-coefficients as variables
        tempSringlist[2] = insert(tempSringlist[2],"a("+string(k)+")");
      }//fill in a-coefficients as variables
      tempIntVec =0;
      for(k=1; k<=size(list_UpToA) + size(list_UpToB)+3; k++)
      {tempIntVec[k] = 1;}
      tempSringlist[3] =
        list(list("lp",tempIntVec),list("C",intvec(0)));
      S = ring(tempSringlist);
      dbprint(p,dbprintWhitespace+"Done generating ring S:");
      dbprint(p,dbprintWhitespace+string(S));
      dbprint(p,dbprintWhitespace+"Generate the ansatz.");
      W = r+S;
      setring(W);
      poly h = imap(r, h);
      poly a = imap(r,tempA);
      poly b = imap(r,tempB);
      if (!defined(list_UpToA))
      {list list_UpToA = imap(r,list_UpToA);}
      if (!defined(list_UpToB))
      {list list_UpToB = imap(r,list_UpToB);}
      b = b*var(nvars(r) +size(list_UpToA)+size(list_UpToB)+3);
      for (k = size(list_UpToB); k>0; k--)
      {b = b + var(nvars(r)+size(list_UpToA)+2+k)*list_UpToB[k];}
      b = b + var(nvars(r) + size(list_UpToA) + 2);
      dbprint(p,dbprintWhitespace + "The ansatz for b is " + string(b));
      for (k = size(list_UpToA); k>0; k--)
      {a = a + var(nvars(r)+k+1)*list_UpToA[k];}
      a = a + var(nvars(r)+1);
      dbprint(p,dbprintWhitespace + "The ansatz for a is " + string(a));
      poly ansatzPoly = a*b -h;
      def listOfRelations = coeffs(ansatzPoly,var(1));
      for (k = 2;k<=nvars(r);k++)
      {listOfRelations = coeffs(listOfRelations,var(k));}
      setring(S);
      ideal listOfRelations = imap(W,listOfRelations);
      option(redSB);
      option(redTail);
      dbprint(p,dbprintWhitespace + "Calculating the solutions of:");
      dbprint(p,listOfRelations);
      def sol = facstd(listOfRelations);
      dbprint(p,dbprintWhitespace + "Filtering the solutions that are
 not in the base-field.");
      for(k = 1; k <=size(sol);k++)
      {//filtering what is not in the ground-field
        filterFlag = 0;
        for (l=1; l<=size(sol[k]); l++)
        {
          if ((deg(sol[k][l])>1) or ((sol[k][l]/leadcoef(sol[k][l])==1)))
          {//Not in the ground field
            filterFlag = 1;
            break;
          }//Not in the ground field
        }
        if (filterFlag or (vdim(std(sol[k]))<0))
        {//In this case, we can delete that whole entry and move on
          sol= delete(sol,k);
          continue;
        }//In this case, we can delete that whole entry and move on
      }//filtering what is not in the ground-field
      dbprint(p,dbprintWhitespace + "Solutions for the coefficients
 are:");
      dbprint(p,sol);
      setring(W);
      if (!(defined(solTrans)))
      {
        if (!defined(sol))
        {def solTrans = imap(S,sol);}
        else
        {def solTrans = sol;}
      }
      else
      {
        if (!defined(sol))
        {solTrans = imap(S,sol);}
        else
        {solTrans = sol;}
      }
      if (defined(sol))
      {
        kill sol;
      }
      if (!(defined(tempResult)))
      {list tempResult;}
      tempResult = list();
      for (k = 1; k<=size(solTrans); k++)
      {
        tempResult = insert(tempResult,list(NF(a,std(solTrans[k])),
                                            NF(b,std(solTrans[k]))));
      }
      setring(r);
      if (!defined(tempResult))
      {def tempResult = imap(W,tempResult);}
      for (k=1; k<= size(tempResult);k++)
      {
        result = insert(result,tempResult[k]);
      }
      kill tempResult;
    }//picking combinations of leading coefficients for a and b
  }//iterating over everything in M
  if (size(result)==0)
  {
    return (list(list(h)));
  }
  else
  {
    return (delete_duplicates_noteval_and_sort(result));
  }
}//factorize_nc_s


static proc test_factorize_nc_s()
{//testing factorize_nc_s
  int result = 1;
  ring R = 0,(e,f,h),dp;
  def r = makeUsl2();
  setring r;
  //Test 1: monomial
  poly input = f*e*h;
  list expected = sortFactorizations(
    list(
      list(f*e,h),
      list(f,e*h),
      list(h*f,e),
      list(h,f*e)
      ));
  list obtained = factorize_nc_s(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 1 for factorize_nc_s failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2 polynomial in USL2
  input = (f*e + 4*h + 2)*(e*h^2 + f + 1);
  expected = sortFactorizations(
    list(
      list((f*e + 4*h + 2),(e*h^2 + f + 1))

      ));
  obtained = factorize_nc_s(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 2 for factorize_nc_s failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill R; kill r;
  //Test 3: polynomial in Nth Weyl Algebra
  ring R = 0,(x(1..4),d(1..4)),dp;
  def r= Weyl();
  setring r;
  poly input = (x(1)*d(2) + d(1))*(x(4)+x(2));
  list expected = list(
    list((x(1)*d(2) + d(1)),(x(4)+x(2)))
    );
  list obtained = factorize_nc_s(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 3 for factorize_nc_s failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill r; kill R;
  //Test 4: polynomial in Nth Shift Algebra
  ring R = 0,(x1,x2,s1,s2),dp;
  matrix C[4][4] = 1,1,1,1,
    1,1,1,1,
    1,1,1,1,
    1,1,1,1;
  matrix D[4][4] = 0,0,s1,0,
    0,0,0,s2,
    -s1,0,0,0,
    0,-s2,0,0;
  def r = nc_algebra(C,D);
  setring(r);
  poly input = (x1*s2 + s1)*(x1+s2);
  list expected = list(
    list((x1*s2 + s1),(x1+s2))
    );
  list obtained = factorize_nc_s(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 4 for factorize_nc_s failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill r; kill R;
  //Test 5: homogeneous polynomial in Nth q-Weyl algebra
  ring R = (0,q1,q2,q3),(x1,x2,x3,d1,d2,d3),dp;
  matrix C[6][6] = 1,1,1,q1,1,1,
    1,1,1,1,q2,1,
    1,1,1,1,1,q3,
    1,1,1,1,1,1,
    1,1,1,1,1,1,
    1,1,1,1,1,1;
  matrix D[6][6] = 0,0,0,1,0,0,
    0,0,0,0,1,0,
    0,0,0,0,0,1,
    -1,0,0,0,0,0,
    0,-1,0,0,0,0,
    0,0,-1,0,0,0;
  def r = nc_algebra(C,D);
  setring(r);
  poly input = (x1*d1 + 3*(x2*d2))*(x3*d3 + 1);
  list expected = sortFactorizations(
    list(
      list((x3*d3 + 1),(x1*d1 + 3*(x2*d2))),
      list((x1*d1 + 3*(x2*d2)),(x3*d3 + 1))
      ));
  list obtained = factorize_nc_s(input);
  obtained = normalizeFactors(obtained);
  obtained = delete_duplicates_noteval_and_sort(obtained);
  if (!isListEqual(expected,obtained))
  {
    print("Test 5 for factorize_nc_s failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 6: Inhomogeneous polynomial nth q-Weyl
  input =(x1*d1 + 3*(x2*d2)+q1*x1)*(x3*d3 + 1+q3*d2);
  expected = sortFactorizations(
    list(
      list((x1*d1 + 3*(x2*d2)+q1*x1),(x3*d3 + 1+q3*d2))
      ));
  obtained = factorize_nc_s(input);
  obtained = normalizeFactors(obtained);
  obtained = delete_duplicates_noteval_and_sort(obtained);
  if (!isListEqual(expected,obtained))
  {
    print("Test 6 for factorize_nc_s failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill r; kill R;
  //Test 7: SubWeyl Algebra
  ring R= 0,(x,y,z,f,a,b),dp;
  matrix C[6][6] =
    1,1,1,1,1,1,
    1,1,1,1,1,1,
    1,1,1,1,1,1,
    1,1,1,1,1,1,
    1,1,1,1,1,1,
    1,1,1,1,1,1;
  matrix D[6][6] =
    0,0,0,0,0,0,
    0,0,0,0,0,0,
    0,0,0,1,0,0,
    0,0,0,0,0,0,
    0,0,0,0,0,0,
    0,0,0,0,0,0;
  def r = nc_algebra(C,D);
  setring r;
  poly input = (4*z*f + 1)*((z*f)^2 + 4z*f - 3);
  list expected = list(
    list((4*z*f + 1),((z*f)^2 + 4z*f - 3)),
    list(((z*f)^2 + 4z*f - 3),(4*z*f + 1))
    );
  list obtained = factorize_nc_s(input);
  obtained = normalizeFactors(obtained);
  obtained = delete_duplicates_noteval_and_sort(obtained);
  if (!isListEqual(expected,obtained))
  {
    print("Test 7 for factorize_nc_s failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  kill r; kill R;
  //Test 8: Another random G-Algebra
  def r =makeUg2();
  setring r;
  poly input = (x(1) + Hb)*(Ha + 2*x(5));
  list expected = list(
    list((x(1) + Hb),(Ha + 2*x(5)))
    );
  list obtained = factorize_nc_s(input);
  if (!isListEqual(expected,obtained))
  {
    print("Test 8 for factorize_nc_s failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return (result);
}//testing factorize_nc_s


static proc getMaxDegreeVecLetterPlace(poly h)
"USAGE: getMaxDegreeVecLetterPlace(h); h is a polynomial in a
        Letterplace ring.
RETURN: intvec
PURPOSE: Returns for each variable in the ring the maximal
         degree in which it appears in h.
ASSUMING: The basering is
"
{//proc getMaxDegreeVecLetterPlace
  int lv = attrib(basering, "isLetterplaceRing"); // nvars of orig ring
  if (h == 0) { return (0:lv); }
  intvec tempIntVec1 = 0:lv;
  intvec maxDegrees = 0:lv;
  intvec tempIntVec2;
  int i; int j;
  for (i = 1; i<=size(h); i++)
  {//going through each monomial in h and finding the degree in each var
    tempIntVec2 = lp2iv(h[i]);
    if (tempIntVec2 == 0)
    {
      i++; continue;
    }
    tempIntVec1 = 0:lv;
    for (j=1; j<=size(tempIntVec2); j++)
    {//filling in the number of occurrences
      tempIntVec1[tempIntVec2[j]] = tempIntVec1[tempIntVec2[j]] + 1;
    }//filling in the number of occurrences
    for (j = 1; j<=lv; j++)
    {//putting the max into maxDegrees
      maxDegrees[j] = max(maxDegrees[j], tempIntVec1[j]);
    }//putting the max into maxDegrees
  }//going through each monomial in h and finding the degree in each var
  return(maxDegrees);
}//proc getMaxDegreeVecLetterPlace

static proc test_getMaxDegreeVecLetterPlace()
{//testing getMaxDegreeVecLetterPlace
  int result = 1;
  ring r = 0,(x,y,z),dp;
  int d =4; // degree bound
  def R = makeLetterplaceRing(d);
  setring R;
  //Test 1: 0
  intvec expected = 0:3;
  intvec obtained = getMaxDegreeVecLetterPlace(0);
  if (expected!=obtained)
  {
    print("Test 1 for getMaxDegreeVecLetterPlace failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: Constant neq 0
  expected = 0:3;
  obtained = getMaxDegreeVecLetterPlace(3);
  if (expected!=obtained)
  {
    print("Test 2 for getMaxDegreeVecLetterPlace failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: univariate, first variable
  expected = 2, 0, 0;
  obtained = getMaxDegreeVecLetterPlace(5*x*x + x + 1);
  if (expected!=obtained)
  {
    print("Test 3 for getMaxDegreeVecLetterPlace failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: univariate, another variable
  expected = 0, 0, 3;
  obtained = getMaxDegreeVecLetterPlace(5*z*z*z + z*z + 1);
  if (expected!=obtained)
  {
    print("Test 4 for getMaxDegreeVecLetterPlace failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 5: random polynomial
  expected = 3, 1, 2;
  obtained = getMaxDegreeVecLetterPlace(2*x*y*x*x + 4*y*z*z);
  if (expected!=obtained)
  {
    print("Test 5 for getMaxDegreeVecLetterPlace failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//testing getMaxDegreeVecLetterPlace

static proc wordsWithMaxAppearance(intvec maxDegInCoordinates, int upToDeg)
"USAGE: wordsWithMaxAppearance(maxDegInCoordinates);
maxDegreeInCoordinates is an intvec.
RETURN: list
PURPOSE: maxDegInCoordinates is a vector representing
the maximum times a variable is allowed to appear in a monomial in
letterplace representation. This function computes all possible words
given this restriction.
ASSUME: maxDegInCoordinates only has non-negative entries
"{//wordsWithMaxAppearance
  int p=printlevel-voice+2;//for dbprint
  int i; int j;
  string dbprintWhitespace = "";
  for (i = 1; i<=voice;i++)
  {dbprintWhitespace = dbprintWhitespace + " ";}
  list result;
  intvec tempMaxDegs;
  list recResult;
  for (i = 1; i<=size(maxDegInCoordinates); i++)
  {//For each coordinate not equal to zero, do a recursive call and concatenate
    if (maxDegInCoordinates[i] <= 0)
    {//Done with coordinate i
      i++; continue;
    }//Done with coordinate i
    tempMaxDegs = maxDegInCoordinates;
    tempMaxDegs[i] = tempMaxDegs[i] - 1;
    recResult = wordsWithMaxAppearance(tempMaxDegs, upToDeg);
    if (size(recResult) == 0 && upToDeg>=1)
    {//Single entry just needs to be there
      result = result + list(intvec(i));
    }//Single entry just needs to be there
    result = result + recResult;
    for (j = 1; j<=size(recResult); j++)
    {//concatenate i to all elements in recResult
      if (size(recResult[j]) + 1 <= upToDeg)
      {//only concatenate if uptodeg is not exceeded
    recResult[j] = intvec(i, recResult[j]);
      }//only concatenate if uptodeg is not exceeded
    }//concatenate i to all elements in recResult
    result = result + recResult;
  }//For each coordinate not equal to zero, do a recursive call and concatenate
  return(delete_duplicates_noteval_and_sort(result));
}//wordsWithMaxAppearance

static proc test_wordsWithMaxAppearance()
{//test_wordsWithMaxAppearance
  int result = 1;
  //Test 1: 0 intvec
  list expected = list();
  list obtained = wordsWithMaxAppearance(intvec(0), 4);
  if (!isListEqual(expected,obtained))
  {
    print("Test 1 for wordsWithMaxAppearance failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: 0 multiple entries intvec
  expected = list();
  obtained = wordsWithMaxAppearance(0:10, 4);
  if (!isListEqual(expected,obtained))
  {
    print("Test 2 for wordsWithMaxAppearance failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: Single letter
  expected = list(intvec(4));
  obtained = wordsWithMaxAppearance(intvec(0, 0, 0, 1, 0, 0), 4);
  if (!isListEqual(expected,obtained))
  {
    print("Test 3 for wordsWithMaxAppearance failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: Two letters, one appearance
  expected = list(intvec(3), intvec(3,4), intvec(4), intvec(4,3));
  obtained = wordsWithMaxAppearance(intvec(0, 0, 1, 1, 0, 0), 4);
  if (!isListEqual(expected,obtained))
  {
    print("Test 4 for wordsWithMaxAppearance failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 5: One letter, degree 2
  expected = list(intvec(4), intvec(4,4));
  obtained = wordsWithMaxAppearance(intvec(0, 0, 0, 2, 0, 0), 4);
  if (!isListEqual(expected,obtained))
  {
    print("Test 5 for wordsWithMaxAppearance failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 6: random example
  expected = list(intvec(1),
          intvec(1,4),
          intvec(1,4,4),
          intvec(4),
          intvec(4,1),
          intvec(4,1,4),
          intvec(4,4),
          intvec(4,4,1));
  obtained = wordsWithMaxAppearance(intvec(1, 0, 0, 2, 0, 0), 4);
  if (!isListEqual(expected,obtained))
  {
    print("Test 6 for wordsWithMaxAppearance failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//test_wordsWithMaxAppearance

static proc monsSmallerThanLetterPlace(poly e, intvec maxDegInCoordinates, int upToDeg)
"USAGE: monsSmallerThanLetterPlace(e, maxDegInCoordinates); e is a
monomial.
maxDegreeInCoordinates encodes the maximal degree we wish to encounter
in each variable.
RETURN: list
PURPOSE: Computes all monomials in the basering which are degree-wise
smaller than the leading monomial of e.
"{//monsSmallerThanLetterPlace
  int p=printlevel-voice+2;//for dbprint
  int i;
  string dbprintWhitespace = "";
  for (i = 1; i<=voice;i++)
  {dbprintWhitespace = dbprintWhitespace + " ";}
  list result;
  int maxLen = min(sum(maxDegInCoordinates), lpDegBound(basering));
  dbprint(p,dbprintWhitespace + "maxLength: " + string(maxLen));
  list allPossibilities = wordsWithMaxAppearance(maxDegInCoordinates, upToDeg);
  dbprint(p,dbprintWhitespace + "words with max appearance: " + string(allPossibilities));
  poly candidate;
  intvec candidateMaxDeg;
  for (i = 1; i<=size(allPossibilities); i++)
  {//checking for monomials with smaller degree than e
    candidate = iv2lp(allPossibilities[i]);
    dbprint(p,dbprintWhitespace + "Checking candidate: " + string(candidate));
    candidateMaxDeg = getMaxDegreeVecLetterPlace(candidate);
    if (candidate < e && candidateMaxDeg <= maxDegInCoordinates)
    {//successfully found a candidate
      result = insert(result, candidate);
    }//successfully found a candidate
  }//checking for monomials with smaller degree than e
  return(result);
}//monsSmallerThanLetterPlace

static proc test_monsSmallerThanLetterPlace()
{//test_monsSmallerThanLetterPlace
  int result = 1;
  ring r = 0,(x,y,z,d,w),dp;
  int upToDegBound = 10; // degree bound
  def R = makeLetterplaceRing(upToDegBound);
  setring R;
  //Test 1: 0, 0
  poly input1 = 0;
  intvec input2 = intvec(0,0,0,0,0);
  list expected = list();
  list obtained = monsSmallerThanLetterPlace(input1, input2, upToDegBound);
  if (!isListEqual(expected,obtained))
  {
    print("Test 1 for monsSmallerThanLetterPlace failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 2: 0, nontrivial maxdegree
  input1 = 0;
  input2 = intvec(0,0,2,1,0);
  expected = list();
  obtained = monsSmallerThanLetterPlace(input1, input2, upToDegBound );
  if (!isListEqual(expected,obtained))
  {
    print("Test 2 for monsSmallerThanLetterPlace failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 3: constant, nontrivial maxdegree
  input1 = 7;
  input2 = intvec(0,0,2,1,0);
  expected = list();
  obtained = monsSmallerThanLetterPlace(input1, input2, upToDegBound);
  if (!isListEqual(expected,obtained))
  {
    print("Test 3 for monsSmallerThanLetterPlace failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 4: single variable smallest, nontrivial maxdegree
  input1 = w;
  input2 = intvec(0,0,2,1,0);
  expected = list();
  obtained = monsSmallerThanLetterPlace(input1, input2, upToDegBound );
  if (!isListEqual(expected,obtained))
  {
    print("Test 4 for monsSmallerThanLetterPlace failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 5: single variable highest, nontrivial maxdegree
  input1 = x;
  input2 = intvec(0,0,2,1,0);
  expected = list(d, z);
  obtained = monsSmallerThanLetterPlace(input1, input2, upToDegBound);
  if (!isListEqual(expected,obtained))
  {
    print("Test 5 for monsSmallerThanLetterPlace failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 6: single variable highest, nontrivial maxdegree
  input1 = x;
  input2 = intvec(0,0,2,1,0);
  expected = list(d, z);
  obtained = monsSmallerThanLetterPlace(input1, input2, upToDegBound );
  if (!isListEqual(expected,obtained))
  {
    print("Test 6 for monsSmallerThanLetterPlace failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 7: nontrivial monomial, nontrivial maxdegree
  input1 = z*z*d*d;
  input2 = intvec(0,0,2,1,0);
  expected = list(d*z*z,
          d*z,
          d,
          z*d*z,
          z*d,
          z*z*d,
          z*z,
          z);
  obtained = monsSmallerThanLetterPlace(input1, input2, upToDegBound);
  if (!isListEqual(expected,obtained))
  {
    print("Test 7 for monsSmallerThanLetterPlace failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return(result);
}//test_monsSmallerThanLetterPlace

static proc ncfactor_letterplace_poly_s(poly h)
"USAGE: ncfactor_letterplace_poly_s(h); h is a polynomial in a
        letterplace algebra
RETURN: list(list)
PURPOSE: Compute all factorizations of h
THEORY: Implements an ansatz-driven factorization method as outlined
by Bell, Heinle and Levandovskyy in \"On Noncommutative Finite
Factorization Domains\".
ASSUME:
- basering is a Letterplace ring
- basefield is such, that factorize() can factor any univariate and
  multivariate commutative polynomial over it.
- h is not a constant or 0.
NOTE:
- Every entry of the output list is a list with factors for one possible factorization.
  The first factor is always a constant (1, if no nontrivial constant
  could be excluded).
SEE ALSO: ncfactor
"{//proc ncfactor_letterplace_poly_s
  int p=printlevel-voice+2;//for dbprint
  int i; int j; int k; int l;
  string dbprintWhitespace = "";
  for (i = 1; i<=voice;i++)
  {dbprintWhitespace = dbprintWhitespace + " ";}
  list result;
  // Producing the set M of the paper (permutation of the variables in
  // the leading monomial)
  dbprint(p,dbprintWhitespace + "Generating the set M.");
  def r = basering;
  intvec maxDegrees = getMaxDegreeVecLetterPlace(h);
  dbprint(p,dbprintWhitespace + "The maximum degrees for each var are given by: "+
      string(maxDegrees));
  intvec expVec = lp2iv(leadmonom(h));
  dbprint(p, dbprintWhitespace + "The leading monomial of h is: " + string(expVec));
  list M;
  for (i = 1; i<size(expVec); i++)
  {//The set M consists of all possible two-word-combinations of the leading monomial
    M = M + list(list(intvec(expVec[1..i]), intvec(expVec[i+1..size(expVec)])));
  }
  dbprint(p,dbprintWhitespace+"The set M is:");
  dbprint(p, M);
  list list_UpToA;
  list list_UpToB;
  list tempSringlist = ringlist(r);
  list clearSlateRingList = ringlist(r);
  clearSlateRingList[2] = list();
  clearSlateRingList[3] = list();
  if (size(clearSlateRingList) == 6)
  {//some non-commutative relations defined
    clearSlateRingList = delete(clearSlateRingList, 6);
    clearSlateRingList = delete(clearSlateRingList, 5);
  }
  else
  {//It is still possible that we have a 5th entry
    if (size(clearSlateRingList) == 5)
    {
      clearSlateRingList = delete(clearSlateRingList, 5);
    }
  }
  intvec tempIntVec;
  def S; def W; def W2;
  list MEntry;
  poly tempA;
  poly tempB;
  int filterFlag;
  int jj = 1; int sizeOfSol = 1;
  for (i = 1; i<=size(M); i++)
  {//Iterating over all two-combinations in the set M
    MEntry = M[i];
    tempA = iv2lp(MEntry[1]);
    tempB = iv2lp(MEntry[2]);
    dbprint(p,dbprintWhitespace + "The potential leading combination of a is " + string(tempA));
    dbprint(p,dbprintWhitespace + "The potential leading combination of b is " + string(tempB));
    dbprint(p,dbprintWhitespace + "Calculating the monomials smaller than A");
    list_UpToA = monsSmallerThanLetterPlace(leadmonom(tempA),
                        maxDegrees - getMaxDegreeVecLetterPlace(tempB),
                        lpDegBound(r));
    dbprint(p,dbprintWhitespace + "Done, they are: " + string(list_UpToA));
    dbprint(p,dbprintWhitespace + "Calculating the monomials smaller than B");
    list_UpToB = monsSmallerThanLetterPlace(leadmonom(tempB),
                        maxDegrees - getMaxDegreeVecLetterPlace(tempA),
                        lpDegBound(r));
    dbprint(p,dbprintWhitespace + "Done, they are: " + string(list_UpToB));
    //we need to filter out lm(tempA) and lm(tempB);
    for (k = size(list_UpToA); k>0; k--)
    {//removing the leading monomial from list_UpToA and invalid parts
      if (list_UpToA[k] == leadmonom(tempA))
      {//found it
    list_UpToA = delete(list_UpToA,k);
    continue;
      }//found it
      if(sum(getMaxDegreeVecLetterPlace(h)) < sum(getMaxDegreeVecLetterPlace(list_UpToA[k])))
      {//total degree exceeds
    list_UpToA = delete(list_UpToA,k);
    continue;
      }//total degree exceeds
    }//removing the leading monomial from list_UpToA and invalid parts
    for (k = size(list_UpToB); k>0; k--)
    {//removing the leading monomial from list_UpToA
      if (list_UpToB[k] == leadmonom(tempB))
      {//found it
    list_UpToB = delete(list_UpToB,k);
    continue;
      }//found it
      if(sum(getMaxDegreeVecLetterPlace(h)) < sum(getMaxDegreeVecLetterPlace(list_UpToB[k])))
      {//total degree exceeds
    list_UpToB = delete(list_UpToB,k);
    continue;
      }//total degree exceeds
    }//removing the leading monomial from list_UpToA
    if (typeof(tempSringlist[1]) == "int")
    {//No extra parameters in the original ring
      tempSringlist[1] = list(tempSringlist[1],list(), list(list()));
    }//No extra parameters in the original ring
    for (k = size(list_UpToB)+1; k>=0; k--)
    {//fill in b-coefficients as variables
      tempSringlist[1][2] = insert(tempSringlist[1][2],"@b("+string(k)+")");
      clearSlateRingList[2] = insert(clearSlateRingList[2],"@b("+string(k)+")");
    }//fill in b-coefficients as variables
    for (k = size(list_UpToA); k>=0; k--)
    {//fill in a-coefficients as variables
      tempSringlist[1][2] = insert(tempSringlist[1][2],"@a("+string(k)+")");
      clearSlateRingList[2] = insert(clearSlateRingList[2], "@a("+string(k)+")");
    }//fill in a-coefficients as variables
    tempIntVec = 0;
    for(k=1; k<=size(list_UpToA) + size(list_UpToB)+3; k++)
    {tempIntVec[k] = 1;}
    clearSlateRingList[3] =
      list(list("lp",tempIntVec),list("C",intvec(0)));
    if (size(tempSringlist[1][3][1]) == 0)
    {//No values in there before
      tempSringlist[1][3][1] =
    list("lp", tempIntVec);
      tempSringlist[1][4] = ideal(0);
    }//No values in there before
    else
    {//there were other parameters
      tempSringlist[1][3][1][2] = tempSringlist[1][3][1][2], tempIntVec;
    }//there were other parameters
    attrib(tempSringlist, "isLetterplaceRing", attrib(r,"isLetterplaceRing"));
    attrib(tempSringlist, "maxExp", 1);
    if (defined(S)) {
      kill S;
    }
    def S = ring(tempSringlist); setring S;
    attrib(S, "uptodeg", lpDegBound(r));
    attrib(S, "isLetterplaceRing", attrib(r,"isLetterplaceRing"));
    dbprint(p,dbprintWhitespace+"Done generating ring S:");
    dbprint(p,dbprintWhitespace+string(S));
    dbprint(p,dbprintWhitespace+"Generate the ansatz.");
    dbprint(p,dbprintWhitespace+"The new ring is: " + string(basering));
    setring(S);
    poly h = imap(r, h);
    poly a = imap(r,tempA);
    poly b = imap(r,tempB);
    if (!defined(list_UpToA))
    {list list_UpToA = imap(r,list_UpToA);}
    if (!defined(list_UpToB))
    {list list_UpToB = imap(r,list_UpToB);}
    b = b*par(size(list_UpToA)+size(list_UpToB)+3);
    for (k = size(list_UpToB); k>0; k--)
    {b = b + par(size(list_UpToA)+2+k)*list_UpToB[k];}
    b = b + par(size(list_UpToA) + 2);
    dbprint(p,dbprintWhitespace + "The ansatz for b is " + string(b));
    for (k = size(list_UpToA); k>0; k--)
    {a = a + par(k+1)*list_UpToA[k];}
    a = a + par(1);
    dbprint(p,dbprintWhitespace + "The ansatz for a is " + string(a));
    poly ansatzPoly = a*b - h;
    dbprint(p,dbprintWhitespace + "The ansatzpoly is " + string(ansatzPoly));
    ideal listOfRelations = coeffs(ansatzPoly, var(1));
    for (k = 2;k<=nvars(r);k++)
    {listOfRelations = coeffs(listOfRelations,var(k));}
    setring(r);
    W = ring(clearSlateRingList); // comm ring of coeffs of the ansatz
    W2 = W+r; // first coeffs, then orig letterplace vars
    setring(W);
    ideal listOfRelations = imap(S, listOfRelations);
    option(redSB);
    option(redTail);
    dbprint(p,dbprintWhitespace + "Calculating the solutions of:");
    dbprint(p,listOfRelations);
    if (!defined(sol))
    {
      def sol = facstd(listOfRelations);
    }
    else
    {
      sol = facstd(listOfRelations);
    }
    dbprint(p,dbprintWhitespace + "Filtering the solutions that are " +
      "not in the base-field.");
    for(k = 1; k <=size(sol);k++)
    {//filtering what is not in the ground-field
      filterFlag = 0;
      for (l=1; l<=size(sol[k]); l++)
      {
        if ((deg(sol[k][l])>1) or ((sol[k][l]/leadcoef(sol[k][l])==1)))
        {//Not in the ground field
          filterFlag = 1;
          break;
        }//Not in the ground field
      }
      if (filterFlag or (vdim(std(sol[k]))<0))
      {//In this case, we can delete that whole entry and move on
        sol= delete(sol,k);
        continue;
      }//In this case, we can delete that whole entry and move on
    }//filtering what is not in the ground-field
    dbprint(p,dbprintWhitespace + "Solutions for the coefficients are:");
    dbprint(p,sol);
    setring S;
    ideal a_coef; jj=1;
    while (a[jj]!=0)
    {
      a_coef[jj]=leadcoef(a[jj]);
      jj++;
    }
    ideal b_coef;
    jj=1;
    while (b[jj]!=0)
    {
      b_coef[jj]=leadcoef(b[jj]);
      jj++;
    }
    setring W; //W = ring of coeffs_variables
    ideal a_coef = imap(S, a_coef);
    ideal b_coef = imap(S, b_coef);
    sizeOfSol = size(sol);
    if (!defined(tempResultCoeffs)) {
      list tempResultCoeffs;
    }
    tempResultCoeffs = list();
    for (k=1; k<=sizeOfSol; k++)
    {
      sol[k] = std(sol[k]);
      tempResultCoeffs = insert(tempResultCoeffs, list(
      NF(a_coef, sol[k]), // element-wise
      NF(b_coef, sol[k]))); // element-wise
    }
    setring S;
    if(!defined(tempResultCoeffs)) {
      list tempResultCoeffs = imap(W, tempResultCoeffs);
    }
    if (!(defined(tempResult)))
    {list tempResult;}
    poly ared;
    poly bred;
    for (k = 1; k <= size(tempResultCoeffs); k++)
    {//Creating the resulting polynomials with the respective coeffs.
      jj=1;
      ared=0;
      bred=0;
      while (a[jj]!=0)
      {//Going through all monomials of a
        ared= ared+leadcoef(tempResultCoeffs[k][1][jj])*leadmonom(a[jj]);
        jj++;
      }//Going through all monomials of a
      jj=1;
      while (b[jj]!=0)
      {//Going through all monomials of b
        bred= bred+leadcoef(tempResultCoeffs[k][2][jj])*leadmonom(b[jj]);
        jj++;
      }//Going through all monomials of b
      tempResult = insert(tempResult,list(ared,bred));
    }//Creating the resulting polynomials with the respective coeffs.
    setring(r);
    if (!defined(tempResult))
    {def tempResult = imap(S,tempResult);}
    for (k=1; k<= size(tempResult);k++)
    {
      result = insert(result,tempResult[k]);
    }
    kill tempResult;
    clearSlateRingList[2] = list();
    clearSlateRingList[3] = list();
    tempSringlist = ringlist(r);
  }//Iterating over all two-combinations in the set M
  if(size(result)==0)
  {
    return (list(list(h)));
  }
  return(delete_duplicates_noteval_and_sort(result));
}//proc ncfactor_letterplace_poly_s


static proc test_ncfactor_letterplace_poly_s()
"Tests the basic functionality."
{//proc test_ncfactor_letterplace_poly_s()
  int result = 1;
  ring r = 0,(x,y,z),dp;
  int d =4; // degree bound
  def R = makeLetterplaceRing(d);
  setring R;
  //TEST 1: power of 2
  poly f1 = (x + y)*(x + y);
  list obtained = ncfactor_letterplace_poly_s(f1);
  list expected = sortFactorizations(
    list(
      list(x + y, x + y)
      ));
  if (!isListEqual(expected,obtained))
  {
    print("Test 1 for ncfactor_letterplace_poly_s failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //TEST 2: Monomial
  f1 = x*z;
  obtained = ncfactor_letterplace_poly_s(f1);
  expected = sortFactorizations(
    list(
      list(x, z)
      ));
  if (!isListEqual(expected,obtained))
  {
    print("Test 2 for ncfactor_letterplace_poly_s failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //TEST 3: Generic product with all variables
  f1 = (x*y + z*x)*(x+ z+ y);
  obtained = ncfactor_letterplace_poly_s(f1);
  expected = sortFactorizations(
    list(
      list(
      x*y + z*x,
      x+ z+ y))
      );
  if (!isListEqual(expected,obtained))
  {
    print("Test 3 for ncfactor_letterplace_poly_s failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //TEST 4: More than one factorization
  f1 = x*y*x + x;
  obtained = ncfactor_letterplace_poly_s(f1);
  expected = sortFactorizations(
    list(
      list(x, y*x + 1),
      list(x*y + 1, x))
      );
  if (!isListEqual(expected,obtained))
  {
    print("Test 4 for ncfactor_letterplace_poly_s failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return (result);
}//proc test_ncfactor_letterplace_poly_s()

static proc ncfactor_without_opt_letterplace(poly h)
"USAGE: ncfactor_without_opt_letterplace(h); h is a polynomial in a
        letterplace ring over a field k.
RETURN: list(list)
PURPOSE: Compute all factorizations of h, without making any
         sanity-checks
THEORY: Implements an ansatz-driven factorization method as outlined
by Bell, Heinle and Levandovskyy in \"On Noncommutative Finite
Factorization Domains\".
ASSUME:
- the basering is a Letterplace ring.
- k is a ring, such that factorize can factor any univariate and
  multivariate commutative polynomial over k.
- There exists at least one variable in the ring.
- h is not a constant or 0.
NOTE:
- Every entry of the output list is a list with factors for one possible factorization.
  The first factor is always a constant (1, if no nontrivial constant
  could be excluded).
SEE ALSO: facWeyl, facSubWeyl, testNCfac, ncfactor
"{//ncfactor_without_opt_letterplace
  int p = printlevel-voice+2;
  int i; int j; int k; int l;
  string dbprintWhitespace = "";
  for (i = 1; i<=voice;i++)
  {dbprintWhitespace = dbprintWhitespace + " ";}
  number commonCoefficient = content(h);
  poly hath = h/commonCoefficient;
  dbprint(p,dbprintWhitespace + "Calculating all possibilities of h as
 a combination of two factors.");
  list result = ncfactor_letterplace_poly_s(hath);
  result = delete_duplicates_noteval_and_sort(result);
  dbprint(p,dbprintWhitespace + "Done. The result is:");
  dbprint(p,result);
  dbprint(p,dbprintWhitespace+"Recursively check factors for
 irreducibility");
  list recursivetemp;
  int changedSomething;
  for(i = 1; i<=size(result);i++)
  {//recursively factorize factors
    if(size(result[i])>1)
    {//Nontrivial factorization
      for (j=1;j<=size(result[i]);j++)
      {//Factorize every factor
        recursivetemp = ncfactor_letterplace_poly_s(result[i][j]);
        recursivetemp = delete_duplicates_noteval(recursivetemp);
        changedSomething = 0;
        for(k=1; k<=size(recursivetemp);k++)
        {//insert factorized factors
          if(size(recursivetemp[k])>1)
          {//nontrivial
            changedSomething = 1;
            result = insert(result,result[i],i);
            for(l = size(recursivetemp[k]);l>=1;l--)
            {
              result[i+1] = insert(result[i+1],recursivetemp[k][l],j);
            }
            result[i+1] = delete(result[i+1],j);
          }//nontrivial
        }//insert factorized factors
        if (changedSomething)
        {break;}
      }//Factorize every factor
      if(changedSomething)
      {
        result = delete(result,i);
        continue;
      }
    }//Nontrivial factorization
  }//recursively factorize factors
  dbprint(p,dbprintWhitespace +" Done");
  dbprint(p,dbprintWhitespace + "Removing duplicates from the list");
  result = delete_duplicates_noteval_and_sort(result);
  for (i = 1; i<=size(result);i++)
  {//Putting the content everywhere
    result[i] = insert(result[i],commonCoefficient);
  }//Putting the content everywhere
  result = normalizeFactors(result);
  result = delete_duplicates_noteval_and_sort(result);
  dbprint(p,dbprintWhitespace +" Done");
  return(result);
}//ncfactor_without_opt_letterplace

static proc test_ncfactor_without_opt_letterplace()
"Tests the basic functionality."
{//test_ncfactor_without_opt_letterplace
  int result = 1;
  ring r = 0,(x,y,z),dp;
  int d =4; // degree bound
  def R = makeLetterplaceRing(d);
  setring R;
  //TEST 1: power of 2
  poly f1 = 4*(x + y)*(x + y);
  list obtained = ncfactor_without_opt_letterplace(f1);
  list expected = sortFactorizations(
    list(
      list(number(4), x + y, x + y)
      ));
  if (!isListEqual(expected,obtained))
  {
    print("Test 1 for ncfactor_without_opt_letterplace failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //TEST 2: Monomial
  f1 = 11*x*z;
  obtained = ncfactor_without_opt_letterplace(f1);
  expected = sortFactorizations(
    list(
      list(number(11), x, z)
      ));
  if (!isListEqual(expected,obtained))
  {
    print("Test 2 for ncfactor_without_opt_letterplace failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //TEST 3: Generic product with all variables
  f1 = (2*x*y + 4*z*x)*(x+z+y);
  obtained = ncfactor_without_opt_letterplace(f1);
  expected = sortFactorizations(
    list(
      list(number(2), x*y + 2*z*x, x+z+y)
      ));
  if (!isListEqual(expected,obtained))
  {
    print("Test 3 for ncfactor_without_opt_letterplace failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //TEST 4: More than one factorization
  f1 = 6*x*y*x + 9*x;
  obtained = ncfactor_without_opt_letterplace(f1);
  expected = sortFactorizations(
    list(
      list(number(3), x, 2*y*x + 3),
      list(number(3), 2*x*y + 3, x)
      ));
  if (!isListEqual(expected,obtained))
  {
    print("Test 4 for ncfactor_without_opt_letterplace failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  //Test 5: At least one recursive call
  f1 = f1*(x + y);
  obtained = ncfactor_without_opt_letterplace(f1);
  expected = sortFactorizations(
    list(
      list(number(3), x, 2*y*x + 3, x + y),
      list(number(3), 2*x*y + 3, x, x + y)
      ));
  if (!isListEqual(expected,obtained))
  {
    print("Test 5 for ncfactor_without_opt_letterplace failed.");
    print("Expected:\n");
    print(expected);
    print("obtained:\n");
    print(obtained);
    result = 0;
  }
  return (result);
}//test_ncfactor_without_opt_letterplace


//==================================================
// EASY EXAMPLES FOR WEYL ALGEBRA
//==================================================
/*
  Easy and fast example polynomials where one can find factorizations: K<x,d |dx=xd+1>
  (x^2+d)*(x^2+d);
  (x^2+x)*(x^2+d);
  (x^3+x+1)*(x^4+d*x+2);
  (x^2*d+d)*(d+x*d);
  d^3+x*d^3+2*d^2+2*(x+1)*d^2+d+(x+2)*d; //Example 5 Grigoriev-Schwarz.
  (d+1)*(d+1)*(d+x*d); //Landau Example projected to the first dimension.
*/

//==================================================
//Some Bugs(fixed)/hard examples from Martin Lee:
//==================================================
// ex1, ex2
/*
ring s = 0,(x,d),Ws(-1,1);
def S = nc_algebra(1,1); setring S;
poly a = 10x5d4+26x4d5+47x5d2-97x4d3; //Not so hard any more... Done in around 4 minutes
def l= facFirstWeyl (a); l;
kill l;
poly b = -5328x8d5-5328x7d6+720x9d2+720x8d3-16976x7d4-38880x6d5
-5184x7d3-5184x6d4-3774x5d5+2080x8d+5760x7d2-6144x6d3-59616x5d4
+3108x3d6-4098x6d2-25704x5d3-21186x4d4+8640x6d-17916x4d3+22680x2d5
+2040x5d-4848x4d2-9792x3d3+3024x2d4-10704x3d2-3519x2d3+34776xd4
+12096xd3+2898d4-5040x2d+8064d3+6048d2; //Still very hard... But it seems to be only because of the
//combinatorial explosion
def l= facFirstWeyl (b); l;

// ex3: there was difference in answers => fixed
LIB "ncfactor.lib";
ring r = 0,(x,y,z),dp;
matrix D[3][3]; D[1,3]=-1;
def R = nc_algebra(1,D);
setring R;
poly g= 7*z4*x+62*z3+26*z;
def l1= facSubWeyl (g, x, z);
l1;
//---- other ring
ring s = 0,(x,z),dp;
def S = nc_algebra(1,-1); setring S;
poly g= 7*z4*x+62*z3+26*z;
def l2= facFirstWeyl (g);
l2;
map F = R,x,0,z;
list l1 = F(l1);
l1;
//---- so the answers look different, check them!
testNCfac(l2); // ok
testNCfac(l1); // was not ok, but now it's been fixed!!!

// selbst D und X so vertauschen dass sie erfuellt ist : ist gemacht

*/

/*
// bug from M Lee
LIB "ncfactor.lib";
ring s = 0,(z,x),dp;
def S = nc_algebra(1,1); setring S;
poly f= -60z4x2-54z4-56zx3-59z2x-64;
def l= facFirstWeyl (f);
l; // before: empty list; after fix: 1 entry, f is irreducible
poly g = 75z3x2+92z3+24;
def l= facFirstWeyl (g);
l; //before: empty list, now: correct
*/

/* more things from Martin Lee; fixed
ring R = 0,(x,s),dp;
def r = nc_algebra(1,s);
setring(r);
poly h = (s2*x+x)*s;
h= h* (x+s);
def l= facFirstShift(h);
l; // contained doubled entries: not anymore, fixed!

ring R = 0,(x,s),dp;
def r = nc_algebra(1,-1);
setring(r);
poly h = (s2*x+x)*s;
h= h* (x+s);
def l= facFirstWeyl(h);
l; // contained doubled entries: not anymore, fixed!

*/

//======================================================================
//Examples from TestSuite that are terminating in a reasonable time.
//======================================================================

//Counter example for old Algorithm, but now working:
/*
ring R = 0,(x,d),dp;
def r = nc_algebra(1,1);
setring(r);
LIB "ncfactor.lib";
poly h = (1+x^2*d)^4;
list lsng = facFirstWeyl(h);
print(lsng);
*/

//Example 2.7. from Master thesis
/*
ring R = 0,(x,d),dp;
def r = nc_algebra(1,1);
setring(r);
LIB "ncfactor.lib";
poly h = (xdd + xd+1+ (xd+5)*x)*(((x*d)^2+1)*d + xd+3+ (xd+7)*x);
list lsng = facFirstWeyl(h);
print(lsng);
 */

//Example with high combinatorial income
/*
ring R = 0,(x,d),dp;
def r = nc_algebra(1,1);
setring(r);
LIB "ncfactor.lib";
poly h = (xdddd + (xd+1)*d*d+ (xd+5)*x*d*d)*(((x*d)^2+1)*d*x*x + (xd+3)*x*x+ (xd+7)*x*x*x);
list lsng = facFirstWeyl(h);
print(lsng);
 */

//Once a bug, now working
/*
ring R = 0,(x,d),dp;
def r = nc_algebra(1,1);
setring(r);
LIB "ncfactor.lib";
poly h = (x^2*d^2+x)*(x+1);
list lsng = facFirstWeyl(h);
print(lsng);
*/

//Another one of that kind
/*
ring R = 0,(x,d),dp;
def r = nc_algebra(1,1);
setring(r);
LIB "ncfactor.lib";
poly h = (x*d*d + (x*d)^5 +x)*((x*d+1)*d-(x*d-1)^5+x);
list lsng = facFirstWeyl(h);
print(lsng);
 */

//Example of Victor for Shift Algebra
/*
ring s = 0,(n,Sn),dp;
def S = nc_algebra(1,Sn); setring S;
LIB "ncfactor.lib";
list lsng = facFirstShift(n^2*Sn^2+3*n*Sn^2-n^2+2*Sn^2-3*n-2);
print(lsng);
 */

//Interesting example, as there are actually also some complex solutions to it:
/*
ring R = 0,(x,d),dp;
def r = nc_algebra(1,1);
setring(r);
LIB "ncfactor.lib";
poly h =(x^3+x+1)*(x^4+d*x+2);//Example for finitely many, but more than one solution in between.
list lsng = facFirstWeyl(h);
print(lsng);
 */

//Another one of that kind:
/*
ring R = 0,(x,d),dp;
def r = nc_algebra(1,1);
setring(r);
LIB "ncfactor.lib";
poly h =(x^2+d)*(x^2+d);//Example for finitely many, but more than one solution in between.
list lsng = facFirstWeyl(h);
print(lsng);
*/

//Example by W. Koepf:
/*
ring R = 0,(x,d),dp;
def r = nc_algebra(1,1);
setring(r);
LIB "ncfactor.lib";
poly h = (x^4-1)*x*d^2+(1+7*x^4)*d+8*x^3;
list lsng = facFirstWeyl(h);
print(lsng);
 */

//Shift Example from W. Koepf
/*
ring R = 0,(n,s),dp;
def r = nc_algebra(1,s);
setring(r);
LIB "ncfactor.lib";
poly h = n*(n+1)*s^2-2*n*(n+100)*s+(n+99)*(n+100);
list lsng = facFirstShift(h);
print(lsng);
 */

//Tsai Example... Once hard, now easy...
/*
ring R = 0,(x,d),dp;
def r = nc_algebra(1,1);
setring(r);
LIB "ncfactor.lib";
poly h = (x^6+2*x^4-3*x^2)*d^2-(4*x^5-4*x^4-12*x^2-12*x)*d + (6*x^4-12*x^3-6*x^2-24*x-12);
list lsng =facFirstWeyl(h);
print(lsng);
 */

 /* recent bufgixes Jan 2018; exs from Viktor and Johannes Hoffmann
// In A_1 (dx=xd+1):
// for alle i the Faktorization should contain
// (x*d+i+1) * (x*d^2-x*d+(i+2)*d-i)
// for i big enough the right hand side is irred
LIB "nctools.lib";
ring r = 0,(x,d),dp;
def R = Weyl(); setring R;
int i = 3;
ncfactor((d-1)*(x*d+i)*(x*d+i+1));
int i = 11;
ncfactor((d-1)*(x*d+i)*(x*d+i+1));
int i = 101;
ncfactor((d-1)*(x*d+i)*(x*d+i+1));
int i = -11;
ncfactor((d-1)*(x*d+i)*(x*d+i+1));
int i = -3;
ncfactor((d-1)*(x*d+i)*(x*d+i+1));
 */

 /* recent bufgixes (2) Jan 2018; exs from Viktor and Johannes Hoffmann
 // Original bug: found only (x+d)^2*x as factorization
LIB "nctools.lib";
ring r = 0,(x,d),dp;
def R = Weyl(); setring R;
ncfactor((x^2+x*d+2)*(x+d)); // now it's fine: 2 fctrzs
*/

//======================================================================
// Hard examples not yet computable in feasible amount of time
//======================================================================

//Also a counterexample for REDUCE. Very long Groebner basis computation in between.
/*
ring R = 0,(x,d),dp;
def r = nc_algebra(1,1);
setring(r);
LIB "ncfactor.lib";
poly h = (d^4+x^2+dx+x)*(d^2+x^4+xd+d);
list lsng = facFirstWeyl(h);
print(lsng);
*/

//Example from the Mainz-Group
/*
ring R = 0,(x,d),dp;
def r = nc_algebra(1,1);
setring(r);
poly dop6 = 1/35*x^4*(27-70*x+35*x^2)+ 1/35*x*(32+152*x+100*x^2-59*x^3+210*x^4+105*x^5)*d+
(-10368/35-67056/35*x-35512/7*x^2-50328/7*x^3-40240/7*x^4-2400*x^5-400*x^6)*d^2+
(-144/35*(x+1)*(1225*x^5+11025*x^4+37485*x^3+61335*x^2+50138*x+16584)-6912/35*(x+2)*
(x+1)*(105*x^4+1155*x^3+4456*x^2+7150*x+4212) -27648/35*(x+3)*(x+1)*(35*x^2+350*x+867)*
(x+2)^2)*d^3;
LIB "ncfactor.lib";
printlevel = 5;
facFirstWeyl(dop6);
$;*/

//Another Mainz Example:
/*
LIB "ncfactor.lib";
ring R = 0,(x,d),dp;
def r = nc_algebra(1,1);
setring(r);
poly dopp = 82547*x^4*d^4+60237*x^3*d^3+26772*x^5*d^5+2231*x^6*d^6+x*(1140138*
x^2*d^2-55872*x*d-3959658*x^3*d^3-8381805*x^4*d^4-3089576*x^5*d^5-274786*
x^6*d^6)+x^2*(-16658622*x*d-83427714*x^2*d^2-19715033*x^3*d^3+78915395*x^4
*d^4+35337930*x^5*d^5+3354194*x^6*d^6)+x^3*(-99752472-1164881352*x*d+
4408536996*x^2*d^2+11774185985*x^3*d^3+5262196786*x^4*d^4+1046030561/2*x^5*
d^5-10564451/2*x^6*d^6)+x^4*(-1925782272+21995375398*x*d+123415803356*x^2*
d^2+302465300831/2*x^3*d^3+34140803907/2*x^4*d^4-15535653409*x^5*d^5-\
2277687768*x^6*d^6)+x^5*(71273525520+691398212366*x*d+901772633569*x^2*d^2+
2281275427069*x^3*d^3+2944352819911/2*x^4*d^4+836872370039/4*x^5*d^5+
9066399237/4*x^6*d^6)+x^6*(2365174430376+9596715855542*x*d+29459572469704*x^
2*d^2+92502197003786*x^3*d^3+65712473180525*x^4*d^4+13829360193674*x^5*d^5
+3231449477251/4*x^6*d^6)+x^7*(26771079436836+117709870166226*x*d+
821686455179082*x^2*d^2+1803972139232179*x^3*d^3+1083654460691481*x^4*d^4+
858903621851785/4*x^5*d^5+50096565802957/4*x^6*d^6)+x^8*(179341727601960+
2144653944040630*x*d+13123246960284302*x^2*d^2+41138357917778169/2*x^3*d^3+
20605819587976401/2*x^4*d^4+3677396642905423/2*x^5*d^5+402688260229369/4*x^6
*d^6)+x^9*(2579190935961288+43587063726809764*x*d+157045086382352387*x^2*d^
2+172175668477370223*x^3*d^3+138636285385875407/2*x^4*d^4+10707836398626232*
x^5*d^5+529435530567584*x^6*d^6)+x^10*(41501953525903392+558336731465626084*
x*d+1407267553543222268*x^2*d^2+1153046693323226808*x^3*d^3+
372331468563656085*x^4*d^4+48654019090240214*x^5*d^5+2114661191282167*x^6*d
^6)+x^11*(364526077273381884+4158060401095928464*x*d+8646807662899324262*x^2*
d^2+5914675753405705400*x^3*d^3+1631934058875116005*x^4*d^4+
187371894330537204*x^5*d^5+7366806367019734*x^6*d^6)+x^12*(
1759850321214603648+18265471270535733520*x*d+34201910114871110912*x^2*d^2+
21265221434709398152*x^3*d^3+5437363546219595036*x^4*d^4+594029113431041060*
x^5*d^5+22881659624561644*x^6*d^6)+x^13*(4648382639403200688+
45699084277107816096*x*d+81049061578449009384*x^2*d^2+48858488665016574368*x
^3*d^3+12515362110098721444*x^4*d^4+1412152747420021048*x^5*d^5+
57196947123984972*x^6*d^6)+x^14*(5459369397960020544+55837825300341621824*x*
d+105671876924055409696*x^2*d^2+71551727420848766624*x^3*d^3+
21094786205096577808*x^4*d^4+2695663190297032192*x^5*d^5+118791751565613264*
x^6*d^6)+x^15*(1023333653580043776+47171127937488813824*x*d+
157258351906685700352*x^2*d^2+145765192195300531840*x^3*d^3+
49876215785510342176*x^4*d^4+6647374188802036864*x^5*d^5+287310278455067312*
x^6*d^6)+x^16*(11960091747366236160+250326608568269289472*x*d+
677587171115580981248*x^2*d^2+538246374825683603456*x^3*d^3+
161380433451548754048*x^4*d^4+19149099315354950144*x^5*d^5+
746433247985092544*x^6*d^6)+x^17*(42246252365448668160+657220532737851248640*
x*d+1531751689216283911680*x^2*d^2+1090829514212206064640*x^3*d^3+
299280728709430851840*x^4*d^4+32932767387222323200*x^5*d^5+
1202281367574179840*x^6*d^6)+x^18*(6239106101942784000+320638742839606579200*
x*d+873857213570556364800*x^2*d^2+645649080101933721600*x^3*d^3+
177008238160627276800*x^4*d^4+19165088507111475200*x^5*d^5+
683600826675660800*x^6*d^6)+x^19*(-60440251454613504000-476055211197689856000
*x*d-733497382597635072000*x^2*d^2-386038662982742016000*x^3*d^3-\
83361486778142976000*x^4*d^4-7524999543181824000*x^5*d^5-232189492987008000*
x^6*d^6)+x^20*(1578562930483200000+12628503443865600000*x*d+
19732036631040000000*x^2*d^2+10523752869888000000*x^3*d^3+
2302070940288000000*x^4*d^4+210475057397760000*x^5*d^5+6577345543680000*x^6*
d^6);
printlevel = 3;
facFirstWeyl(dopp);
*/



//Hard Example by Viktor:
/*
  ring r = 0,(x,d), (dp);
def R = nc_algebra(1,1);
setring R;
LIB "ncfactor.lib";
poly t = x; poly D =d;
poly p = 2*t^2*D^8-6*t*D^8+2*t^2*D^7+8*t*D^7+12*D^7-2*t^4*D^6+6*t^3*D^6+12*t*D^6-20*D^6
-2*t^4*D^5-8*t^3*D^5-4*t^2*D^5+12*t*D^5-28*D^5-12*t^3*D^4-4*t^2*D^4-4*t*D^4-24*D^4+4*t^4*D^3
-12*t^3*D^3+2*t^2*D^3-18*t*D^3+16*D^3+6*t^4*D^2-2*t^3*D^2+2*t^2*D^2-2*t*D^2+44*D^2+2*t^4*D
+12*t^3*D+2*t*D+4*t^3-8;
list lsng = facFirstWeyl(p);
print(lsng);
*/

/*later hard example From Beals-Kartashova paper
  ring R = 0, (x1,x2,d1,d2),dp;def r = Weyl();setring(r);
  poly h = d1^2 -d2^2 + x1*d2 + x2*d1 + 1/4*(x2^2 - x1^2) +1;
 */
