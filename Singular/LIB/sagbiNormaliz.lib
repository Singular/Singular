//// Singular library sagbiNormaliz.lib
version="version sagbiNormaliz.lib 4.3.2.0 June 2023 "; // $Id$
category="Commutative Algebra";
info="
LIBRARY: sagbiNormaliz.lib  Provides an interface for the computation of Sagbi bases.
It uses normaliz.lib (version 4... or higher) for combinatorial computations.

AUTHORS: Winfried Bruns, wbruns@uos.de

OVERVIEW:

The library sagbiNormaliz.lib provides functions for the computations of Sagbi bases. It
is based on normaliz.lib. Its functions compute Sagbi bases with or without the control by
Hilbert functions and/orv degrees. Hilbert functions and degrees require that bthe ambient
polynomial ring is standard gtraded. (An extension to general positive gradinmgs would
not be difficult.)

Use of this library requires the program Normaliz to be installed and the
availability of normaliz.lib. You can download both from
@uref{https://github.com/Normaliz/Normaliz/releases}.
Please make sure that the executable is in the search path or use setNmzExecPath (defined
in normaliz.lib).

The computations of this library require reading Normaliz output files and therefore a file name
must be set. The standard file name chosen by the library is NmzSagbiExchange in the current
directory. The user can overwrite it by setting another name.

KEYWORDS: Sagbi basis, initial algebra

PROCEDURES:
sagbiGeneral(ideal Q [, int sagbiMaxRounds, int sorting, int verb]) computes the Sagbi basis of the subalgebra of
                              the current polynomial ring that is generated by the elements of Q. The computation is stopped after at most sagbiMaxRounds rounds if trhe parameter is set. If sorting is set, the  compouted elements are degrevlex sorted before a round of the algorithm.
                              The optional parameter verb sets the terminal output. Fefault is 1 = on..

sagbiByDegree(ideal Q, int Sagbi_degree_bound,[,int sorting, int verb]) computes the Sagbi basis degree by degree until thwe degree bound is reached or the Sagbi basis has been computed completely.

sagbiHilbControlled(ideal Q, intvec HS_num_algebra, intvec HS_denom_algebra, int Sagbi_degree_bound[, int finalCheck, int sorting, int verb]) computes the Sagbi basis up to the degree bound. The Hilbert series of the subalgebra
                              generated by the elements of Q is given by its numerator and denominator as a rational
                              function. HS_denom_algebra lists the exponents g_i in the factors 1 -t^g_i of the denominator.
                              If the degree bound is reached and the optional argument inalCheck is set, the Hilbert series
                              is checked again for completion.
";

// ------------------------------------------------
// Helpers related to grading
//  -----------------------------------------------


static proc gradingDenominator(ideal P){
    int GradingDenom = deg(P[1]);
    for(int i = 2; i <= size(P); i++){
        GradingDenom = gcd(GradingDenom, deg(P[i]));
    }
    return(GradingDenom);
}

static proc gradVector(ideal Q, int GradingDenom){
    intvec SGrad;
    SGrad = deg(Q[1]) div GradingDenom;
    for(int i = 2; i <= size(Q); i++){
        SGrad = SGrad, deg(Q[i]) div GradingDenom;
    }
    return(SGrad);
}

static proc scalarProduct(intvec u, intvec v){
    int p = 0;
    for(int i = 1; i <= size(u); i++){
        p = p + u[i]*v[i];
    }
    return(p);
}

static proc posScalarProductMat(intmat U, int row, intvec v){
    int p = 0;
    for(int i = 1; i <= ncols(U); i++){
        if(U[row,i] > 0){
            p = p + U[row,i]*v[i];
        }
    }
    return(p);
}

static proc selectNextDegree(intmat saveTete_a_tete, int startTete_tete, intvec SGrad){

    for(int k = 1; k <= nrows(saveTete_a_tete); k++){
        // posScalarProductMat(saveTete_a_tete, k, SGrad);
    }

    int endTete_atete = nrows(saveTete_a_tete);
    if(startTete_tete > nrows(saveTete_a_tete))
{
        intmat empty[0][ncols(saveTete_a_tete)];
        return (empty, startTete_tete);
    }

    int startDeg = posScalarProductMat(saveTete_a_tete, startTete_tete, SGrad);
    int i,j;

    for(i = startTete_tete; i <= nrows(saveTete_a_tete); i++){
        if(posScalarProductMat(saveTete_a_tete, i, SGrad) > startDeg)
{
            endTete_atete = i -1;
            break;
        }
    }
    intmat selection[endTete_atete - startTete_tete +1][ncols(saveTete_a_tete)];
    for(i = startTete_tete; i <= endTete_atete; i++){
            for(j = 1; j <= ncols(saveTete_a_tete); j++){
                selection[i - startTete_tete +1, j] = saveTete_a_tete[i, j];
            }
    }
    return(selection, endTete_atete + 1);
}

static proc selectionByDegree(ideal P, intvec grading, int our_deg){
    ideal Q;
    for(int i = 1; i <= size(P); i++){
        if(scalarProduct(leadexp(P[i]), grading) == our_deg){
            Q = Q + P[i];
        }
    }
    return(Q);
}

// ------------------------------------------------
// Helpers for Hilbert series
//  -----------------------------------------------


static proc polyProd(intvec F, bigintmat G, int max_degree){
// F and G represent polynomials in one variable
// We compute their product up to maxdegree
    int deg_F = size(F) - 1;
    int deg_G = ncols(G) - 1;
    int deg_prod = deg_F + deg_G;
    int eff_deg = max_degree;
    if(eff_deg > deg_prod || eff_deg == -1){
        eff_deg = deg_prod;
    }
    bigintmat Prod[1][eff_deg +1];
    int d, j;
    bigint S;
    for(d = 0; d <= eff_deg; d++){
        S = 0;
        for(j = 0; j <= d; j++){
            if(j  <= deg_F && d - j <= deg_G){
                    S = S + F[j + 1]*G[1, d - j +1];
            }
        }
        Prod[1,d + 1] = S;
    }
    return(Prod);
}

static proc cycloRatFunctionExpansion(intvec num_vec, intvec den_vec, int exp_degree){
// Computes the expansion of a rational function with numerator represented by num_vec
// and denominator a product of terms 1 - t^g_i where zjhe g_i are the entries of den_vec
    bigintmat E[1][exp_degree + 1];
    int to_copy = size(num_vec);
    if(to_copy > exp_degree + 1){
        to_copy = exp_degree + 1;
    }
    int i, j, k;
    for(i = 1; i <= to_copy; i++){
        E[1, i] = num_vec[i];
    }
    intvec fac;
    for(i = 1; i <= exp_degree; i++){
        fac = fac, 0;
    }
    for( k = 1; k<= size(den_vec); k++){
        for(i = 1; i <= size(fac); i++){
            fac[i] = 0;
        }
        for(i = 0; i * den_vec[k] <= exp_degree; i++){
            fac[1 + i * den_vec[k] ] = 1;
        }
        E = polyProd(fac, E, exp_degree);
    }
    return(E);
}

static proc intvec2poly(intvec vec){
    poly f = 0;
    poly t = var(1);
    for(int i = 1; i <= size(vec); i++){
        f = f + vec[i]*t^(i-1);
    }
    return(f);
}

static proc expandDenom(intvec den){
    poly g = 1;
    poly t = var(1);
    for(int i = 1; i <= size(den); i++){
        g = g*(1-t^den[i]);
    }
   return(g);
}

static proc unifiedRepresentations(intvec num_vec_1, intvec den_vec_1, intvec num_vec_2, intvec den_vec_2){

    ring T = 0,t,dp;
    poly num_1, den_1, num_2, den_2;
    num_1 = intvec2poly(num_vec_1);
    num_2 = intvec2poly(num_vec_2);
    den_1 = expandDenom(den_vec_1);
    den_2 = expandDenom(den_vec_2);
    if(num_1*den_2 == num_2*den_1){
        return(1);
    }
    return(0);
}

static proc compareCCycloRatFunctions(intvec num_vec_1, intvec den_vec_1, num_vec_2, den_vec_2){
// Compares the expansions of rational functions as in cycloRatFunctionExpansion
// It must be made sure that the rational functions agree if and only they agree in
// numerator and denominator

    if(num_vec_1 == num_vec_2 && den_vec_1 == den_vec_2){
        return(-1,0);
    }
    if(unifiedRepresentations(num_vec_1, den_vec_1, num_vec_2, den_vec_2) ){
         return(-1,0);
    }

    int expansion_deg = size(num_vec_1);
    bigintmat expansion_1, expansion_2;
    int u;
    while(1)
{
        expansion_1 = cycloRatFunctionExpansion(num_vec_1, den_vec_1, expansion_deg);
        expansion_2 = cycloRatFunctionExpansion(num_vec_2, den_vec_2, expansion_deg);
        if(expansion_1 == expansion_2){
            expansion_deg = 2*expansion_deg;
            continue;
        }
        for(u = 1; u <= expansion_deg+1; u++){
            if(expansion_1[1, u] != expansion_2[1, u]){
                return(u -1, expansion_1[1, u] - expansion_2[1, u])
            }
        }
    }
}

// ------------------------------------------------
// Computation of Hilbert series
//  -----------------------------------------------

// The return value is_normal registers whether monoid is normal
// in the nonnormal case the Markov basis is kept
// for use in tete-a-tete
static proc HilbertSeriesMonoid(intmat U, int min_degree){
// min_degree for output of Markovbasis
    intmat V;
    int swallow = setNmzOption("intclosed",1);
    V = normaliz(U, "monoid");
    exportNuminvs();
    // showNuminvs();
    swallow = setNmzOption("intclosed",0);
    int is_normal = nmz_integrally_closed;
    if(!is_normal){
        dbprint(our_printlevel,"Not normal");
        swallow = setNmzOption("MRK",1);
    }
    swallow = setNmzOption("only_hvect",1);
    V = normaliz(U, "monoid", min_degree, "gb_min_degree");
    swallow = setNmzOption("only_hvect",0);
    swallow = setNmzOption("MRK",0);
    exportNuminvs();
    return(nmz_hilbert_series_num, nmz_hilbert_series_denom, is_normal);
}

static proc HilbertSeriesMonAlgebra(ideal P, int min_degree)
{
    intmat U = mons2intmat(P);
    return (HilbertSeriesMonoid(U, min_degree));
}

// ------------------------------------------------
// Computation of Hilbert bases
//  -----------------------------------------------

static proc HilbertBasisMonoid(intmat U){
    intmat V;
    int swallow = setNmzOption("hilbbas",1);
    V = normaliz(U, "monoid");
    swallow = setNmzOption("hilbbas",0);
    return(V);
}

static proc HilbertBasisMonAlgebra(ideal P){
    intmat U = mons2intmat(P);
    return (intmat2mons(HilbertBasisMonoid(U)));
}

// ------------------------------------------------
// Subduction
//  -----------------------------------------------

static proc Subduction(ideal Pgiven, bigint nr_generators_needed){
// nr_generators = -1: complete subduction
// szbduction in the sense of Robbiano-Sweedler.
// It is applied once to every polynomial whose
// initial is not in the minimal system of generators of the algebra
// generated by the initial monomials
    ideal P = Pgiven;
    intvec test_num, test_den;
    int i,j;
    int swallow = setNmzOption("REP",1);
    intmat U = mons2intmat(P);
    intmat V = normaliz(U, "monoid"); // V only to swallow return value
    V = readNmzData("rep");
    swallow = setNmzOption("REP",0);
    exportNuminvs();

    bigint nr_generators = bigint(size(P) - nrows(V));
    string output = "polynomials " + string(size(P)) +  " minimal so far " + string( nr_generators);
    dbprint(our_printlevel,output);

    if(nr_generators_needed != -1 &&  nr_generators_needed == nr_generators){
        return(P, 0, nmz_hilbert_basis_key); // important here: no change in P anymore
    }                                        // can use  nmz_hilbert_basis_key
    if(nr_generators_needed == -1 &&  size(P) == nmz_hilbert_basis_elements){
        return(P, 0, nmz_hilbert_basis_key);
    }
   if(nr_generators_needed != -1 &&  size(P) == nmz_hilbert_basis_elements){
        ERROR("Error in Subduction. Inform thge authors");
    }
    // relative to Pgiven
    def our_ring = basering;
    int p = size(P);
    list baseringlist = ringlist(basering);
    ring S = (baseringlist[1]),(y(1.. p)),dp;
    ideal Bl = intmat2binomials(V);
    setring our_ring;
    map f = S, P;
    ideal P_modify = f(Bl);
    for(i = 1; i <= nrows(V); i++){
        for(j= 1; j <= ncols(V); j++){
                if(V[i,j] == 1){
                        break;
                }
        }
        P[j] = P_modify[i];
    }
    P = simplify(P,3);
    return(P,1, nmz_hilbert_basis_key);
}

static proc HilbbasSubduction(ideal P, int old_nr_hilbbas, bigint HF_difference){
// Applies subduction as many times as necessary to frill HF_difference
    ideal Q = simplify(P, 3);
    int change;
    intvec HilbertBasisKey;

    bigint nr_generators_needed = bigint(old_nr_hilbbas) + HF_difference;
    string output = "Have " + string( old_nr_hilbbas) +  " need " + string(nr_generators_needed);
    dbprint(our_printlevel,output);

    while(1){
        (Q, change, HilbertBasisKey) = Subduction(Q, nr_generators_needed);
        if(change == 0){
            list L = sort(HilbertBasisKey);
            HilbertBasisKey = L[1];
            return(Q, HilbertBasisKey); // HilbertBasisKey only used in this case
        }
    }
}

static proc completeSubduction(ideal Q){
// applies subduction repeatedly until statbility is reached.
    int change;
    intvec HilbertBasisKey; // for syntactical reasons

    string output = "complete subduction applied to size "+ string(size(Q));
    dbprint(our_printlevel,output);
    while(1){
        (Q, change,HilbertBasisKey) = Subduction(Q, -1);
        if(change == 0){
            output = "subduced size " + string(size(Q));
            dbprint(our_printlevel,output);
            return(Q);
        }
    }
}

// ------------------------------------------------
// Tete-a-tete
//  -----------------------------------------------

static proc Tete_A_TeteHilbControlled(ideal P, int crit_degree, int is_normal)
// Computes the terte-a-ztete of a system of polynomials (terminology of
// Robbiano-Sweedler). Control by Hilbert series: only the crit degree is
// evaluated and normality is exploited. General version below.
{
    dbprint(our_printlevel,"Start Tete-a-tete ");
    string output;

    // system("--ticks-per-sec",1000);
    // timer=0;
    // int t = timer;

    int i;
    ideal Q = P;
    Q = simplify(Q,3);

    // First we reconstruct the grading of the binomials
    // Only needed in the nonnormal case
    int GradingDenom = gradingDenominator(Q);
    intvec SGrad = gradVector(Q, GradingDenom);
    intmat U = mons2intmat(Q);

    def our_ring = basering;
    int p = size(Q);
    list baseringlist = ringlist(basering);
    ring S = (baseringlist[1]),(y(1..p)), dp;
    // U;
    intmat V;
    ideal B, Bfull;
    if(is_normal){ // in the normal case we don't have the Markov basis yet
        int swallow = setNmzOption("MRK",1);
        intmat Bl = normaliz(U, "monoid", crit_degree, "gb_min_degree", crit_degree, "gb_degree_bound");
        exportNuminvs();
        swallow = setNmzOption("MRK",0);
        V = readNmzData("mrk");
        dbprint(our_printlevel,"Evaluating tete-a-tete");
        output = "Computing " + string(nrows(V)) +  " binomials";
        dbprint(our_printlevel,output);
        B = intmat2binomials(V);
    }
    else{ // we have the full Markov basis already from the Hilbert series computation.
        // However we have the full Markov basis, and not a single degree only.
        // IMPORTANT::: we use the data of the Hilbert series computation
        // in this case.
        //

        int our_deg, u;
        V = readNmzData("mrk");
        dbprint(our_printlevel,"Evaluating tete-a-tete");
        output = "Selecting from " + string(nrows(V)) + " binomials";
        dbprint(our_printlevel,output);
        Bfull = intmat2binomials(V);
        // "SSSSSSS ", size(leadexp(Bfull[1])), "   ", size(SGrad);
        B = selectionByDegree(Bfull, SGrad, crit_degree);
    }

    B = simplify(B,3);
    dbprint(our_printlevel,"Binomials computed");

    setring our_ring;
    map f =S, P;
    Q = Q, f(B);
    dbprint(our_printlevel,"Generators extended");
    Q =simplify(Q,3);
    // "Time in milliseconds ", timer-t;
    return(Q);
}

static proc Tete_A_TeteGeneral(ideal P, int current_degree, int Sagbi_degree_bound, int degreeByDegree, int makeNewTete_a_tete)
{
    int degree_tete_a_tete = -1;
    string output;
    // "Start Tete-a-tete ";
    // "current_degree ", current_degree;
    // "Sagbi_degree_bound ", Sagbi_degree_bound;
    // "degreeByDegree ", degreeByDegree;
    // "makeNewTete_a_tete ", makeNewTete_a_tete;
    // "startTete_tete", startTete_tete;
    if(makeNewTete_a_tete){
        dbprint(our_printlevel,"Making new tete-a-tete");
    }
    else{
        dbprint(our_printlevel,"Exploiting existing tete-a-tete");
    }
    ideal Q = P;
    intvec SGrad;
    if(degreeByDegree){
        int GradingDenom = gradingDenominator(Q);
        SGrad = gradVector(Q, GradingDenom);
    }

    intmat U = mons2intmat(Q);

    def our_ring = basering;
    int p = size(Q);
    list baseringlist = ringlist(basering);
    ring S = (baseringlist[1]),(y(1..p)), dp;
    // U;
    ideal B;

    int swallow = setNmzOption("MRK",1);
    intmat Dummy;
    if(current_degree != -1){
        if(degreeByDegree == 2){ // no jumping over empty degrees
            Dummy = normaliz(U, "monoid", current_degree, "gb_min_degree", current_degree, "gb_degree_bound");
                    exportNuminvs();
        }
        else{
            if(makeNewTete_a_tete){
                // U;
                // "---------------";
                // transpose(U);
                Dummy = normaliz(U, "monoid", current_degree, "gb_min_degree");
                // exportNuminvs();
                // showNuminvs();
            }
            // gb_degree_bound = -2 implies: print component d such that d >= gb_min_degree
            // and component is nonzero
            // Bl = normaliz(U, "monoid", current_degree, "gb_min_degree", -2, "gb_degree_bound");
        }
    }
    else{
        Dummy = normaliz(U, "monoid");
    }
    swallow = setNmzOption("MRK",0);

    intmat V;
    if(current_degree != -1){
        if(makeNewTete_a_tete){
            saveTete_a_tete =  readNmzData("mrk");
            startTete_tete = 1;
        }
        (V, startTete_tete) = selectNextDegree(saveTete_a_tete, startTete_tete, SGrad);
    }
    else{
        V = readNmzData("mrk");
    }

    int tete_a_tete_empty = 0;
    if(nrows(V) == 0){
        dbprint(our_printlevel,"Tete-a-tete empty");
        tete_a_tete_empty = 1;
    }
    dbprint(our_printlevel,"Evaluating tete-a-tete");
    output = "Computing " + string(nrows(V)) +  " binomials";
    dbprint(our_printlevel,output);
    B = intmat2binomials(V);
    dbprint(our_printlevel,"Binomials computed");
    int degree_too_large;
    degree_too_large = 0;
    if(degreeByDegree==1){
        degree_tete_a_tete = scalarProduct(leadexp(B[1]), SGrad);
        if(degree_tete_a_tete > Sagbi_degree_bound)
        {
            degree_too_large = 1;
        }
    }
    if(degreeByDegree==2){
        degree_tete_a_tete = current_degree;
    }
    B = simplify(B,3);
    setring our_ring;
    if(tete_a_tete_empty && degreeByDegree != 2){
        return(Q, -1);
    }
    if(degree_too_large){
        return(Q, degree_tete_a_tete);
    }
    map f =S, Q;
    Q = Q, f(B);
    dbprint(our_printlevel,"Generators extended");
    Q =simplify(Q,3);
    return(Q, degree_tete_a_tete);
}

// ------------------------------------------------
// Sagbi computation
//  -----------------------------------------------

static proc dosagbiHilbControlled(ideal Q, intvec HS_num_algebra, intvec HS_denom_algebra,
                                  int Sagbi_degree_bound, int finalCheck, int sorting){
// The code would allow Sagbi_degree_bound = -, meaning no bound

    string output;

    int crit_degree, nr_hilbbas_1, nr_hilbbas_2, i;
    bigint HF_difference;
    ideal Plow, Phigh, K, Dummy;
    intvec HS_denom_cand, HS_num_cand;
    int GradingDenom, standard_crit_degree;
    intvec HilbertBasisKey;

    ideal P = simplify(Q,15); // make initial coeff 1, erase 0, duplicates and scalar multiples
    P = completeSubduction(P);
    dbprint(our_printlevel,"Initial subduction dione");

    GradingDenom = gradingDenominator(P);
    int round = 0;
    int count;
    intmat U,V;
    int swallow;
    int is_normal;

    list L;

    crit_degree = 0;


    while(1){
        if(round > 0){
            output = "New Hilbert series " + string(round);
           dbprint(our_printlevel,output);
        }

        if(sorting){
            L = sort(P,"dp");
            P = L[1];
        }

        (HS_num_cand, HS_denom_cand, is_normal) = HilbertSeriesMonAlgebra(P, crit_degree+1);

        (crit_degree, HF_difference) = compareCCycloRatFunctions(HS_num_algebra, HS_denom_algebra,
                        HS_num_cand, HS_denom_cand);

        if(crit_degree > Sagbi_degree_bound && Sagbi_degree_bound != -1){
        output =  "critical degree = " + string(crit_degree) +  " > Sagbi_degree_bound = " + string(Sagbi_degree_bound);
            dbprint(our_printlevel,"--------------------------------------------------------------");
            return(P,0):
        }

        if(crit_degree == -1){
            if(round > 0){
                dbprint(our_printlevel,"Sagbi basis computed");
                dbprint(our_printlevel,"--------------------------------------------------------------");
            }
            return(P,2);
        }
        if(round == 0){
            dbprint(our_printlevel,"--------------------------------------------------------------");
        }
        else{
            dbprint(our_printlevel,"*********************");
        }
        round++;

        // "got Hilbert series ", HS_num_cand, "  ", HS_denom_cand;
        if(round == 1){
            output = "expected Hilbert series with representation " + string(HS_num_algebra)  + "   " + string( HS_denom_algebra);
            dbprint(our_printlevel,output);
        }
        output = "crit_degree " + string(crit_degree) + ": HF_difference " + string( HF_difference);
        dbprint(our_printlevel,output);

        // we must split our algebra generators at the critical degree
        Plow = 0;
        Phigh = 0;
        standard_crit_degree = crit_degree * GradingDenom;
        for(i = 1; i <=size(P); i++){
            if(deg(P[i])  <= standard_crit_degree){
                Plow = Plow + P[i];
            }
            else{
                Phigh = Phigh + P[i];
            }
        }
        Dummy = HilbertBasisMonAlgebra(Plow);
        nr_hilbbas_1 = size(Dummy);

        K= Tete_A_TeteHilbControlled(Plow, crit_degree,is_normal);
        dbprint(our_printlevel,"Tete-a-tete done");
        (K, HilbertBasisKey) = HilbbasSubduction(K, nr_hilbbas_1, HF_difference);
        dbprint(our_printlevel,"Subduction done");

        P = 0;
        for(i = 1; i <= size( HilbertBasisKey); i++){
            P = P + K[ HilbertBasisKey[i]];
        }

        if(crit_degree >= Sagbi_degree_bound && Sagbi_degree_bound != -1 && !finalCheck){
            output = "Sagbi basis computed up tp degree " + string(Sagbi_degree_bound);
            dbprint(our_printlevel,output);
            dbprint(our_printlevel,"No final check");
            return(P,1);
        }

        if(size(Phigh) > 0){
            P = P + Phigh;
            P = completeSubduction(P);
        }
    }
}

static proc doSagbiGeneral(ideal Q, int Sagbi_degree_bound, int Sagbi_max_rounds, int sorting)
{

    string output;

    int degreeByDegree = 0;
    if(Sagbi_degree_bound != -1){
        degreeByDegree = 1;
    }
    ideal P = simplify(Q,15); // make initial coeff 1, erase 0, duplicates and scalar multiples

    P = simplify(P,3);
    P = completeSubduction(P);
    dbprint(our_printlevel,"Initial subduction dione");

    int GradingDenom = gradingDenominator(P);
    int maxDegreeGens = deg(P[1]);
    int minDegreeGens = maxDegreeGens;
    int i;
    for(i = 2; i <= size(P); i++){
        if(deg(P[i]) > maxDegreeGens){
            maxDegreeGens = deg(P[i]);
        }
        if(deg(P[i]) < minDegreeGens){
            minDegreeGens = deg(P[i]);
        }
    }
    maxDegreeGens = maxDegreeGens div GradingDenom;
    minDegreeGens = minDegreeGens div GradingDenom;


    ideal P_1;
    int done;
    int checked;
    int makeNewTete_a_tete = 1;

    int uu = minDegreeGens;
    int degreeBoundReached;
    list L;

    int degree_tete_a_tete;

    ideal Plow, Phigh;
    int round = 1;

    while(1){
        P = simplify(P,3);
        if(sorting){
            L = sort(P, "dp");
            P = L[1];
        }

        Plow = 0;
        Phigh = 0;

        if(!degreeByDegree){
            (P_1, degree_tete_a_tete) = Tete_A_TeteGeneral(P, -1, -1, 0,1);
            P_1 = completeSubduction(P_1);
        }
        else{
            if(uu < maxDegreeGens){
                for(i = 1; i <=size(P); i++){
                    if(deg(P[i])  <= uu * GradingDenom){
                        Plow = Plow + P[i];
                    }
                    else{
                        Phigh = Phigh + P[i];
                    }
                }
                // 2 = strictly degree by degree
                (P_1, degree_tete_a_tete) = Tete_A_TeteGeneral(Plow,uu, Sagbi_degree_bound, 2, 1);
            }
            else{
                (P_1, degree_tete_a_tete) = Tete_A_TeteGeneral(P,uu, Sagbi_degree_bound, 1, makeNewTete_a_tete);
            }
            if(degree_tete_a_tete == -1){
                dbprint(our_printlevel,"Sagbi basis computed");
                return(P_1,2);
            }
            if(uu !=  degree_tete_a_tete){
                if(uu > degree_tete_a_tete){
                    ERROR("Degree in tete-a-tete too small. Inform the authors");
                }
                uu = degree_tete_a_tete;
                if(uu > Sagbi_degree_bound){
                    dbprint(our_printlevel,"Degree bound reached");
                    return(P_1, 1);
                }
                output = "Degree increased to " + string( uu);
                dbprint(our_printlevel,output);
            }
            P_1 = completeSubduction(P_1);
        }

        degreeBoundReached = 0;
        if(Sagbi_degree_bound == uu){
            degreeBoundReached = 1;
        }

        if(degreeBoundReached){
            dbprint(our_printlevel,"Degree bound reached");
            return(P_1,1);
        }

        done = 0;
        checked = 0;
        if(size(P) == size(P_1) && !degreeByDegree){
            done = 1;
            checked = 1;
            for(i = 1; i <= size(P); i++){
                if(P[i] != P_1[i]){
                    done = 0;
                    break;
                }
            }
        }

        if(done){
            dbprint(our_printlevel,"Sagbi basis compouted");
            return(P_1, 2);
        }

        round++;
        if(Sagbi_max_rounds != -1 && round > Sagbi_max_rounds){
            dbprint(our_printlevel,"Maximal number of rounds reached");
            return(P_1,1);
        }

        uu++;
        dbprint(our_printlevel,"*********************");
        output = "Round " + string( round) + " with " + string(size(P_1)) + " generators";
        dbprint(our_printlevel,output);
        if(degreeByDegree){
            output = "Degree >= " + string(uu);
            dbprint(our_printlevel, output);
        }
        if(degreeByDegree){
            if(size(P_1) > size(P) && size(Phigh) == 0 || uu == maxDegreeGens){ // we have git new generators
                makeNewTete_a_tete = 1;
            }
            else{
                makeNewTete_a_tete = 0;
            }
        }
        P = P_1 + Phigh;

     }
}

// ------------------------------------------------
// User interface
//  -----------------------------------------------

proc sagbiHilbControlled(ideal Q, intvec HS_num_algebra, intvec HS_denom_algebra, int Sagbi_degree_bound, list #)
"USAGE:   agbiHilbControlled(ideal Q, intvec HS_num_algebra, intvec HS_denom_algebra, int Sagbi_degree_bound [,int finalChweck, int sorting, int verb]);
RETURN:   An ideal whose generators form the Sagbi basis of the algebra generated
          by the polynomials inin degrwees <= Sagbi_degree_bound. The computatiojn is controlled by the Hilbert series
          given by the numerator and the denominator.

          If sorting is set, the  compouted elements are degrevlex sorted before a round of the algorithm.
                    The optional parameter verb sets the terminal output. Fefault is 1 = on.

          The component has a second integer component. Its possible values are: 0, if the full Sagbi basis has
          not been reached, 1 if this is unknown, and 2 if the full Sagbi basis has been computed.
EXAMPLE:  sagbiHilbControlled; shows an example
"
{

    int finalCheck = 0;
    int sorting = 0;

    if(size(#) > 0){
        finalCheck = #[1];
    }
    if(size(#) > 1){
        sorting = #[2];
    }
    if(size(#) > 2){
        our_printlevel = #[3];
    }

    if(Sagbi_degree_bound <= 0){
        ERROR("Degree bound must be positive");
    }

    if(!homog(Q)){
            ERROR("sagbiHilbControlled expects homogeneous input");
    }
    list baseringlist = ringlist(basering);
    intvec w = baseringlist[3][1][2];
    for(int i = 1; i <=size(w); i++){
        if(w[i] !=  1){
            ERROR("Basering not standard graded");
        }
    }

    ideal P;
    int success;
    (P, success) = dosagbiHilbControlled(Q, HS_num_algebra, HS_denom_algebra, Sagbi_degree_bound, finalCheck, sorting);
    return(P,success);
}
example
{ "EXAMPLE:"; echo=2;
    ring R = 0, (x,y,z),dp;
    ideal P = x^6+y^6+z^6, x^7+y^7+z^7, x^8+y^8+z^8;
    ideal Q;
    intvec HS_num = 1;
    intvec HS_denom = 6,7,8;
    int success;
    // degree bound 40, final check, ,no sorting, no terminal output
    (Q,success) = sagbiHilbControlled(P,HS_num, HS_denom,40, 1,0,0);
    lead(Q);
    "Note: success = 0 <==> Sagbi basis incomplete";
    "success",success;
}


proc sagbiByDegree(ideal Q, int Sagbi_degree_bound, list #)
"USAGE:   sagbiByDegree(ideal Q, int sagbiDegreeBound [,int sorting, int verb]);
RETURN:   RETURN:   An ideal whose generators form the Sagbi basis of the algebra generated
          by the polynomials inin degrwees <= Sagbi_degree_bound.

           If sorting is set, the  compouted elements are degrevlex sorted before a round of the algorithm.
          The optional parameter verb sets the terminal output. Fefault is 1 = on.

          The component has a second integer component. Its possible values are: 0, if the full Sagbi basis has
          not been reached, 1 if this is unknown, and 2 if the full Sagbi basis has been computed.

EXAMPLE:  example sagbiByDegree; shows an example
"
{
    int sorting = 0;
    if(size(#) > 0)
    {
        sorting = #[1];
    }
    if(size(#) > 1){
        our_printlevel = #[2];
    }


    if(Sagbi_degree_bound <= 0){
        ERROR("Degree bound must be positive");
    }
    if(!homog(Q)){
            ERROR("sagbiByDegree expects homogeneous input");
    }

    list baseringlist = ringlist(basering);
    intvec w = baseringlist[3][1][2];
    for(int i = 1; i <=size(w); i++){
        if(w[i] !=  1){
            ERROR("Basering not standard graded");
        }
    }

    ideal P;
    int success;
    (P, success) = doSagbiGeneral(Q, Sagbi_degree_bound, -1, sorting);

    int NrTerms = 0;
    for(int k = 1; k <= size(P); k++){
            NrTerms = NrTerms + size(P[k]);
    }
    // "Number Terms", NrTerms;


    return(P,success);
}
example
{ "EXAMPLE:"; echo=2;
    ring R = 0, (x,y,z),dp;
    ideal P = x^6+y^6+z^6, x^7+y^7+z^7, x^8+y^8+z^8;
    ideal Q;
    int success;
    // degree bound 40, no sorting, no terminal output
    (Q,success) = sagbiByDegree(P,40,0,0);
    lead(Q);
    "Note: success = 1 <==> Unknown whether complete";
    "success",success;
}


proc sagbiGeneral(ideal Q, list #)
"USAGE:   sagbiGeneral(ideal Q [, int sagbiMaxRounds, int sorting, int verb]));
RETURN:   An ideal whose generators form the Sagbi basis of the algebra generated
          by the polynomials in Q as far as computwed in at most sagbiMaxRounds.

          If sorting is set, the  compouted elements are degrevlex sorted before a round of the algorithm.
          The optional parameter verb sets the terminal output. Fefault is 1 = on.

          The component has a second integer component. Its possible values are: 0, if the full Sagbi basis has
          not been reached, 1 if this is unknown, and 2 if the full Sagbi basis has been computed.

EXAMPLE:  example agbiGeneral; shows an example
"
{
    int sorting = 0;
    int Sagbi_max_rounds = -1;
    if(size(#) > 0){
        Sagbi_max_rounds = #[1];
    }
    if(size(#) > 1){
        sorting = #[2];
    }
    if(size(#) > 2){
        our_printlevel = #[3];
    }
    ideal P;
    int success;
    (P, success) = doSagbiGeneral(Q, -1, Sagbi_max_rounds, sorting);
    return(P,success);
}
example
{ "EXAMPLE:"; echo=2;
    ring R = 0, (x,y,z),dp;
    ideal P = x^6+y^6+z^6, x^7+y^7+z^7;
    ideal Q;
    int success;
    // at most 3 rounds, no sorting, no terminal output
    (Q,success) = sagbiGeneral(P,3,0,0);
     Q;
    "Note: success = 2 <==> Sagbi basi complete";
    "success",success;
}
// ------------------------------------------------
// Initialization
//  -----------------------------------------------

static proc mod_init()
{
    LIB "general.lib";
    LIB "normaliz.lib";
    int swallow;
    addNmzOption("MRK","MarkovBasis");
    addNmzOption("REP","Representations");
    addNmzOption("BPK","BinomialsPacked");
    swallow = setNmzOption("BPK", 1);
    swallow = setNmzOption("MRK",0);
    swallow =setNmzOption("REP",0);
    setNmzFilename("NmzSagbiExchange");
    intmat saveTete_a_tete;
    int startTete_tete;
    export(saveTete_a_tete);
    export(startTete_tete);
    int our_printlevel = 1;
    export(our_printlevel);
}

