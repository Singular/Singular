//////////////////////////////////////////////////////////////////////
version="version ncloc.lib 4.1.2.0 Feb_2019 "; // $Id$
category="Noncommutative";
info="
LIBRARY:   ncloc.lib  Ore-localization in G-Algebras
AUTHOR:    Johannes Hoffmann, email: johannes.hoffmann at math.rwth-aachen.de

OVERVIEW:
This library introduces a new type: ncloc.
This type wraps the localization data defined as in olga.lib.
An element of type ncloc has two members:
  - int locType
  - def locData

OPERATIONS:
string(ncloc);
  give a string representation of the data describing the localization
print(ncloc);
  prints the string representation of the localization
status(ncloc);
  report on the status/validity of the localization
test(ncloc);
  check if the localization is valid

INFIX OPERATIONS:
ncloc == ncloc;
  compare two localizations
ncloc != ncloc;
  compare two localizations
ncloc = list/poly
  create a monoidal localization from the given data
ncloc = ideal
  create a geometric localization from the given data
ncloc = intvec
  create a rational localization from the given data

PROCEDURES:
isDenom(poly, ncloc);
  determine if a polynomial is in the denominator set of the localization
testNcloc();
  execute a series of internal testing procedures
testNclocExamples();
  execute the examples of all procedures in this library
";
//////////////////////////////////////////////////////////////////////
proc testNclocExamples()
"USAGE:   testNclocExamples()
PURPOSE: execute the examples of all procedures in this library
RETURN:  nothing
NOTE:
EXAMPLE: "
{
    example isDenom;
}
//////////////////////////////////////////////////////////////////////
proc testNcloc()
"USAGE:   testNcloc()
PURPOSE: execute a series of internal testing procedures
RETURN:  nothing
NOTE:
EXAMPLE: "
{
    print("testing ncloc.lib...");
    testNclocCreation();
    testNclocComparison();
    testDenominatorDetection();
    print("testing complete - ncloc.lib OK");
}
//////////////////////////////////////////////////////////////////////
static proc mod_init() {
    LIB "olga.lib";
    /* new type: ncloc (non-commutative localization) */
    newstruct("ncloc", "def locData, int locType");
    // types: 0 - monoidal, 1 - geometric, 2 - rational
    system("install", "ncloc", "string", nclocToString, 1);
    system("install", "ncloc", "print", printNcloc, 1);
    system("install", "ncloc", "=", createNcloc, 1);
    system("install", "ncloc", "==", compareNclocs, 2);
    system("install", "ncloc", "!=", invertedCompareNclocs, 2);
    system("install", "ncloc", "test", testNcloc, 4);
    system("install", "ncloc", "status", statusNcloc, 4);
}
////////// status and printing ///////////////////////////////////////
static proc statusNcloc(ncloc loc) {
    return(locStatus(loc.locType, loc.locData)); // locStatus from olga.lib
}
//////////////////////////////////////////////////////////////////////
static proc testNcloc(ncloc loc) {
    list stat = status(loc);
    if(!stat[1]) {
        ERROR(stat[2]);
    } else {
        return();
    }
}
//////////////////////////////////////////////////////////////////////
static proc nclocToString(ncloc loc) {
    list stat = status(loc);
    if (!stat[1]) {
        return(stat[2]);
    }
    string result;
    int locT = loc.locType;
    int i;
    if (locT == 0) {
        list data = loc.locData;
        result = result + "monoidal localization generated by:" + newline;
        result = result + string(data[1]);
        for (i = 2; i <= size(data); i++) {
            result = result + ", " + string(data[i]);
        }
    }
    if (locT == 1) {
        ideal data = loc.locData;
        result = result + "geometric localization at prime ideal:" + newline;
        result = result + data;
    }
    if (locT == 2) {
        intvec data = loc.locData;
        result = result + "rational localization generated by:" + newline;
        result = result + string(var(data[1]));
        for (i = 2; i <= size(data); i++) {
            result = result + ", " + string(var(data[i]));
        }
    }
    if (result == "") {
        result = "invalid localization";
    }
    return(result);
}
//////////////////////////////////////////////////////////////////////
static proc printNcloc(ncloc loc) {
    print(string(loc));
}
////////// initialization, comparison and declaration ////////////////
static proc createNcloc(def input) {
    string inputType = typeof(input);
    ncloc result;
    if (inputType == "list") {
        result.locType = 0;
        result.locData = normalizeMonoidal(input);
    }
    if (inputType == "poly") {
        result.locType = 0;
        result.locData = normalizeMonoidal(list(input));
    }
    if (inputType == "ideal") {
        result.locType = 1;
        result.locData = std(input);
    }
    if (inputType == "intvec") {
        result.locType = 2;
        result.locData = normalizeRational(input);
    }
    test(result);
    return(result);
}
//////////////////////////////////////////////////////////////////////
static proc compareNclocs(ncloc loc1, ncloc loc2) {
    // only detects "naturally" isomorphic localizations
    test(loc1);
    test(loc2);
    int locT = loc1.locType;
    if (locT != loc2.locType) {
        return(0); // different types of localizations
    }
    if (locT == 0) {
        int i, j, found;
        list L1 = loc1.locData;
        list L2 = loc2.locData;
        for (i = 1; i <= size(L1); i++) { // test if L1 subset of L2
            found = 0;
            for (j = 1; j <= size(L2); j++) {
                if (L1[i] == L2[j]) {
                    found = 1;
                    break;
                }
            }
            if (!found) {
                return(0);
            }
        }
        for (j = 1; j <= size(L2); j++) { // test if L2 subset of L1
            found = 0;
            for (i = 1; i <= size(L1); i++) {
                if (L1[i] == L2[j]) {
                    found = 1;
                    break;
                }
            }
            if (!found) {
                return(0);
            }
        }
        return(1);
    }
    if (locT == 1) {
        ideal I1 = std(loc1.locData);
        ideal I2 = std(loc2.locData);
        if (size(NF(I1,I2)) != 0) { // test if I1 subset of I2
            return(0);
        }
        if (size(NF(I2,I1)) != 0) { // test if I2 subset of I1
            return(0);
        }
        return(1);
    }
    if (locT == 2) {
        return(loc1.locData == loc2.locData); // direct comparison of intvec
    }
    ERROR("unreachable state reached"); // enforced by testNcloc
}
//////////////////////////////////////////////////////////////////////
static proc invertedCompareNclocs(ncloc loc1, ncloc loc2) {
    return(!(compareNclocs(loc1, loc2)));
}
//////////////////////////////////////////////////////////////////////
proc isDenom(poly p, ncloc loc)
"USAGE:   isDenom(p, loc), poly a, ncloc loc
PURPOSE: check if p is a valid denominator in the localization loc
RETURN:  int
NOTE:    returns 1 or 0, depending whether p is a valid denominator
EXAMPLE: example isDenom; shows examples"
{
    return(isInS(p, loc.locType, loc.locData, 1)); // isInS from olga.lib
}
example
{
    "EXAMPLE:"; echo = 2;
    ring R = 0,(x,y,Dx,Dy),dp;
    def S = Weyl();
    setring S; S;
    // monoidal localization
    ncloc loc;
    poly g1 = x^2*y+x+2;
    poly g2 = y^3+x*y;
    list L = g1,g2;
    loc = L;
    poly g = g1^2*g2;
    poly f = g - 1;
    isDenom(g, loc);
    isDenom(f, loc);
    // geometrical localization
    loc = ideal(x-1,y-3);
    g = x^2+y-3;
    f = (x-1)*g;
    isDenom(g, loc);
    isDenom(f, loc);
    // rational localization
    intvec v = 2;
    loc = v;
    g = y^5+17*y^2-4;
    f = x*y;
    isDenom(g, loc);
    isDenom(f, loc);
}
//////////////////////////////////////////////////////////////////////
////////// internal testing procedures ///////////////////////////////
static proc testNclocCreation()
{
    print("  testing ncloc creation...");
    ring r = 0,(x,y,Dx,Dy),dp;
    def R = Weyl();
    setring R;
    ncloc loc1 = list(x*y,4*x); // create from list
    ncloc loc2 = 3*Dx*Dy+2; // create from poly
    ncloc loc3 = ideal(x-3,y2+y+1); // create from ideal
    ncloc loc4 = intvec(1,2); // create from intvec
    ncloc loc5 = intvec(3);
    print("    ncloc creation OK");
}
//////////////////////////////////////////////////////////////////////
static proc testNclocComparison()
{
    print("  testing ncloc comparison...");
    ring r = 0,(x,y,Dx,Dy),dp;
    def R = Weyl();
    setring R;
    // monoidal localization
    ncloc monloc1 = list(x,y-3);
    ncloc monloc2 = list(x*(y-3)^2);
    ncloc monloc3 = list(y-3);
    if (!(monloc1 == monloc2)) {
        ERROR("monoidal comparison failed");
    }
    if (!(monloc1 != monloc3)) {
        ERROR("monoidal inverted comparison failed");
    }
    // geometric localization
    ncloc geoloc1 = ideal(x*y-y+2, y^2-x-2);
    ncloc geoloc2 = ideal(x*y-y+2, y^2-x-2, x^2+x+2*y-2);
    ncloc geoloc3 = ideal(x*y-y+1, y^2-x-2);
    if (!(geoloc1 == geoloc2)) {
        ERROR("geometric comparison failed");
    }
    if (!(geoloc1 != geoloc3)) {
        ERROR("geometric inverted comparison failed");
    }
    // rational localization
    ncloc ratloc1 = intvec(1);
    ncloc ratloc2 = intvec(1,1);
    ncloc ratloc3 = intvec(2);
    if (!(ratloc1 == ratloc2)) {
        ERROR("rational comparison failed");
    }
    if (!(ratloc1 != ratloc3)) {
        ERROR("rational inverted comparison failed");
    }
    print("    ncloc comparison OK");
}
//////////////////////////////////////////////////////////////////////
static proc testDenominatorDetection() {
    print("  testing ncloc denominator detection...");
    ring R = 0,(x,y,Dx,Dy),dp;
    def S = Weyl();
    setring S;
    // monoidal localization
    ncloc loc;
    poly g1 = x^2*y+x+2;
    poly g2 = y^3+x*y;
    loc = list(g1,g2);
    poly g = g1^2*g2;
    poly f = g - 1;
    if (!isDenom(g, loc)) {
        ERROR("monoidal positive denominator detection error");
    }
    if (isDenom(f, loc)) {
        ERROR("monoidal negative denominator detection error");
    }
    // geometric localization
    loc = ideal(x-1,y-3);
    g = x^2+y-3;
    f = (x-1)*g;
    if (!isDenom(g, loc)) {
        ERROR("geometric maximal positive denominator detection error");
    }
    if (isDenom(f, loc)) {
        ERROR("geometric maximal negative denominator detection error");
    }
    loc = ideal(x);
    g = x*y^2-7*y+3;
    f = x^2-3*x;
    if (!isDenom(g, loc)) {
        ERROR("geometric prime positive denominator detection error");
    }
    if (isDenom(f, loc)) {
        ERROR("geometric prime negative denominator detection error");
    }
    // rational localization
    loc = intvec(2);
    g = y^5+17*y^2-4;
    f = x*y;
    if (!isDenom(g, loc)) {
        ERROR("rational positive denominator detection error");
    }
    if (isDenom(f, loc)) {
        ERROR("rational negative denominator detection error");
    }
    print("    ncloc denominator detection OK");
}
//////////////////////////////////////////////////////////////////////
