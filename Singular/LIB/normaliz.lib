//// Singular library normaliz.lib
version="version normaliz.lib 4.3.2.14 Apr_2023 "; // $Id$
category="Commutative Algebra";
info="
LIBRARY: normaliz.lib  Provides an interface for the use of Normaliz 3.10.0 or
         newer within SINGULAR.
AUTHORS: Winfried Bruns, wbruns@uos.de
         Christof Soeger, Christof.Soeger@Uni-Osnabrueck.de

OVERVIEW:
@texinfo
The library normaliz.lib provides an interface for the use of Normaliz 3.10.0 or
newer within SINGULAR. The exchange of data is via files.
In addition to the top level
functions that aim at objects of type ideal or ring, several other auxiliary
functions allow the user to apply Normaliz to data of type intmat.  Options
such as compoutationn goals or algorithmic variants can be activated.To some extent,
SINGULAR can therefore be used as an environment for interactive access to Normaliz.
@* Please see the @code{Normaliz.pdf} (included in the Normaliz
distribution) for a more extensive documentation of Normaliz.

Normaliz allows the use of a grading. In the Singular functions that access
Normaliz the parameter grading is an intvec that assigns a (not necessarily
positive) degree to every variable of the ambient polynomial ring.
But it must give positive degrees to the generators given to the function.

Singular and Normaliz exchange data via files. The input files use the Normaliz 3 syntax.
These files are automatically
created and erased behind the scenes. As long as one wants to use only the
ring-theoretic functions there is no need for file management.
@*Note that the numerical invariants computed by Normaliz can be
accessed in this \"automatic file mode\".
@*However, if Singular is used as a frontend for Normaliz or the user
wants to inspect data not automatically returned to Singular, then
an explicit filename and a path can be specified for the exchange of
data. Moreover, the library provides functions for access to these files.
Deletion of the files is left to the user.  (Not all output files
of Normaliz can be read by this library.)

Use of this library requires the program Normaliz >=3.10.0 to be installed.
You can download it from
@uref{https://github.com/Normaliz/Normaliz/releases}. Please make sure
that the executable is in the search path or use setNmzExecPath
(@ref{setNmzExecPath}).
@end texinfo

KEYWORDS: integral closure; normalization; toric ring

PROCEDURES:
 intclToricRing(ideal I)      computes the integral closure of the toric ring
                              generated by the leading monomials of the
                              elements of I in the basering
 normalToricRing(ideal I)     computes the normalization of the toric ring
                              generated by the leading monomials of the
                              elements of I
 proc hilbertSeriesToricRing(ideal I) computes the Hilbert series of the toric ring
                              generated by the lead monomials of the elements in I.
                              A grading can be specified
 normalToricRingFromBinomials(ideal I)  computes the normalization of the
                              polynomial ring modulo the unique minimal binomial
                              prime ideal of the binomial ideal I
 toricRingFromBinomials(ideal I)  computes the polynomial ring modulo the unique
                              inimal binomial prime ideal of the binomial ideal I
 ehrhartRing(ideal I)         considers the exponent vectors of the elements of I
                              as points of a lattice polytope and computes the
                              integral closure of the polytopal algebra
 intclMonIdeal(ideal I)       Computes the integral closure of the Rees algebra
                              of the ideal generated by the leading monomials of
                              the elements of I
 definingBinomialIdeal(ideal I) computes the defining binomail ideal of the toric ring
                              generated by the leading monomials of the elements of I
 latticeIdeal(ideal I)        computes the lattice ideal defined by the binomial ideal I
 groebnerBasis(ideal I)       computes a GrÃ¶bner basis of the lattice ideal defined by
                              the binomial ideal I
 torusInvariants(intmat T)    computes the ring of invariants of a torus action
 finiteDiagInvariants(intmat C)  computes the ring of invariants of a finite
                                 abelian group acting diagonally on a polynomial
                                 ring
 diagInvariants(intmat C)     computes the ring of invariants of a
                              diagonalizable group
 intersectionValRings(intmat V)   computes the intersection of the polynomial
                                  ring with the valuation rings of monomial
                                  valuations
 intersectionValRingIdeals(intmat V)       computes ideals of monomial valuations
 showNuminvs()                prints the numerical invariants found by Normaliz
 exportNuminvs()              exports the numerical invariants found by Normaliz

 allNmzOptions() prints all available Normaliz options with thei naming string,
                               the default value and the string passed to Normaliz
 setNmzOption(string s, int onoff) sets the option s to onoff
 addNmzOption(string short_cut, string nmz_oprion) adds a Normaliz option to the list
                              of predefined ones and activates it
 showNmzOptions()             prints the enabled options to the standard output
 resetNmzOptions() resets the options to the default choice

 normaliz(intmat input_mat,string nmz_type,...) applies Normaliz to the input matrix
                              of type nmz_type. Further arguments can be additional matrices and integer parameters.
 setNmzExecPath(string nmz_exec_path_name) sets the path to the Normaliz
                                           executable

 writeNmzData(intmat sgr, string nmz_type) creates an input file for Normaliz
                            (also from a list of pairs sgr, nmz_type)
 readNmzData(string nmz_suffix) reads the Normaliz output file with the
                                specified suffix

 setNmzFilename(string nmz_filename_name) sets the filename for the exchange
                                          of data
 setNmzDataPath(string nmz_data_path_name) sets the directory for the exchange
                                           of data
 writeNmzPaths()              writes the path names into two files
 startNmz()                   retrieves the path names written by writeNmzPaths
 rmNmzFiles()                 removes the files created for and by Normaliz

 mons2intmat(ideal I)         returns the intmat whose rows represent the
                              leading exponents of the elements of I
 intmat2mons(intmat expo_vecs) returns the ideal generated by the monomials
                               which have the rows of expo_vecs as
                               exponent vector
 binomials2intmat(ideal I)    returns the intmat whose rows represent the
                              exponents of the elements of the binomial ideal I
 intmat2binomials(intmat expo_vecs)   returns the ideal generated by the binomials
                              represent by the rows of the intmat expo_vecs
";


// helpers
static proc fileExists(string f)
{
    return(status (f,"exists")=="yes");
}

static proc appendSlash(string s)
// if nonempty and / is not the terminating char
{
    if(size(s)>0)
    {
        if(s[size(s)]!="/")
        {
            s=s+"/";
            return(s);
        }
    }
    return(s);
}

// filenames and paths

proc setNmzExecPath(string nmz_exec_path_name)
"USAGE:   setNmzExecPath(string s);   @code{s} path to the Normaliz executable
CREATE:   @code{Normaliz::nmz_exec_path} to save the given path @code{s}
NOTE:     It is not necessary to use this function if the Normaliz executable
          is in the search path of the system.
SEE ALSO: setNmzOption
EXAMPLE:  example setNmzExecPath; shows an example"
{
    nmz_exec_path=nmz_exec_path_name;
    nmz_exec_path=appendSlash(nmz_exec_path);
}
example
{ "EXAMPLE:";echo = 2;
  setNmzExecPath("../Normaliz/");
}

proc setNmzFilename(string nmz_filename_name)
"USAGE:   setNmzFilename(string s);
CREATE:   @code{Normaliz::nmz_filename} to save the given filename @code{s}
NOTE:     The function sets the filename for the exchange of data. Unless a
          path is set by setNmzDataPath, files will be created in the current
          directory.
          @* If a non-empty filename is set, the files created for and by
             Normaliz are kept. This is mandatory for the data access functions
             (see @ref{writeNmzData} and @ref{readNmzData}).
          @* Resetting the filename by setNmzFilename(\"\") forces the library
             to return to deletion of temporary files, but the files created
             while the filename had been set will not be erased.
SEE ALSO: writeNmzData, readNmzData, setNmzDataPath, rmNmzFiles
EXAMPLE:  example setNmzFilename; shows an example"
{
    nmz_filename=nmz_filename_name;
    if(nmz_filename_name!="")
    {
        nmz_files_keep_switch=1;
    }
    else
    {
        nmz_files_keep_switch=0;
    }
}
example
{ "EXAMPLE:";echo = 2;
  setNmzDataPath("examples/");
  setNmzFilename("example1");
  //now the files for the exchange with Normaliz are examples/example1.SUFFIX
}

proc setNmzDataPath(string nmz_data_path_name)
"USAGE:   setNmzDataPath(string s);
CREATE:   @code{Normaliz::nmz_data_path} to save the given path @code{s}
NOTE:     The function sets the path for the exchange of data. By default the
          files will be created in the current directory.
          @* It seems that Singular cannot use filenames starting with @code{~}
             or @code{$HOME} in its input/output functions.
          @* You must also avoid path names starting with @code{/} if you work
             under Cygwin, since Singular and Normaliz interpret them in
             different ways.
SEE ALSO: writeNmzData, readNmzData, rmNmzFiles, setNmzFilename
EXAMPLE:  example setNmzDataPath; shows an example"
{
    nmz_data_path=nmz_data_path_name;
    nmz_data_path=appendSlash(nmz_data_path);
}
example
{ "EXAMPLE:";echo = 2;
  setNmzDataPath("examples/");
  setNmzFilename("example1");
  //now the files for the exchange with Normalize are examples/example1.SUFFIX
}

proc writeNmzPaths();
"USAGE:   writeNmzPaths();
CREATE:   the file nmz_sing_exec.path where the path to the Normaliz executable
          is saved
          @* the file nmz_sing_data.path where the directory for the exchange
          of data is saved
NOTE:     Both files are saved in the current directory. If one of the names
          has not been defined, the corresponding file is created, but
          contains nothing.
SEE ALSO: setNmzDataPath, setNmzExecPath, startNmz
EXAMPLE:  example writeNmzPaths; shows an example
"{
    link outf=":w nmz_sing_exec.path";
    write(outf, nmz_exec_path);
    close(outf);

    outf=":w nmz_sing_data.path";
    write(outf, nmz_data_path);
    close(outf);
}
example
{ "EXAMPLE:";echo = 2;
  setNmzExecPath("../Normaliz/");
  writeNmzPaths();
  int dummy=system("sh","cat nmz_sing_exec.path");
  dummy=system("sh","cat nmz_sing_data.path");
}

proc startNmz()
"USAGE:   startNmz();
PURPOSE:  This function reads the files written by @code{writeNmzPaths()},
          retrieves the path names, and types them on the standard output
          (as far as they have been set). Thus, once the path names have been
          stored, a Normaliz session can simply be opened by this function.
SEE ALSO: setNmzDataPath, setNmzExecPath, writeNmzPaths
EXAMPLE:  example startNmz; shows an example
"
{
    link inf=":r nmz_sing_exec.path";
    string s=read(inf);
    int i,p;
    p=findWord("/",s,1);
    if(p!=-1)
    {
        for(i=size(s);i>=1;i--)
        {
            if(s[i]=="/")
            {
                s=s[1..i];
                break;
            }
        }
        nmz_exec_path=s;
        "nmz_exec_path is",nmz_exec_path;
    }
    else
    {
        "nmz_exec_path not set";
    }

    inf=":r nmz_sing_data.path";
    s=read(inf);
    p=findWord("/",s,1);
    if(p!=-1)
    {
        for(i=size(s);i>=1;i--)
        {
            if(s[i]=="/")
            {
                s=s[1..i];
                break;
            }
        }
        nmz_data_path=s;
        "nmz_data_path is",nmz_data_path;
    }
    else
    {
        "nmz_data_path not set";
    }
}
example
{ "EXAMPLE:"; echo=2;
  writeNmzPaths();
  startNmz();
}

static proc getNmzFile()
{
    if(nmz_files_keep_switch)
    {
        return(nmz_data_path+nmz_filename);
    }
    else
    {
        return(nmz_filename);
    }
}

static proc makeTempNmzDataPath()
{
    string testdir, testdir1;
    int i,dummy;

    testdir1="/tmp/nmz_sing_"+string(system("pid"));
    testdir=testdir1;
    while(fileExists(testdir))
    {
        i = i +1;
        testdir=testdir1+string(i);
    }
    dummy=system("sh","mkdir "+ testdir);
    nmz_filename=testdir+"/nmz"; //files are nmz+suffix in testdir
}

static proc eraseTempNmzDataPath();
{
    int dummy;

    string tmpdir=getNmzFile();
    tmpdir=tmpdir[1..size(tmpdir)-4]; // remove "/nmz"
    dummy=system("sh","rm -r "+tmpdir);
    setNmzFilename("");
}

static proc setNmzExec()
{
    return(nmz_exec_path+"normaliz");
}

proc rmNmzFiles()
"USAGE:  rmNmzFiles();
PURPOSE: This function removes the files created for and by Normaliz, using
         the last filename specified.
         It needs an explicit filename set (see @ref{setNmzFilename}).
SEE ALSO: writeNmzData, readNmzData, setNmzFilename, setNmzDataPath
EXAMPLE:  example rmNmzFiles; shows an example
"{

    if(!nmz_files_keep_switch)
    {
        ERROR("rmNmzFiles: no filename specified");
    }

    list suffixes="in","gen","out","cst","typ","egn","esp","inv","tri","ht1",
                  "ext","dec", "lat", "mod", "tgn", "msp", "inc", "fac", "aut",
                  "IntHull.out", "symm.out", ".ProjectCone.out, grb, mrk, rep", "ogn";
    int i,dummy;
    string f;

    for(i=1;i<=size(suffixes);i++)
    {
        f=getNmzFile()+"."+suffixes[i];
        if (fileExists(f))
        {
            dummy=system("sh","rm "+f+ "&> /dev/null");
        }
    }
}
example
{ "EXAMPLE:"; echo=2;
  setNmzFilename("VeryInteresting");
  rmNmzFiles();
}



// parsing normaliz output

static proc digit(string s)
{
    if(s==" ") // skip blanks quickly
    {
        return(0);
    }

    if((s[1]>="0" && s[1]<="9")||s[1]=="-")
    {
        return(1);
    }
    return(0);
}

static proc nextWord(string s, int p)
{
    int j,sw,ew;

    for(;p<=size(s);p++) // must start with a letter
    {

        if((s[p]>="a" && s[p]<="z")||
             (s[p]>="A" && s[p]<="Z"))
        {
            sw=p; break;
        }
    }
    if(p>size(s))
    {
        return(-1,-1); // no word found
    }

    for(;p<=size(s);p++) // now numerals and -_ allowed
    {
        if(!((s[p]>="a" && s[p]<="z")||
             (s[p]>="A" && s[p]<="Z")||
             (s[p]>="0" && s[p]<="9")||
              s[p]=="_"||s[p]=="-"))
        {
            break;
        }
    }
    return(sw,p);
}

static proc getInt(string s, int p)
{
    string nst;
    int i,j,en,sn;

    for(;p<=size(s);p++)
    {

        if(digit(s[p]))
        {
            sn=p; break;
        }
    }
    if(not(sn))
    {
        return(0,-1); // -1 indicates: no number found
    }
    p++;
    for(;p<=size(s);p++)
    {
        if(!digit(s[p]))
        {
            en=p-1; break;
        }
    }
    if(p>size(s))
    {
        en=size(s);
    }
    nst="i="+s[sn,en-sn+1];
    execute(nst);
    return(i,p);
}


static proc getRational(string s, int p)
{
    string nst;
    int i,j,en,sn;

    for(;p<=size(s);p++)
    {
        if(digit(s[p]))
        {
            sn=p; break;
        }
    }
    if(not(sn))
    {
        return(0,-1); // -1 indicates: no number found
    }
    p++;
    int slash_at;
    for(;p<=size(s);p++)
    {
        if(s[p]=="/")
        {
            slash_at=p;
            p++;
            continue;
        }
        if(!digit(s[p]))
        {
            en=p-1; break;
        }
    }
    if(p>size(s))
    {
        en=size(s);
    }
    if(slash_at)
    {
        nst="i="+s[sn,slash_at-sn];
        execute(nst);
        nst="j="+s[slash_at+1,en-slash_at];
        execute(nst);
        return(i,p,j);
    }
    nst="i="+s[sn,en-sn+1];
    execute(nst);
    return(i,p);
}


static proc findWord(string s, string t, int p)
{
    for(;p<=size(t)-size(s)+1;p++)
    {
        if(t[p]==s[1])
        {
            if(t[p,size(s)]==s)
            {
                 return(p+size(s));
            }
        }
    }
    return(-1);
}


static proc skipEqualsign(string s,int p)
{
    for(;p<=size(s);p++)
    {
        if(s[p]=="=")
        {
            break;
        }
    }
    return(p+1);
}


// input and output to/from normaliz

// for backward compatibility:
static proc num_type_to_string(int nmz_type)
{
    if (nmz_type == 20) {
        return("grading");}
    if (nmz_type == 0) {
        return("integral_closure");}
    if (nmz_type == 1) {
        return("normalization");}
    if (nmz_type == 2) {
        return("polytope");}
    if (nmz_type == 3) {
        return("rees_algebra");}
    if (nmz_type == 4) {
        return("inequalities");}
    if (nmz_type == 5) {
        return("equations");}
    if (nmz_type == 6) {
        return("congruences");}
    if (nmz_type == 10) {
        return("lattice_ideal");}
    if (nmz_type == -1) {
        return("-1");}
}

//list must have pairs of intmat, nmz_type
static proc doWriteNmzData(list #)
{
    string s;
    int i,j;
    link outf=":w "+ getNmzFile() +".in";  // also sets the filename

    intmat sgr;
    intvec vecinput;
    int num_rows, num_cols;
    string nmz_type;

    write(outf,"amb_space auto");

    for (int k=1; k<=size(#); k=k+2) {
    //get data from the parameter list
        if(typeof(#[k+1]) == "int"){
            nmz_type = num_type_to_string(#[k+1]);}
        else{
            nmz_type   = #[k+1];}

        if (nmz_type != "-1") { //skip -1 type

            if(typeof(#[k]) == "int"){
                s= nmz_type + " ";
                s= s + string(#[k]);
                write(outf, s);
            }
            if(typeof(#[k]) == "intvec"){
                vecinput = #[k];
                s= nmz_type;
                write(outf, s);
                write(outf,"[");
                s = "";
                for(i=1;i<= size(vecinput);i++){
                    s= s + string(vecinput[i]);
                }
                write(outf,s);
                write(outf,"]");
            }
            if(typeof(#[k]) != "int" && typeof(#[k]) != "intvec"){
                write(outf, nmz_type);
                sgr = #[k];
                num_rows = nrows(sgr);
                num_cols = ncols(sgr);

                if(nmz_type != "grading")
                {
                    write(outf,"[");
                }

                for(i=1;i<=nrows(sgr);i++)
                {
                    s="[";
                    for(j=1;j<=num_cols -1;j++)
                    {
                        s= s + string(sgr[i,j]);
                        s = s + ", ";
                    }
                    s= s + string(sgr[i,num_cols]);
                    s = s + "]";
                    write(outf,s);
                }
                if(nmz_type != "grading")
                {
                    write(outf,"]");
                }
            }
        }
    }
    close(outf);
}

static proc prepareGrading(list #)
{
    if (size(#)==0) {
        return(0,-1); // type -1 specifies discard the matrix
    }
    if (size(#)>1) {
        print(#);
        ERROR("To many parameters!");
    }
    intmat g = intmat(#[1],1,size(#[1]));
    return (g,"grading");
}


proc writeNmzData(list #)
"USAGE:   writeNmzData(intmat M, string nmz_type);
          writeNmzData(intmat M, string nmz_type, intmat M2, string nmz_type2, ...);
CREATE:   Creates an input file for Normaliz from the matrix M. The second
          parameter sets the type. How the matrix is interpreted depends on the
          type. See the Normaliz documentation for more information.

          It is also possible to give more than one pair of matrix and type. In
NOTE:     Needs an explicit filename set. The filename is created from the
          current filename.
   @*     Note that all high level functions in normaliz.lib write and read their
          data automatically to and from the hard disk so that writeNmzData will
          hardly ever be used explicitly.
SEE ALSO: readNmzData, rmNmzFiles, setNmzFilename, setNmzDataPath
EXAMPLE:  example writeNmzData; shows an example"
{
    if(nmz_filename=="")
    {
        ERROR("writeNmzData: no filename specified");
    }
    doWriteNmzData(#);
}
example
{ "EXAMPLE:"; echo=2;
  setNmzFilename("VeryInteresting");
  intmat sgr[3][3]=1,2,3,4,5,6,7,8,10;
  writeNmzData(sgr,"cone_and_lattice");
  int dummy=system("sh","cat VeryInteresting.in");

  intmat Inequalities[2][3] = 2,-1,0, // 2x-y >= 0
                             1, 1,0; //  x+y >= 0
  intmat Equation[1][3] = 0,1,-1;    // y = z
  intmat Congruence[1][4] = 1,0,0,3;  // x = 0 (3)
  writeNmzData(Inequalities,"inequalities",Equation,"equations",Congruence,"congruences");
  dummy=system("sh","cat VeryInteresting.in");
}

static proc readNmzSparseMatrix(string nmz_suffix)
{
    string s;
    int n_rows,n_cols;            //number of rows/columns
    int p;                     //position
    int i,j;

    string filename = getNmzFile() + "."+ nmz_suffix;
    link in_f=":r "+ filename;
    s=read(in_f);
    close(in_f);

    p=1;

    (n_rows,p)=getInt(s,p);
    n_rows = - n_rows;
    (n_cols,p)=getInt(s,p);

    intmat nmz_gen[n_rows][n_cols];
    int nr_nonzero_entries;
    int k;
    for(i=1;i<=n_rows;i++)
    {
        (nr_nonzero_entries,p)=getInt(s,p);
        for(j=1;j<=nr_nonzero_entries;j++)
        {
            (k,p)=getInt(s,p);
            (nmz_gen[i,k],p) = getInt(s,p);
        }
    }

    return(nmz_gen);
}


proc readNmzData(string nmz_suffix)
"USAGE:  readNmzData(string suffix);
RETURN:  Reads an output file of Normaliz containing an integer matrix and
         returns it as an intmat. For example, this function is useful if one
         wants to inspect the support hyperplanes. The filename is created
         from the current  filename and the suffix given to the function.
         In addition to file suffixes, also sup, equ and cgr are allowed.
         They extract the support hyperplanes, equations and congruences,
         respectively, from the cst file.
NOTE:    Needs an explicit filename set by setNmzFilename.
   @*    Note that all functions in normaliz.lib write and read their data
         automatically so that readNmzData will usually not be used explicitly.
   @*    This function reads only the first matrix in a file! But see su, equ, cgr above.)
   @*    It is the responsability of the user to make sure that an output file
         read by this function has been created for the current input file of Normaliz.
         Files are not automatically removed before a new computation starts.
   @*    Not every output file can be read by this function.
SEE ALSO: writeNmzData, rmNmzFiles, setNmzFilename, setNmzDataPath
EXAMPLE:  example readNmzData; shows an example"
{
    if(nmz_filename=="")
    {
        ERROR("readNmzData: no filename specified");
    }

    if(nmz_suffix == "rep" || nmz_suffix == "grb" || nmz_suffix == "mrk"){
        return(readNmzSparseMatrix(nmz_suffix));
    }

    string s;
    int n_rows,n_cols;            //number of rows/columns
    int p;                     //position
    int i,j;
    int returnvalue;

    int which_matrix = 1;
    if(nmz_suffix == "sup"){
        nmz_suffix = "cst";
    }
    if(nmz_suffix == "equ"){
        nmz_suffix = "cst";
        which_matrix = 2;
    }
    if(nmz_suffix == "cgr"){
        nmz_suffix = "cst";
        which_matrix = 3;
    }

    string filename = getNmzFile() + "."+ nmz_suffix;
    link in_f=":r "+ filename;
    s=read(in_f);
    close(in_f);

    p=1;
    for(int mm = 1; mm <= which_matrix; mm = mm + 1)
    {
        (n_rows,p)=getInt(s,p);
        (n_cols,p)=getInt(s,p);
        if( mm > 1){
            kill nmz_gen;
        }
        intmat nmz_gen[n_rows][n_cols];
        for(i=1;i<=n_rows;i++)
        {
            for(j=1;j<=n_cols;j++)
            {
                (nmz_gen[i,j],p) = getInt(s,p);
            }
        }
    }
    return(nmz_gen);
}
example
{ "EXAMPLE:"; echo=2;
  setNmzFilename("VeryInteresting");
  intmat sgr[3][3]=1,2,3,4,5,6,7,8,9;
  intmat sgrnormal=normaliz(sgr,"cone");
  readNmzData("sup");
  readNmzData("equ");
}



proc setNmzOption(string s, int onoff)
"USAGE:   setNmzOption(string s, int onoff);
PURPOSE:  If @code{onoff=1} the option @code{s} is activated, and
          if @code{onoff=0} it is deactivated.
The predefined Normaliz options are accessible via the following names:
@* @code{-s:  supp}
@* @code{-t:  triang}
@* @code{-v:  volume}
@* @code{-p:  hvect} deprecated, replacement:
@* @code{-p:  hvect_deg1}
@* @code{-q:  only_hvect}
@* @code{--FVector:  fvect}
@* @code{-1:  height1}
@* @code{-G:  Gorenst}
@* @code{-w:  witness}
@* @code{--IsIntegrallyClosed:  intclosed}
@* @code{-C:  classgroup}
@* @code{-n:  normal}  deprecated, replacement:
@* @code{-n:  hilbbasvol}
@* @code{-N:  normal_l}  deprecated, replacement:
@* @code{-N:  hilbbas}
@* @code{-h:  hilb} deprecated, replacement:
@* @code{-h:  hilbbas_hvect}
@* @code{--MarkovBasis: groebner}
@* @code{--GroebnerBasis: markov}
@* @code{--Lex: lex}
@* @code{--RevLex: revlex}
@* @code{--DegLex: deglex}
@* @code{-d:  dual}
@* @code{-M:  genoverori}
@* @code{-a:  allf}
@* @code{--typ:  type}
@* @code{-c:  control} deprecated, replacement:
@* @code{-c:  verbose}
@* @code{-e:  errorcheck} allowed, but ignored
@* @code{-B:  bigint} Use GMP for arbitrary precision integers
@* @code{-x=N:  threads} In this case the int parameter is used to set the
                         number of threads N, default 8, 0 means no explicit limiting.

            Further Normaliz options can be added to the nlist by addNmzOption.

SEE ALSO: allNmzOptions,showNmzOptions, addNmzOption, resetNmzOptions
EXAMPLE:  example setNmzOption; shows an example
"
{
    for(int i=1;i<=size(nmz_options);i++)
    {
        if(s==nmz_options[i][1])
        {
            nmz_options[i][2]=onoff;
            return(1);
        }
    }
    "Invalid option ", s;
    return(0);
}
example
{ "EXAMPLE:"; echo=2;
  setNmzOption("only_hvect",1);
  showNmzOptions();
  setNmzOption("only_hvect",0);
  showNmzOptions();
}

proc resetNmzOptions()
"USAGE:   resetNmzOptions();
PURPOSE:  Resets the options to the default value.
SEE ALSO: showNmzOptions, setNmzOption, allNmzOptions, addNmzOption
EXAMPLE:  example resetNmzOptions; shows an example
"
{
  nmz_options = default_options;
}
example
{ "EXAMPLE:"; echo=2;
  setNmzOption("only_hvect",1);
  showNmzOptions();
  resetNmzOptions();
  showNmzOptions();
}

static proc collectNmzOptions()
{
    string run_options=" -f ";
    for(int i=1;i<=size(nmz_options);i++)
    {
        if(nmz_options[i][2])
        {
            run_options=run_options+nmz_options[i][3];
            if (nmz_options[i][1]=="threads") {
                run_options=run_options+string(nmz_options[i][2]);
            }
            run_options=run_options+" ";
        }
    }
    return(run_options+" ");
}

proc addNmzOption(string short_cut, string nmz_option)
"USAGE:   addNmzOption(string short_cut, string nmz_option)
NOTE:     This function allows the addition of Normaliz options
          in addition to the predefined ones. Adding an option does not
          activate it.
    @*    Note: The function prefixes a single letter option by - and
          multiletter options by --.
SEE ALSO: allNmzOptions,showNmzOptions, setNmzOption, resetNmzOptions
EXAMPLE:  example addNmzOption; shows an example
"
{
    if(size(nmz_option) == 1){
        nmz_option = "-" + nmz_option;
    }
    else{
        nmz_option = "--" + nmz_option;
    }
    list new_option = list(short_cut, 0, nmz_option);
    nmz_options = nmz_options + list(new_option);
}
example
{ "EXAMPLE:"; echo=2;
  addNmzOption("FL", "FaceLattice");
  setNmzOption("FL", 1);
  showNmzOptions();
  resetNmzOptions();
}

proc showNmzOptions()
"USAGE:   showNmzOptions();
RETURN:   Returns the string of activated options.
NOTE:     This string is used as parameter when calling Normaliz.
SEE ALSO: setNmzOption
EXAMPLE:  example showNmzOptions; shows an example
"
{
    return(collectNmzOptions());
}
example
{ "EXAMPLE:"; echo=2;
  setNmzOption("hilb",1);
  showNmzOptions();
  setNmzOption("hilb",0);
  showNmzOptions();
}


static proc runNormaliz(list #)
{
    if(!nmz_files_keep_switch)
    {
        makeTempNmzDataPath();
    }

    doWriteNmzData(#);

    if(nmz_files_keep_switch)
    {
       int dummy=system("sh",setNmzExec()+ collectNmzOptions() + getNmzFile());
    }
    else
    {
        string gotodir="/tmp";
        string fname=getNmzFile();
        fname=fname[6..size(fname)];
        string exec="cd "+gotodir+" ; ";
        exec=exec+setNmzExec()+ collectNmzOptions()+" ";
        exec=exec+fname+" ;";
        int dummy=system("sh",exec);
    }

    Num_Invs=getNuminvs();
    int gens_computed = 0;
    for( int i = 1; i <= size(Num_Invs); i = i+1){
        if(Num_Invs[i][1] == "hilbert_basis_elements"){
            gens_computed = 1;
        }
    }

    if(!gens_computed) // return input matrix if "gen" has not been generated
    {
        if(!nmz_files_keep_switch)
        {
            eraseTempNmzDataPath();
        }
        return(#[1]);
    }

    intmat Gen=readNmzData("gen");

    if(!nmz_files_keep_switch)
    {
        eraseTempNmzDataPath();
    }

    return(Gen);

}

proc normaliz(list #)
"USAGE:   normaliz(intmat input_mat,string nmz_type);
          normaliz(intmat input_mat, string nmz_type,  ...);
RETURN:   The function applies Normaliz to the matrix input_mat ofe type nmz_type.
          One can add further pairs "value, type" such as vectors or numerical
          parameters. See Normaliz manual for possible types and values.
          The function returns the intmat defined by the file ith suffix gen, provided it has been computed. Otherwise it returns the input_mat.
NOTE:     You will find procedures for many applications of Normaliz in this
          library, so the explicit call of this procedure may not be necessary.
SEE ALSO: intclToricRing, normalToricRing, ehrhartRing, intclMonIdeal,
          torusInvariants, diagInvariants, finiteDiagInvariants, intersectionValRings,
             intersectionValRingIdeals
EXAMPLE:  example normaliz; shows an example
"
{
    return(runNormaliz(#));
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y,z),dp;
  intmat M[3][2]=3,1,
                 3,2,
                 1,3;
  normaliz(M,"cone");
  intmat Inequalities[2][3] = 2,-1,0, // 2x-y >= 0
                             1, 1,0; //  x+y >= 0
  intmat Equation[1][3] = 0,1,-1;    // y = z
  intmat Congruence[1][4] = 1,0,0,3;  // x = 0 (3)
  normaliz(Inequalities,"inequalities",Equation,"equations",Congruence,"congruences");
}


// retrieving normaliz numerical invariants

static proc getNuminvs()
{
    string s;
    list num_invs;
    int p,sw,v_length,i,dummy_int;
    intvec dummy_vec;
    string type_inv,name_inv,dummy_bool;

    link in_f=":r "+ getNmzFile() + "."+"inv";
    s=read(in_f);

    p=1;
    while(p<size(s))
    {
        (sw,p)=nextWord(s,p);
        if(sw==-1)
        {
            break;
        }
        type_inv=s[sw..p-1];
        if(type_inv=="vector")
        {
            (v_length,p)=getInt(s,p);
            (sw,p)=nextWord(s,p);
            name_inv=s[sw..p-1];
            if(name_inv=="h-vector")
            {
                name_inv="h_vector";
            }
            if(name_inv!="hilbert_polynomial"
              && name_inv!="hilbert_quasipolynomial")
            {
                for(i=1;i<=v_length;i++)
                {
                    if(i==1)
                    {
                        (dummy_int,p)=getInt(s,p);
                        dummy_vec=dummy_int;
                    }
                    else
                    {
                        (dummy_int,p)=getInt(s,p);
                        dummy_vec=dummy_vec,dummy_int;
                    }
                }
                num_invs=num_invs+list(list(name_inv,dummy_vec,"intvec"));
            }
            else
            {
                p=skipEqualsign(s,p);
            }
        }
        if(type_inv=="integer")
        {
            (sw,p)=nextWord(s,p);
            name_inv=s[sw..p-1];
            if (name_inv!="hilbert_quasipolynomial_denom") {
              (dummy_int,p)=getInt(s,p);
              num_invs=num_invs+list(list(name_inv,dummy_int,"int"));
            }
        }
        if(type_inv=="boolean")
        {
            (sw,p)=nextWord(s,p);
            name_inv=s[sw..p-1];
            p=skipEqualsign(s,p);
            (sw,p)=nextWord(s,p);
            dummy_bool=s[sw..p-1];
            dummy_int=0;
            if(dummy_bool=="true")
            {
                dummy_int=1;
            }
            num_invs=num_invs+list(list(name_inv,dummy_int,"int"));
        }
    }
    return(num_invs);
}

proc showNuminvs()
"USAGE:   showNuminvs();
PURPOSE:  prints the numerical invariants
SEE ALSO: exportNuminvs
EXAMPLE:  example showNuminvs(); shows an example
"
{
    list dummy;
    int i;
    for(i=1;i<=size(Num_Invs);i++)
    {
        dummy=Num_Invs[i];
        dummy[1],":", dummy[2];
    }
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y,z,t),dp;
  ideal I=x3,x2y,y3;
  list l=intclMonIdeal(I);
  showNuminvs();
}


proc exportNuminvs()
"USAGE:   exportNuminvs();
CREATE:   Creates top-level variables which contain the numerical invariants.
          Depending on the options of normaliz different invariants are
          calculated. Use showNuminvs (@ref{showNuminvs}) to see which
          invariants are available.
SEE ALSO: showNuminvs
EXAMPLE:  example exportNuminvs; shows an example
"
{
    list dummy;
    int i;
    string s;
    for(i=1;i<=size(Exported_Num_Invs);i++)
    {
        dummy=Exported_Num_Invs[i];
        s="kill  nmz_" + dummy[1];
        execute(s);
    }
    for(i=1;i<=size(Num_Invs);i++)
    {
        dummy=Num_Invs[i];
        s=dummy[3]+" nmz_" + dummy[1] + "=dummy[2]; exportto(Top," + "nmz_" + dummy[1] + ");";
        execute(s);
    }
    Exported_Num_Invs = Num_Invs;
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y,z,t),dp;
  ideal I=x3,x2y,y3;
  list l=intclMonIdeal(I);
  exportNuminvs();
  // for example, now the following variables are set:
  nmz_hilbert_basis_elements;
  nmz_number_extreme_rays;
  nmz_rank;
  nmz_number_support_hyperplanes;
  nmz_multiplicity;
  nmz_primary;
}


// intmats to/from monomials

proc mons2intmat(ideal I)
"USAGE:   mons2intmat(ideal I);
RETURN:   Returns the intmat whose rows represent the leading exponents of the
          (non-zero) elements of I. The length of each row is nvars(basering).
SEE ALSO: intmat2mons
EXAMPLE:  example mons2intmat; shows an example"
{
    int i,j,k;
    intmat expo_vecs[size(I)][nvars(basering)];
    intvec expo_v;

    k=0;
    for(i=1;i<=ncols(I);i++)
    {
        if(I[i]!=0)
        {
            k++;
            expo_v=leadexp(I[i]);
            for(j=1;j<=nvars(basering);j++)
            {
                expo_vecs[k,j]=expo_v[j];
            }
        }
    }
    return(expo_vecs);
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y,z),dp;
  ideal I=x2,y2,x2yz3;
  mons2intmat(I);
}

proc intmat2mons(intmat expo_vecs)
"USAGE:   intmat2mons(intmat M);
RETURN:   an ideal generated by the monomials which correspond to the exponent
          vectors given by the rows of @code{M}
NOTE:     The number of variables in the basering @code{nvars(basering)} has to
          be at least the number of columns @code{ncols(M)}, otherwise the
          function exits with an error.
          is thrown (see @ref{ERROR}).
SEE ALSO: mons2intmat
EXAMPLE:  example intmat2mons; shows an example
"
{
    int i,j;
    poly m;
    ideal mons;

    if(nvars(basering)<ncols(expo_vecs))
    {
        ERROR("intmat2mons: not enough variables in ring");
    }

    for(i=1;i<=nrows(expo_vecs);i++)
    {
        m=1;
        for(j=1;j<=ncols(expo_vecs);j++)
        {
            m=m*var(j)^expo_vecs[i,j];
        }
        mons=mons,m;
    }
     mons=simplify(mons,2);    // get rid of starting 0
     return(mons);
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y,z),dp;
  intmat expo_vecs[3][3] =
  2,0,0,
  0,2,0,
  2,1,3;
  intmat2mons(expo_vecs);
}

static proc intmat2monsSel(intmat expo_vecs, int d)
{
    int i,j;
    poly m;
    ideal mons;

    if(nvars(basering)<ncols(expo_vecs)-1)
    {
        ERROR("intmat2monsSel: not enough variables in ring");
    }

    for(i=1;i<=nrows(expo_vecs);i++)
    {
        if(expo_vecs[i,ncols(expo_vecs)]==d)
        {
            m=1;
            for(j=1;j<=ncols(expo_vecs)-1;j++)
            {
                m=m*var(j)^expo_vecs[i,j];
            }
            mons=mons,m;
        }
    }
    mons=simplify(mons,2);    // get rid of starting 0
    return(mons);
}


proc binomials2intmat(ideal I)
"USAGE:   binomials2intmat(ideal I);
RETURN:   Returns the intmat whose rows represent the exponents of the
          (non-zero) elements of I which have to be binomials.
          The length of each row is nvars(basering).
SEE ALSO: intmat2binomials, mons2intmat, intmat2mons
EXAMPLE:  example binomials2intmat; shows an example"
{
    int i,j,k;
    intmat expo_vecs[size(I)][nvars(basering)];
    intvec expo_v;

    k=0;
    poly f;

    for(i=1; i<=ncols(I); i++)
    {
        if( I[i] != 0 )
        {
            k++;
            f = I[i];
            if (leadcoef(f) != 1) {f = -f;}  //works in all characteristics
            if (size(f)!=2 || leadcoef(f)!=1 || leadcoef(f[2])!=-1)
            {
                ERROR(string("normalToricRing: binomial ideal expected: generator ",i,": ",I[i]));
            }

            expo_v = leadexp(f)-leadexp(f[2]);
            for(j=1;j<=nvars(basering);j++)
            {
                expo_vecs[k,j]=expo_v[j];
            }
        }
    }
    return(expo_vecs);
}
example
{ "EXAMPLE:"; echo=2;
  ring S = 37,(u,v,w,x,y,z),dp;
  ideal I = u2v-xyz, ux2-vyz, uvw-y2z;
  binomials2intmat(I);
}

proc intmat2binomials(intmat expo_vecs)
"USAGE:   intmat2binomials(intmat M);
RETURN:   an ideal generated by the binomials which correspond to the exponent
          vectors given by the rows of @code{M}
NOTE:     The number of variables in the basering @code{nvars(basering)} has to
          be at least the number of columns @code{ncols(M)}, otherwise the
          function exits with an error is thrown (see @ref{ERROR}).
          The vector with all entries zero represents 1.
SEE ALSO: binomials2intmat
EXAMPLE:  example intmat2binomials; shows an example"
{
    int i,j;
    poly f,g;
    ideal binoms;
    // expo_vecs;

    if(nvars(basering)<ncols(expo_vecs))
    {
        ERROR("intmat2binomilals: not enough variables in ring");
    }

    for(i=1;i<=nrows(expo_vecs);i++)
    {
        f=1;
        g=1;
        for(j=1;j<=ncols(expo_vecs);j++)
        {
            if(expo_vecs[i,j]>0)
            {
                f=f*var(j)^expo_vecs[i,j];
            }
            if(expo_vecs[i,j]<0)
            {
                g=g*var(j)^(-expo_vecs[i,j]);
            }
        }
        binoms=binoms,f-g;
    }
    binoms = simplify(binoms,2);  // get rid of starting 0
    return(binoms);
}
example
{ "EXAMPLE:"; echo=2;
  ring S = 37,(u,v,w,x,y,z),dp;
  intmat M[2][6] = 1,0,1,-1,-2,0,  -3,4,5,0,0,1;
  intmat2binomials(M);
}

// integral closure of rings and ideals

static proc runIntclToricRing(ideal I, string nmz_type, list #)
{
    intmat expo_vecs=mons2intmat(I);
    return( intmat2mons( runNormaliz(expo_vecs,nmz_type, prepareGrading(#)) ) );
}

proc intclToricRing(ideal I, list #)
"USAGE:   intclToricRing(ideal I);
          intclToricRing(ideal I, intvec grading);
RETURN:   The toric ring S is the subalgebra of the basering generated by
          the leading monomials of the elements of I (considered as a list
          of polynomials). The function computes the integral
          closure T of S in the basering and returns an ideal listing
          the algebra generators of T over the coefficient field.
@*        The function returns the input ideal I if an option
          blocking the computation of Hilbert bases has been activated.
          However, in this case some numerical invariants are computed, and
          some other data may be contained in files that you can read into
          Singular (see @ref{showNuminvs}, @ref{exportNuminvs}).
NOTE:     A mathematical remark: the toric ring depends on the list of
          monomials given, and not only on the ideal they generate!
SEE ALSO:  normalToricRing, ehrhartRing, intclMonIdeal
EXAMPLE:   example intclToricRing; shows an example
"
{
    return(runIntclToricRing(I,"cone",#));
}
example
{ "EXAMPLE:"; echo=2;
  ring R=37,(x,y,t),dp;
  ideal I=x3,x2y,y3;
  intclToricRing(I);
  showNuminvs();
  //now the same example with another grading
  intvec grading = 2,3,1;
  intclToricRing(I,grading);
  showNuminvs();

}

proc normalToricRing(ideal I, list #)
"USAGE:   normalToricRing(ideal I);
          normalToricRing(ideal I, intvec grading);
RETURN:   The toric ring S is the subalgebra of the basering generated by the
          leading monomials of the elements of I (considered as a list of
          polynomials). The function computes the
          normalisation T of S and returns an ideal listing the algebra
          generators of T over the coefficient field.
@*        The function returns the input ideal I if one of the options
          blocking the computation of Hilbert bases has been activated.
          However, in this case some numerical invariants are computed, and
          some other data may be contained in files that you can read into
          Singular (see @ref{showNuminvs}, @ref{exportNuminvs}).
NOTE:     A mathematical remark: the toric ring depends on the list of
          monomials given, and not only on the ideal they generate!
SEE ALSO: toricRingFromBinomials, intclToricRing, ehrhartRing, intclMonIdeal, normalToricRingFromBinomials
EXAMPLE:  example normalToricRing; shows an example
"
{
    return(runIntclToricRing(I,"cone_and_lattice",#));
}
example
{ "EXAMPLE:"; echo=2;
  ring  R = 37,(x,y,t),dp;
  ideal I = x3,x2y,y3;
  normalToricRing(I);
}

proc hilbertSeriesToricRing(ideal I, list #)
"USAGE:   hilbertSeriesToricRing(ideal I);
          hilbertSeriesToricRing(ideal I, intvec grading);
RETURN:   The toric ring is the subalgebra of the ring generated by the
          leading monomials of the elements of I (considered as a list of
          polynomials). The function computes the Hilbert series of the toric
          ring with respect to the grading. It assumes the standard grading on
          the ambient polynomial ring is none is given explicitly.
          The grading is normalized, i.e. diided by the gcd of the degrees of the
          generators.
          The return value is the pair of numerator polynomial encoded as an
          intvec and the denomionator, also encoded as an intvec, whose components
          e stand nfor the factors (1-t^e) of the denominator,
NOTE:     A mathematical remark: the toric ring depends on the list of
          monomials given, and not only on the ideal they generate!
SEE ALSO: toricRingFromBinomials, normalToricRing, intclToricRing
"
EXAMPLE:  example hilbertSeriesToricRing; shows an example
{
    intmat U = mons2intmat(I);
    int swallow = setNmzOption("only_hvect",1);
    intmat Dummy = runNormaliz(U,"monoid", prepareGrading(#));
    swallow = setNmzOption("only_hvect",0);
    exportNuminvs();
    return(nmz_hilbert_series_num,nmz_hilbert_series_denom);
}
example
{ "EXAMPLE:"; echo=2;
  ring  R = 37,(x,y),dp;
  ideal I = x3, x2y,y3;
  intvec hilb_num, hilb_denom;
  (hilb_num, hilb_denom) = hilbertSeriesToricRing(I);
  "num", hilb_num, " denom",hilb_denom;
}

proc normalToricRingFromBinomials(ideal I, list #)
"USAGE:   normalToricRingFromBinomials(ideal I);
          normalToricRingFromBinomials(ideal I, intvec grading);
RETURN:   @texinfo
@tex
The ideal $I$ is generated by binomials of type $X^a-X^b$ (multiindex notation)
in the surrounding polynomial ring $K[X]=K[X_1,...,X_n]$. The binomials
represent a congruence on the monoid ${Z}^n$ with residue monoid $M$.
Let $N$ be the image of $M$ in gp($M$)/torsion. Then $N$ is universal in the
sense that every homomorphism from $M$ to an affine monoid factors through $N$.
If $I$ is a prime ideal, then $K[N]= K[X]/I$. In general, $K[N]=K[X]/P$ where
$P$ is the unique minimal prime ideal of $I$ generated by binomials of type
$X^a-X^b$.

The function computes the normalization of $K[N]$ and returns a newly created
polynomial ring of the same Krull dimension, whose variables are
$x(1),...,x(n-r)$, where $r$ is the rank of the matrix with rows $a-b$.
(In general there is no canonical choice for such an embedding.)
Inside this polynomial ring there is an ideal $I$ which lists the algebra
generators of the normalization of $K[N]$.
@end tex
@end texinfo
@*        The function returns the input ideal I if an option blocking
          the computation of Hilbert bases has been activated.
          However, in this case some numerical invariants are computed, and
          some other data may be contained in files that you can read into
          Singular (see @ref{showNuminvs}, @ref{exportNuminvs}).
SEE ALSO: intclToricRing, normalToricRing, ehrhartRing, intclMonIdeal
EXAMPLE:  example normalToricRing; shows an example
"
{
    intmat expo_vecs = binomials2intmat(I);
    intmat result = runNormaliz(expo_vecs,"normal_toric_ideal",prepareGrading(#));

    list baseringlist = ringlist(basering);
    ring S = (baseringlist[1]),(x(1..ncols(result))),dp;
    ideal I = intmat2mons(result);
    export(I);
    return (S);
}
example
{ "EXAMPLE:"; echo=2;
  ring R = 37,(u,v,w,x,y,z),dp;
  ideal I = u2v-xyz, ux2-wyz, uvw-y2z;
  def S = normalToricRingFromBinomials(I);
  setring S;
  I;
}

proc toricRingFromBinomials(ideal I, list #)
"USAGE:   toricRingFromBinomials(ideal I);
          toricRingFromBinomials(ideal I, intvec grading);
RETURN:   @texinfo
@tex
The ideal $I$ is generated by binomials of type $X^a-X^b$ (multiindex notation)
in the surrounding polynomial ring $K[X]=K[X_1,...,X_n]$. The binomials
represent a congruence on the monoid ${Z}^n$ with residue monoid $M$.
Let $N$ be the image of $M$ in gp($M$)/torsion. Then $N$ is universal in the
sense that every homomorphism from $M$ to an affine monoid factors through $N$.
If $I$ is a prime ideal, then $K[N]= K[X]/I$. In general, $K[N]=K[X]/P$ where
$P$ is the unique minimal prime ideal of $I$ generated by binomials of type
$X^a-X^b$.

The function computes $K[N]$ and returns a newly created
polynomial ring of the same Krull dimension, whose variables are
$x(1),...,x(n-r)$, where $r$ is the rank of the matrix with rows $a-b$.
(In general there is no canonical choice for such an embedding.)
@end tex
@end texinfo
@*        The function returns the input ideal I if an option blocking
          the computation of Hilbert bases has been activated.
          However, in this case some numerical invariants are computed, and
          some other data may be contained in files that you can read into
          Singular (see @ref{showNuminvs}, @ref{exportNuminvs}).
SEE ALSO: toricRingFromBinomials, normalToricRingFromBinomials
EXAMPLE:  example normalToricRing; shows an example"
{
    intmat expo_vecs = binomials2intmat(I);
    intmat result = runNormaliz(expo_vecs,"toric_ideal",prepareGrading(#));

    list baseringlist = ringlist(basering);
    ring S = (baseringlist[1]),(x(1..ncols(result))),dp;
    ideal I = intmat2mons(result);
    export(I);
    return (S);
}
example
{ "EXAMPLE:"; echo=2;
  ring R = 37,(u,v,w,x,y,z),dp;
  ideal I = u2v-xyz, ux2-wyz, uvw-y2z;
  def S = toricRingFromBinomials(I);
  setring S;
  I;
}

proc definingBinomialIdeal(ideal I)
"USAGE:   definingBinomialIdeal(ideal I);
RETURN:   The toric ring S is the subalgebra of the basering generated by the
          leading monomials of the elements of I (considered as a list of
          polynomials). The function computes the defining binomial
          ideal J of S with respect to the generators and returns it, together with
          J. D See example.
NOTE:     A mathematical remark: the toric ring depends on the list of
          monomials given, and not only on the ideal they generate!
          This function requires the previous setting of an NmzFilename.
          The function does not delete the written files.
SEE ALSO: normalToricRingFromBinomials
EXAMPLE:  example definingBinomialIdeal; shows an example"
{
    if(!nmz_files_keep_switch){
        ERROR("definingBinomialIdeal requires a filename");
    }
    setNmzOption("markov",1);
    intmat Dummy = normaliz(mons2intmat(I), "monoid");
    setNmzOption("markov",0);
    intmat bin = readNmzData("mrk");
    list baseringlist = ringlist(basering);
    ring S = (baseringlist[1]),(x(1..ncols(bin))),dp;
    ideal J = intmat2binomials(bin);
    export(J);
    return(S);
}
example
{ "EXAMPLE:"; echo=2;
    ring R = 37,(x,y,z,w),dp;
    ideal I = x4,x3y,x2y2,xy3,y4;
    setNmzFilename("binomials");
    def S = definingBinomialIdeal(I);
    setring S;
    J;
}


proc latticeIdeal(ideal I)
"USAGE:   latticeIdeal(ideal I);
RETURN:   Returns the lattice ideal defined by the elements of I
          which have to be binomials. The lattice ideal is
          the restriction to the polynomial ring of the ideal of
          the Laurent polynomial ring generated by I
NOTE:     This function requires the previous setting of an NmzFilename.
          The function does not delete the written files.
SEE ALSO: intmat2binomials
EXAMPLE:  example latticeIdeal; shows an example
"
{
    if(!nmz_files_keep_switch){
        ERROR("latticeIdeal requires a filename");
    }
    intmat B = binomials2intmat(I);
    setNmzOption("markov",1);
    intmat Dummy = normaliz(B, "lattice_ideal");
    setNmzOption("markov",0);
    intmat bin = readNmzData("mrk");
    return(intmat2binomials(bin));
}
example
{ "EXAMPLE:"; echo=2;
  setNmzFilename("binomials");
  ring S = 37,(u,v,w,x,y,z),dp;
  ideal I = u2-v2, x2-y2, y2-vw, z2-xy;
  latticeIdeal(I);
}

proc groebnerBasis(ideal I)
"USAGE:   groebnerBasis(ideal I);
RETURN:   Returns a Gr\"obner basis of the lattice ideal defined by the
          elements of I  which have to be binomials. The lattice ideal is
          the restriction to the polynomial ring of the ideal of
          the Laurent polynomial ring generated by I. The default monomial
          order is DegRevLex where Deg is the total degree on the ambient
          polynomial ring. Lex and DegLex orders can be chosen via options.
NOTE:     This function requires the previous setting of an NmzFilename.
          The function does not delete the written files.
SEE ALSO: latticeIdeal
EXAMPLE:  example groebnerBasis; shows an example"
{

    if(!nmz_files_keep_switch){
        ERROR("groebnerBasis requires a filename");
    }
    intmat B = binomials2intmat(I);
    int swallow = setNmzOption("groebner",1);
    intmat Dummy = normaliz(B, "lattice_ideal");
    swallow = setNmzOption("groebner",0);
    intmat bin = readNmzData("grb");
    return(intmat2binomials(bin));
}
example
{ "EXAMPLE:"; echo=2;
  setNmzFilename("binomials");
  ring S = 37,(u,v,w,x,y,z),dp;
  ideal I = u2-v2, x2-y2, y2-vw, z2-xy;
  groebnerBasis(I);
  setNmzOption("lex",1);
  groebnerBasis(I);
  setNmzOption("lex",0);
}

static proc runIntclMonIdeal(ideal I, string nmz_type, list #)
{
    intmat expo_vecs=mons2intmat(I);
    int i,last_comp;

    // we test if there is room for the Rees algebra

    for(i=1;i<=nrows(expo_vecs);i++)
    {
        if(expo_vecs[i,ncols(expo_vecs)]!=0)
        {
            last_comp=1;  break; // no
        }
    }

    //adjust size of input matrix
    if (!last_comp) { // remove last component
        intmat tmp[nrows(expo_vecs)][ncols(expo_vecs)-1]
               = expo_vecs[1..nrows(expo_vecs),1..(ncols(expo_vecs)-1)];
        expo_vecs = tmp;
    }
    intmat nmz_data=runNormaliz(expo_vecs,nmz_type,prepareGrading(#));

    if(last_comp)
    {
        ideal I1=intmat2monsSel(nmz_data,1);
        return(list(I1));
    }
    else
    {
        ideal I1=intmat2monsSel(nmz_data,1);
        ideal I2=intmat2mons(nmz_data);
        return(list(I1,I2));
    }
}

proc ehrhartRing(ideal I)
"USAGE:    ehrhartRing(ideal I);
RETURN:    The exponent vectors of the leading monomials of the elements of I
           are considered as points of a lattice polytope P.
           The Ehrhart ring of a (lattice) polytope P is the monoid algebra
           defined by the monoid of lattice points in the cone over the
           polytope P; see Bruns and Gubeladze, Polytopes, Rings, and K-theory,
           Springer 2009, pp. 228, 229.
           The function returns a list of ideals:
@*         (i) If the last ring variable is not used by the monomials, it is
               treated as the auxiliary variable of the Ehrhart ring. The
               function returns two ideals, the first containing the monomials
               representing all the lattice points of the polytope, the second
               containing the algebra generators of the Ehrhart ring over the
               coefficient field.
@*         (ii) If the last ring variable is used by the monomials, the list
                returned contains only one ideal, namely the monomials
                representing the lattice points of the polytope.
@*
@*        The function returns the a list containing the input ideal I if
          an option blocking the computation of the Hilbert basis has been activated.
          However, in this case some numerical invariants are computed, and
          some other data may be contained in files that you can read into
          Singular (see @ref{showNuminvs}, @ref{exportNuminvs}).
NOTE:      A mathematical remark: the Ehrhart ring depends on the list of
           monomials given, and not only on the ideal they generate!
SEE ALSO: intclToricRing, normalToricRing, intclMonIdeal
EXAMPLE:  example ehrhartRing; shows an example
"
{
    return(runIntclMonIdeal(I,"polytope"));
}
example
{ "EXAMPLE:"; echo=2;
  ring R=37,(x,y,t),dp;
  ideal J=x3,x2y,y3,xy2t7;
  ehrhartRing(J);
}

proc intclMonIdeal(ideal I, list #)
"USAGE:   intclMonIdeal(ideal I);
          intclMonIdeal(ideal I, intvec grading);
RETURN:   The exponent vectors of the leading monomials of the elements of I
          are considered as generators of a monomial ideal for which the
          normalization of its Rees algebra is computed. For a Definition of the
          Rees algebra (or Rees ring) see Bruns and Herzog, Cohen-Macaulay
          rings, Cambridge University Press 1998, p. 182.
          The function returns a list of ideals:
@* (i) If the last ring variable is not used by the monomials, it is treated
       as the auxiliary variable of the Rees algebra. The function returns two
       ideals, the first containing the monomials generating the integral
       closure of the monomial ideal, the second containing the algebra
         generators of the normalization of the Rees algebra.
@* (ii) If the last ring variable is used by the monomials, the list returned
        contains only one ideal, namely the monomials generating the integral
        closure of the ideal.
@*        The function returns the a list containing the input ideal I if an option
          blocking the computation of Hilbert bases has been activated.
          However, in this case some numerical invariants are computed, and
          some other data may be contained in files that you can read into
          Singular (see @ref{showNuminvs}, @ref{exportNuminvs}).
SEE ALSO: intclToricRing, normalToricRing, ehrhartRing
EXAMPLE:  example intclMonIdeal; shows an example
"
{
    return(runIntclMonIdeal(I,"rees_algebra",#));
}
example
{ "EXAMPLE:"; echo=2;
    ring R=0,(x,y,z,t),dp;
    ideal I=x^2,y^2,z^3;
    list l=intclMonIdeal(I);
    l[1]; // integral closure of I
    l[2];  // monomials generating the integral closure of the Rees algebra
}

// torus invariants and valuation rings and ideals

proc torusInvariants(intmat E, list #)
"USAGE:   torusInvariants(intmat A);
          torusInvariants(intmat A, intvec grading);
RETURN:   @texinfo
Returns an ideal representing the list of monomials generating the ring of
invariants as an algebra over the coefficient field.
@tex
$R^T$.
@end tex
@*        The function returns the ideal given by the input matrix A if one of
          the options @code{supp}, @code{triang}, @code{volume}, or
          @code{hseries} has been activated.
          However, in this case some numerical invariants are computed, and
          some other data may be contained in files that you can read into
          Singular (see @ref{showNuminvs}, @ref{exportNuminvs}).
@end texinfo
BACKGROUND: @texinfo
@tex
 Let $T = (K^*)^r$ be the $r$-dimensional torus acting on the polynomial ring
 $R = K[X_1 ,\ldots,X_n]$ diagonally. Such an action can be described as
 follows: there are integers $a_{i,j}$, $i=1,\ldots,r$, $j=1,\ldots,n$, such
 that $(\lambda_1,\ldots,\lambda_r)\in T$ acts by the substitution
$$ X_j \mapsto \lambda_1^{a_{1,j}} \cdots \lambda_r^{a_{r,j}}X_j,
   \quad j=1,\ldots,n.$$
In order to compute the ring of invariants $R^T$ one must specify the matrix
$A=(a_{i,j})$.
@end tex
@end texinfo
SEE ALSO: diagInvariants, finiteDiagInvariants, intersectionValRings,
          intersectionValRingIdeals
EXAMPLE:  example torusInvariants; shows an example
"
{
    if(nvars(basering)!=ncols(E))
    {
        ERROR("torusInvariants: wrong number of columns in matrix");
    }
    return( intmat2mons( runNormaliz(E,"equations",prepareGrading(#)) ) );
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y,z,w),dp;
  intmat E[2][4] = -1,-1,2,0, 1,1,-2,-1;
  torusInvariants(E);
}

proc finiteDiagInvariants(intmat C, list #)
"USAGE:   finiteDiagInvariants(intmat U);
          finiteDiagInvariants(intmat U, intvec grading);
RETURN:   @texinfo
@tex
This function computes the ring of invariants of a finite abelian group $G$
acting diagonally on the surrounding polynomial ring $K[X_1,...,X_n]$. The
group is the direct product of cyclic groups generated by finitely many
elements $g_1,...,g_w$. The element $g_i$ acts on the indeterminate $X_j$ by
$g_i(X_j)=\lambda_i^{u_{ij}}X_j$ where $\lambda_i$ is a primitive root of
unity of order equal to $ord(g_i)$. The ring of invariants is generated by all
monomials satisfying the system
$u_{i1}a_1+\ldots+u_{in} a_n \equiv 0$ mod ord$(g_i)$, $i=1,\ldots,w$.
The input to the function is the $w\times(n+1)$ matrix $U$ with rows
$u_{i1}\ldots u_{in}$ ord$(gi)$, $i=1,\ldots,w$. The output is a monomial ideal
listing the algebra generators of the subalgebra of invariants
{$R^G=\{f\in R : g_i f = f$ for all $i=1,\ldots,w\}$}.
@end tex
@end texinfo
@*        The function returns the ideal given by the input matrix C if one of
          the options @code{supp}, @code{triang}, @code{volume}, or
          @code{hseries} has been activated.
          However, in this case some numerical invariants are computed, and
          some other data may be contained in files that you can read into
          Singular (see @ref{showNuminvs}, @ref{exportNuminvs}).
NOTE:
SEE ALSO: torusInvariants, diagInvariants, intersectionValRings,
          intersectionValRingIdeals
EXAMPLE:  example finiteDiagInvariants; shows an example
"
{
    if(nvars(basering)!=ncols(C)-1)
    {
        ERROR("finiteDiagInvariants: wrong number of columns in matrix");
    }
    return( intmat2mons( runNormaliz(C,"congruences",prepareGrading(#)) ) );
}
example
{ "EXAMPLE:"; echo=2;
  ring R = 0,(x,y,z,w),dp;
  intmat C[2][5] = 1,1,1,1,5, 1,0,2,0,7;
  finiteDiagInvariants(C);
}

proc diagInvariants(intmat E, intmat C, list #)
"USAGE:   diagInvariants(intmat A, intmat U);
          diagInvariants(intmat A, intmat U, intvec grading);
RETURN:   @texinfo
@tex
This function computes the ring of invariants of a diagonalizable group
$D = T\times G$ where $T$ is a torus and $G$ is a finite abelian group, both
acting diagonally on the polynomial ring $K[X_1,\ldots,X_n]$. The group
actions are specified by the input matrices A and U. The first matrix specifies
the torus action, the second the action of the finite group. See
torusInvariants and finiteDiagInvariants for more detail. The output is a
monomial ideal listing the algebra generators of the subalgebra of invariants.
@end tex
@end texinfo
@*        The function returns the ideal given by the input matrix A if one of
          the options @code{supp}, @code{triang}, @code{volume}, or
          @code{hseries} has been activated.
          However, in this case some numerical invariants are computed, and
          some other data may be contained in files that you can read into
          Singular (see @ref{showNuminvs}, @ref{exportNuminvs}).
SEE ALSO: torusInvariants, finiteDiagInvariants, intersectionValRings, intersectionValRingIdeals
EXAMPLE:  example diagInvariants; shows an example
"
{
    if(nvars(basering)!=ncols(E) || nvars(basering)!=ncols(C)-1)
    {
        ERROR("diagInvariants: wrong number of columns in matrix");
    }
    return( intmat2mons( runNormaliz(E,"equations",C,"congruences",prepareGrading(#)) ) );
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y,z,w),dp;
  intmat E[2][4] = -1,-1,2,0, 1,1,-2,-1;
  intmat C[2][5] = 1,1,1,1,5, 1,0,2,0,7;
  diagInvariants(E,C);
}

proc intersectionValRings(intmat V, list #)
"USAGE:   intersectionValRings(intmat V, intvec grading);
RETURN:   The function returns a monomial ideal, to be considered as the list
          of monomials generating @math{S} as an algebra over the coefficient
          field.
BACKGROUND: @texinfo
@tex
A discrete monomial valuation $v$ on $R = K[X_1 ,\ldots,X_n]$ is determined by
the values $v(X_j)$ of the indeterminates. This function computes the
subalgebra $S = \{ f \in R : v_i ( f ) \geq 0,\ i = 1,\ldots,r\}$ for several
such valuations $v_i$, $i=1,\ldots,r$. It needs the matrix $V = (v_i(X_j))$ as
its input.
@end tex
@end texinfo
@*        The function returns the ideal given by the input matrix V if one of
          the options @code{supp}, @code{triang}, @code{volume}, or
          @code{hseries} has been activated.
          However, in this case some numerical invariants are computed, and
          some other data may be contained in files that you can read into
          Singular (see @ref{showNuminvs}, @ref{exportNuminvs}).
SEE ALSO: torusInvariants, diagInvariants, finiteDiagInvariants, intersectionValRingIdeals
EXAMPLE:  example intersectionValRings; shows an example
"
{

    if(nvars(basering)!=ncols(V))
    {
        ERROR("intersectionValRings: wrong number of columns in matrix");
    }

    intmat V1[nrows(V)+ncols(V)][ncols(V)];
    int i,j;

    for(i=1;i<=ncols(V);i++)
    {
        V1[i,i]=1;
    }
    for(i=1;i<=nrows(V);i++)
    {
        for(j=1;j<=ncols(V);j++)
        {
            V1[i+ncols(V),j]=V[i,j];
        }
    }

/*    if(!GenGen) // return V
    {
        runNormaliz(V1,4,prepareGrading(#));
        return(V);
    }
*/
    return(intmat2mons(runNormaliz(V1,"inequalities",prepareGrading(#))));
}
example
{ "EXAMPLE:"; echo=2;
  ring R=0,(x,y,z,w),dp;
  intmat V0[2][4]=0,1,2,3, -1,1,2,1;
  intersectionValRings(V0);
}

proc intersectionValRingIdeals(intmat V, list #)
"USAGE:   intersectionValRingIdeals(intmat V);
          intersectionValRingIdeals(intmat V, intvec grading);
RETURN:   The function returns two ideals, both to be considered as lists of
          monomials. The
          first is the system of monomial generators of @math{S}, the second
          the system of generators of @math{M}.
@*        The function returns a list consisting of the ideal given by the
          blocking the computation of Hilbert bases has been activated.
          However, in this case some numerical invariants are computed, and
          some other data may be contained in files that you can read into
          Singular (see @ref{showNuminvs}, @ref{exportNuminvs}).
BACKGROUND: @texinfo
@tex
A discrete monomial valuation $v$ on $R = K[X_1 ,\ldots,X_n]$ is determined by
the values $v(X_j)$ of the indeterminates. This function computes the
subalgebra $S = \{ f \in R : v_i ( f ) \geq 0,\ i = 1,\ldots,r\}$ for several
such valuations $v_i$, $i=1,\ldots,r$. It needs the matrix $V = (v_i(X_j))$ as
its input.

This function simultaneously determines the $S$-submodule
$M = \{ f \in R : v_i(f) \geq w_i ,\ i = 1,\ldots,r\}$ for integers
$w_1,\ldots\,w_r$. (If $w_i \geq 0$ for all $i$, $M$ is an ideal of $S$.)
The numbers $w_i$ form the $(n+1)$th column of the input matrix.
@end tex
@end texinfo
NOTE:   The function also gives an error message if the matrix V has the
        wrong number of columns.
SEE ALSO: torusInvariants, diagInvariants, finiteDiagInvariants, intersectionValRings
EXAMPLE:  example intersectionValRingIdeals; shows an example
"
{
    if(nvars(basering)!=ncols(V)-1)
    {
        ERROR("intersectionValRingIdeals: wrong number of columns in matrix");
    }

    intmat V1[nrows(V)+ncols(V)][ncols(V)];
    int i,j;

    for(i=1;i<=ncols(V);i++)
    {
        V1[i,i]=1;
    }
    for(i=1;i<=nrows(V);i++)
    {
        for(j=1;j<=ncols(V);j++)
        {
            V1[i+ncols(V),j]=V[i,j];
        }
    }
    for(i=1;i<=nrows(V);i++)
    {
        V1[i+ncols(V),ncols(V)]=-V1[i+ncols(V),ncols(V)];
    }

    intmat nmz_data=runNormaliz(V1,"inequalities",prepareGrading(#));
    ideal I1=intmat2monsSel(nmz_data,0);
    ideal I2=intmat2monsSel(nmz_data,1);
    return(list(I1,I2));
}
example
{ "EXAMPLE:"; echo=2;
 ring R=0,(x,y,z,w),dp;
 intmat V[2][5]=0,1,2,3,4, -1,1,2,1,3;
 intersectionValRingIdeals(V);
}

proc allNmzOptions()
"USAGE:   proc alNmzOptions();
PURPOSE:  The function prints a list of the Normaliz options that
          are available in this library: the string naming the option,
          the default value, and the option sent to Normaliz.
SEE ALSO: setNmzOption, showNmzOptions
EXAMPLE:  example allNmzOptions; shows an example
"
{
    for(int i=1;i<=size(nmz_options);i++){
        if(size(nmz_options[i]) == 3){
            nmz_options[i][1], nmz_options[i][2], nmz_options[i][3];
        }
        else{
            nmz_options[i][1], nmz_options[i][2], nmz_options[i][3], nmz_options[i][4] ;
        }
    }
    " ";
}
example
{ "EXAMPLE:"; echo=2;
    allNmzOptions();
}

static proc mod_init()
{
  string nmz_exec_path; export nmz_exec_path;
  string nmz_filename; export nmz_filename;
  int nmz_files_keep_switch;export nmz_files_keep_switch;
  string nmz_data_path; export nmz_data_path;
  // int GenGen=1; export GenGen; // indicates whether "gen" is generated // no longer used
  list Num_Invs; export Num_Invs;
  list Exported_Num_Invs; export Exported_Num_Invs;
// running normaliz (with options)

// component 1 is name of option
// 2 is default value
// 3 is command line option to be passed to Normaliz
// 4 indicates whether file "gen" is generated
// value 2 of 4 indicates "no influence"

  list nmz_options=
        list("supp",0,"-s"),
        list("triang",0,"-T"),
        list("volume",0,"-v"),
        list("hvect",0,"-p"," -- name deprecated, use hvect_deg1"),
        list("hvect_deg1",0, "-p"),
        list("only_hvect",0,"-q"),
        list("fvect",0,"--FVector"),
        list("height1",0,"-1"),
        list("Gorenst",0,"-G"),
        list("intclosed",0,"--IsIntegrallyClosed"),
        list("witness",0,"--w"),
        list("classgroup",0,"-C"),
        list("normal",0,"-n"," -- name deprecated, use hilbbasvol"),
        list("hilbbasvol",0,"-n"),
        list("normal_l",0,"-N"," -- name deprecated, use hilbbas"),
        list("hilbbas",0,"-N"),
        list("hilb",0,"-h"," -- name deprecated, use hilbbas_hvect"),
        list("hilbbas_hvect",0,"-h"),
        list("dual",0,"-d"),
        list("markov", 0, "--MarkovBasis --BinomialsPacked"),
        list("groebner", 0, "--GroebnerBasis --BinomialsPacked"),
        list("lex", 0, "--Lex"),
        list("revlex", 0, "--RevLex"),
        list("lex", 0, "--Lex"),
        list("deglex", 0, "--DegLex"),
        list("genoverori",0,"-M --mod"),
        list("type",0,"--typ"),
        list("control",0,"-c"," -- name deprecated, use verbose"),
        list("verbose",0,"-c"),
        list("allf",0,"-a"),
        list("bigint",0,"-B"),
        list("threads",8,"-x="),
        list("errorcheck",0,"-e", " -- allowed, but ignored by Normaliz");
    export nmz_options;
    list default_options = nmz_options;
    export default_options;
}

