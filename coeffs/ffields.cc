/****************************************
*  Computer Algebra System SINGULAR     *
****************************************/
/* $Id$ */
/*
* ABSTRACT: finite fields with a none-prime number of elements (via tables)
*/

#include <string.h>
#include <kernel/mod2.h>
#include <omalloc/mylimits.h>
#include <kernel/febase.h>
#include <omalloc/omalloc.h>
#include <kernel/numbers.h>
#include <kernel/ring.h>
#include <kernel/ffields.h>

int nfCharQ=0;  /* the number of elemts: q*/
int nfM1;       /*representation of -1*/
int nfCharP=0;  /* the characteristic: p*/
static int nfCharQ1=0; /* q-1 */
unsigned short *nfPlus1Table=NULL; /* the table i=log(z^i) -> log(z^i+1) */
/* the q's from the table 'fftable' */
unsigned short fftable[]={
    4,  8, 16, 32, 64, 128, 256, 512,1024,2048,4096,8192,16384, 32768,
/*2^2 2^3 2^4 2^5 2^6  2^7  2^8  2^9 2^10 2^11 2^12 2^13  2^14  2^15*/
    9, 27, 81,243,729,2187, 6561,19683,59049,
/*3^2 3^3 3^4 3^5 3^6  3^7  3^8   3^9  3^10*/
   25,125,625,3125,15625,
/*5^2 5^3 5^4 5^5  5^6*/
   49,343,2401,16807,
/*7^2 7^3  7^4 7^5*/
   121,1331, 14641,
/*11^2 11^3  11^4*/
  169, 2197, 28561,
/*13^2 13^3  13^4*/
  289, 4913,
/*17^2 17^3*/
  361, 6859,
/*19^2 19^3*/
  529, 12167,
/*23^2 23^3*/
  841, 24389,
/*29^2 29^3*/
  961, 29791,
/*31^2 31^3*/
  1369, 50653,
/*37^2  37^3*/
  1681, /*41^2*/
  1849, /*43^2*/
  2209, /*47^2*/
  2809, /*53^2*/
  3481, /*59^2*/
  3721, /*61^2*/
  4489, /*67^2*/
  5041, /*71^2*/
  5329, /*73^2*/
  6241, /*79^2*/
  6889, /*83^2*/
  7921, /*89^2*/
  9409, /*97^2*/
  10201, /*101^2*/
  10609, /*103^2*/
  11449, /*107^2*/
  11881, /*109^2*/
  12769, /*113^2*/
  16129, /*127^2*/
  17161, /*131^2*/
  18769, /*137^2*/
  19321, /*139^2*/
  22201, /*149^2*/
  22801, /*151^2*/
  24649, /*157^2*/
  26569, /*163^2*/
  27889, /*167^2*/
  29929, /*173^2*/
  32041, /*179^2*/
  32761, /*181^2*/
  36481, /*191^2*/
  37249, /*193^2*/
  38809, /*197^2*/
  39601, /*199^2*/
  49729, /*223^2*/
  44521, /*211^2*/
  51529, /*227^2*/
  52441, /*229^2*/
  54289, /*233^2*/
  57121, /*239^2*/
  58081, /*241^2*/
  63001, /*251^2*/
  0 };

/*1
* numbers in GF(p^n):
* let nfCharQ=q=nfCharP^n=p^n
* GF(q)\{0} will be generated by powers of an element Z
* Z^i will be represented by the int i, 1 by the int 0, 0 by the int q=nfChar
*/

#ifdef LDEBUG
/*2
* debugging: is a a valid representation of a number ?
*/
BOOLEAN nfDBTest (number a, const char *f, const int l)
{
  if (((long)a<0L) || ((long)a>(long)nfCharQ))
  {
    Print("wrong %d in %s:%d\n",(int)((long)a),f,l);
    return FALSE;
  }
  int i=0;
  do
  {
    if (nfPlus1Table[i]>nfCharQ)
    {
      Print("wrong table %d=%d in %s:%d\n",i,nfPlus1Table[i],f,l);
      return FALSE;
    }
    i++;
  } while (i<nfCharQ);
  return TRUE;
}
#define nfTest(N) nfDBTest(N,__FILE__,__LINE__)
#endif

/*2
* k >= 0 ?
*/
BOOLEAN nfGreaterZero (number k)
{
#ifdef LDEBUG
  nfTest(k);
#endif
  return !nfIsZero(k) && !nfIsMOne(k);
}

/*2
* a*b
*/
number nfMult (number a,number b)
{
#ifdef LDEBUG
  nfTest(a);
  nfTest(b);
#endif
  if (((long)a == (long)nfCharQ) || ((long)b == (long)nfCharQ))
    return (number)(long)nfCharQ;
  /*else*/
  int i=(int)((long)a+(long)b);
  if (i>=nfCharQ1) i-=nfCharQ1;
#ifdef LDEBUG
  nfTest((number)(long)i);
#endif
  return (number)(long)i;
}

/*2
* int -> number
*/
number nfInit (int i, const ring r)
{
  // Hmm .. this is just to prevent initialization
  // from nfInitChar to go into an infinite loop
  if (i==0) return (number)(long)nfCharQ;
  while (i <  0)    i += nfCharP;
  while (i >= nfCharP) i -= nfCharP;
  if (i==0) return (number)(long)nfCharQ;
  unsigned short c=0;
  while (i>1)
  {
    c=nfPlus1Table[c];
    i--;
  }
#ifdef LDEBUG
  nfTest((number)(long)c);
#endif
  return (number)(long)c;
}

/*
* the generating element `z`
*/
number nfPar (int i)
{
  return (number)1;
}

/*2
* the degree of the "alg. number"
*/
int nfParDeg(number n)
{
#ifdef LDEBUG
  nfTest(n);
#endif
  if((long)nfCharQ == (long)n) return -1;
  return (int)((long)n);
}

/*2
* number -> int
*/
int nfInt (number &n, const ring r)
{
  return 0;
}

/*2
* a + b
*/
number nfAdd (number a, number b)
{
/*4 z^a+z^b=z^b*(z^(a-b)+1), if a>=b; *
*          =z^a*(z^(b-a)+1)  if a<b  */
#ifdef LDEBUG
  nfTest(a);
  nfTest(b);
#endif
  if ((long)nfCharQ == (long)a) return b;
  if ((long)nfCharQ == (long)b) return a;
  long zb,zab,r;
  if ((long)a >= (long)b)
  {
    zb = (long)b;
    zab = (long)a-(long)b;
  }
  else
  {
    zb = (long)a;
    zab = (long)b-(long)a;
  }
#ifdef LDEBUG
  nfTest((number)zab);
#endif
  if (nfPlus1Table[zab]==nfCharQ) r=(long)nfCharQ; /*if z^(a-b)+1 =0*/
  else
  {
    r= zb+(long)nfPlus1Table[zab];
    if(r>=(long)nfCharQ1) r-=(long)nfCharQ1;
  }
#ifdef LDEBUG
  nfTest((number)r);
#endif
  return (number)r;
}

/*2
* a - b
*/
number nfSub (number a, number b)
{
  number mb = nfNeg(b);
  return nfAdd(a,mb);
}

/*2
* a == 0 ?
*/
BOOLEAN nfIsZero (number  a)
{
#ifdef LDEBUG
  nfTest(a);
#endif
  return (long)nfCharQ == (long)a;
}

/*2
* a == 1 ?
*/
BOOLEAN nfIsOne (number a)
{
#ifdef LDEBUG
  nfTest(a);
#endif
  return 0L == (long)a;
}

/*2
* a == -1 ?
*/
BOOLEAN nfIsMOne (number a)
{
#ifdef LDEBUG
  nfTest(a);
#endif
  if (0L == (long)a) return FALSE; /* special handling of char 2*/
  return (long)nfM1 == (long)a;
}

/*2
* a / b
*/
number nfDiv (number a,number b)
{
#ifdef LDEBUG
  nfTest(b);
#endif
  if ((long)b==(long)nfCharQ)
  {
    WerrorS(nDivBy0);
    return (number)((long)nfCharQ);
  }
#ifdef LDEBUG
  nfTest(a);
#endif
  if ((long)a==(long)nfCharQ)
    return (number)((long)nfCharQ);
  /*else*/
  long s = (long)a - (long)b;
  if (s < 0L)
    s += (long)nfCharQ1;
#ifdef LDEBUG
  nfTest((number)s);
#endif
  return (number)s;
}

/*2
* 1 / c
*/
number  nfInvers (number c)
{
#ifdef LDEBUG
  nfTest(c);
#endif
  if ((long)c==(long)nfCharQ)
  {
    WerrorS(nDivBy0);
    return (number)((long)nfCharQ);
  }
#ifdef LDEBUG
  nfTest(((number)((long)nfCharQ1-(long)c)));
#endif
  return (number)((long)nfCharQ1-(long)c);
}

/*2
* -c
*/
number nfNeg (number c)
{
/*4 -z^c=z^c*(-1)=z^c*nfM1*/
#ifdef LDEBUG
  nfTest(c);
#endif
  if ((long)nfCharQ == (long)c) return c;
  long i=(long)c+(long)nfM1;
  if (i>=(long)nfCharQ1) i-=(long)nfCharQ1;
#ifdef LDEBUG
  nfTest((number)i);
#endif
  return (number)i;
}

/*2
* a > b ?
*/
BOOLEAN nfGreater (number a,number b)
{
#ifdef LDEBUG
  nfTest(a);
  nfTest(b);
#endif
  return (long)a != (long)b;
}

/*2
* a == b ?
*/
BOOLEAN nfEqual (number a,number b)
{
#ifdef LDEBUG
  nfTest(a);
  nfTest(b);
#endif
  return (long)a == (long)b;
}

/*2
* write via StringAppend
*/
void nfWrite (number &a, const ring r)
{
#ifdef LDEBUG
  nfTest(a);
#endif
  if ((long)a==(long)nfCharQ)  StringAppendS("0");
  else if ((long)a==0L)   StringAppendS("1");
  else if (nfIsMOne(a))   StringAppendS("-1");
  else
  {
    StringAppendS(r->parameter[0]);
    if ((long)a!=1L)
    {
      if(r->ShortOut==0)  StringAppendS("^");
      StringAppend("%d",(int)((long)a));
    }
  }
}

/*2
*
*/
char * nfName(number a)
{
#ifdef LDEBUG
  nfTest(a);
#endif
  char *s;
  char *nfParameter=currRing->parameter[0];
  if (((long)a==(long)nfCharQ) || ((long)a==0L)) return NULL;
  else if ((long)a==1L)
  {
    return omStrDup(nfParameter);
  }
  else
  {
    s=(char *)omAlloc(4+strlen(nfParameter));
    sprintf(s,"%s%d",nfParameter,(int)((long)a));
  }
  return s;
}
/*2
* c ^ i with i>=0
*/
void nfPower (number a, int i, number * result)
{
#ifdef LDEBUG
  nfTest(a);
#endif
  if (i==0)
  {
    //*result=nfInit(1);
    *result = (number)0L;
  }
  else if (i==1)
  {
    *result = a;
  }
  else
  {
    nfPower(a,i-1,result);
    *result = nfMult(a,*result);
  }
#ifdef LDEBUG
  nfTest(*result);
#endif
}

/*4
* read an integer (with reduction mod p)
*/
static const char* nfEati(const char *s, int *i)
{
  if (*s >= '0' && *s <= '9')
  {
    *i = 0;
    do
    {
      *i *= 10;
      *i += *s++ - '0';
      if (*i > (MAX_INT_VAL / 10)) *i = *i % nfCharP;
    }
    while (*s >= '0' && *s <= '9');
    if (*i >= nfCharP) *i = *i % nfCharP;
  }
  else *i = 1;
  return s;
}

/*2
* read a number
*/
const char * nfRead (const char *s, number *a)
{
  int i;
  number z;
  number n;

  s = nfEati(s, &i);
  z=nfInit(i, currRing);
  *a=z;
  if (*s == '/')
  {
    s++;
    s = nfEati(s, &i);
    n=nfInit(i, currRing);
    *a = nfDiv(z,n);
  }
  char *nfParameter=currRing->parameter[0];
  if (strncmp(s,nfParameter,strlen(nfParameter))==0)
  {
    s+=strlen(nfParameter);
    if ((*s >= '0') && (*s <= '9'))
    {
      s=eati(s,&i);
      while (i>=nfCharQ1) i-=nfCharQ1;
    }
    else
      i=1;
    z=(number)(long)i;
    *a=nfMult(*a,z);
  }
#ifdef LDEBUG
  nfTest(*a);
#endif
  return s;
}

#ifdef HAVE_FACTORY
int gf_tab_numdigits62 ( int q );
int convertback62 ( char * p, int n );
#else
static int gf_tab_numdigits62 ( int q )
{
    if ( q < 62 )          return 1;
    else  if ( q < 62*62 ) return 2;
    /*else*/               return 3;
}

static int convback62 ( char c )
{
    if ( c >= '0' && c <= '9' )
        return int(c) - int('0');
    else  if ( c >= 'A' && c <= 'Z' )
        return int(c) - int('A') + 10;
    else
        return int(c) - int('a') + 36;
}

static int convertback62 ( char * p, int n )
{
    int r = 0;
    for ( int j = 0; j < n; j++ )
        r = r * 62 + convback62( p[j] );
    return r;
}
#endif

int nfMinPoly[16];

void nfShowMipo()
{
  int i=nfMinPoly[0];
  int j=0;
  loop
  {
    j++;
    if (nfMinPoly[j]!=0)
      StringAppend("%d*%s^%d",nfMinPoly[j],currRing->parameter[0],i);
    i--;
    if(i<0) break;
    if (nfMinPoly[j]!=0)
      StringAppendS("+");
  }
}

static void nfReadMipo(char *s)
{
  const char *l=strchr(s,';')+1;
  char *n;
  int i=strtol(l,&n,10);
  l=n;
  int j=1;
  nfMinPoly[0]=i;
  while(i>=0)
  {
    nfMinPoly[j]=strtol(l,&n,10);
    if (l==n) break;
    l=n;
    j++;
    i--;
  }
  if (i>=0)
  {
    WerrorS("error in reading minpoly from gftables");
  }
}

/*2
* init global variables from files 'gftables/%d'
*/
void nfSetChar(int c, char **param)
{
  //Print("GF(%d)\n",c);
  if ((c==nfCharQ)||(c==-nfCharQ))
    /*this field is already set*/  return;
  int i=0;
  while ((fftable[i]!=c) && (fftable[i]!=0)) i++;
  if (fftable[i]==0)
    return;
  if (nfCharQ > 1)
  {
    omFreeSize( (ADDRESS)nfPlus1Table,nfCharQ*sizeof(unsigned short) );
    nfPlus1Table=NULL;
  }
  if ((c>1) || (c<0))
  {
    if (c>1) nfCharQ = c;
    else     nfCharQ = -c;
    char buf[100];
    sprintf(buf,"gftables/%d",nfCharQ);
    FILE * fp = feFopen(buf,"r",NULL,TRUE);
    if (fp==NULL)
    {
      return;
    }
    if(!fgets( buf, sizeof(buf), fp)) return;
    if(strcmp(buf,"@@ factory GF(q) table @@\n")!=0)
    {
      goto err;
    }
    if(!fgets( buf, sizeof(buf), fp))
    {
      goto err;
    }
    int q;
    sscanf(buf,"%d %d",&nfCharP,&q);
    nfReadMipo(buf);
    nfCharQ1=nfCharQ-1;
    //Print("nfCharQ=%d,nfCharQ1=%d,mipo=>>%s<<\n",nfCharQ,nfCharQ1,buf);
    nfPlus1Table= (unsigned short *)omAlloc( (nfCharQ)*sizeof(unsigned short) );
    int digs = gf_tab_numdigits62( nfCharQ );
    char * bufptr;
    int i = 1;
    int k;
    while ( i < nfCharQ )
    {
      fgets( buf, sizeof(buf), fp);
      //( strlen( buffer ) == (size_t)digs * 30, "illegal table" );
      bufptr = buf;
      k = 0;
      while ( (i < nfCharQ) && (k < 30) )
      {
        nfPlus1Table[i] = convertback62( bufptr, digs );
        if(nfPlus1Table[i]>nfCharQ)
        {
          Print("wrong entry %d: %d(%c%c%c)\n",i,nfPlus1Table[i],bufptr[0],bufptr[1],bufptr[2]);
        }
        bufptr += digs;
        if (nfPlus1Table[i]==nfCharQ)
        {
          if(i==nfCharQ1)
          {
            nfM1=0;
          }
          else
          {
            nfM1=i;
          }
        }
        i++; k++;
      }
    }
    nfPlus1Table[0]=nfPlus1Table[nfCharQ1];
  }
  else
    nfCharQ=0;
#ifdef LDEBUG
  nfTest((number)0);
#endif
  return;
err:
  Werror("illegal GF-table %d",nfCharQ);
}

/*2
* map Z/p -> GF(p,n)
*/
number nfMapP(number c)
{
  return nfInit((int)((long)c), currRing);
}

/*2
* map GF(p,n1) -> GF(p,n2), n1 < n2, n1 | n2
*/
int nfMapGG_factor;
number nfMapGG(number c)
{
  int i=(long)c;
  i*= nfMapGG_factor;
  while (i >nfCharQ1) i-=nfCharQ1;
  return (number)((long)i);
}
/*2
* map GF(p,n1) -> GF(p,n2), n1 > n2, n2 | n1
*/
number nfMapGGrev(number c)
{
  int ex=(int)((long)c);
  if ((ex % nfMapGG_factor)==0)
    return (number)(((long)ex) / ((long)nfMapGG_factor));
  else
    return (number)(long)nfCharQ; /* 0 */
}

/*2
* set map function nMap ... -> GF(p,n)
*/
nMapFunc nfSetMap(const ring src, const ring dst)
{
  if (rField_is_GF(src,nfCharQ))
  {
    return ndCopy;   /* GF(p,n) -> GF(p,n) */
  }
  if (rField_is_GF(src))
  {
    int q=src->ch;
    if ((nfCharQ % q)==0) /* GF(p,n1) -> GF(p,n2), n2 > n1 */
    {
      // check if n2 is a multiple of n1
      int n1=1;
      int qq=nfCharP;
      while(qq!=q) { qq *= nfCharP; n1++; }
      int n2=1;
      qq=nfCharP;
      while(qq!=nfCharQ) { qq *= nfCharP; n2++; }
      Print("map %d^%d -> %d^%d\n",nfCharP,n1,nfCharP,n2);
      if ((n2 % n1)==0)
      {
        int save_ch=currRing->ch;
        char **save_par=currRing->parameter;
        nfSetChar(src->ch,src->parameter);
        int nn=nfPlus1Table[0];
        nfSetChar(save_ch,save_par);
        nfMapGG_factor= nfPlus1Table[0] / nn;
        Print("nfMapGG_factor=%d (%d / %d)\n",nfMapGG_factor, nfPlus1Table[0], nn);
        return nfMapGG;
      }
      else if ((n1 % n2)==0)
      {
        nfMapGG_factor= (n1/n2);
        return nfMapGGrev;
      }
      else
        return NULL;
    }
  }
  if (rField_is_Zp(src,nfCharP))
  {
    return nfMapP;    /* Z/p -> GF(p,n) */
  }
  return NULL;     /* default */
}
