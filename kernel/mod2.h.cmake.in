/* -*-c++-*- */
/*******************************************************************
 *  Computer Algebra System SINGULAR
 *
 *  mod2.h: Main configuration file for Singular
 *          DO NOT EDIT!
 *
 *******************************************************************/
#ifndef MOD2_H
#define MOD2_H

/*******************************************************************
 * Defines which are set by configure
 ******************************************************************/
/* Define to use dynamic linking */
#cmakedefine HAVE_DL 1
/* Define to use readline lib for fancy display: configure result */
#cmakedefine HAVE_LIBREADLINE 1
/* Define to use static readline lib for fancy display */
#cmakedefine HAVE_READLINE 1
/* define to use dynamic version of readline lib */
#cmakedefine HAVE_DYN_RL 1
/* Define to have dbm links */
#cmakedefine HAVE_DBM 1
/* Define to have MP links */
#cmakedefine HAVE_MPSR 1
/* Define to have factory functionality added */
#cmakedefine HAVE_FACTORY 1
/* Define if you have stdc headers */
#cmakedefine STDC_HEADERS 1
/* Define if you have asm/sigcontext.h */
#cmakedefine HAVE_ASM_SIGCONTEXT_H 1
/* Define if you have sys/file.h */
#cmakedefine HAVE_SYS_FILE_H 1
/* Define if you have sys/stat.h */
#cmakedefine HAVE_SYS_STAT_H 1
/* Define if you have sys/param.h */
#cmakedefine HAVE_SYS_PARAM_H 1
/* Define if you have sys/file.h */
#cmakedefine HAVE_SYS_TYPES_H 1
/* Define if you have sys/ioctl.h */
#cmakedefine HAVE_SYS_IOCTL_H 1
/* Define if you have sys/time.h */
#cmakedefine HAVE_SYS_TIME_H 1
/* Define if you have sys/times.h */
#cmakedefine HAVE_SYS_TIMES_H 1
/* io header: */
/* Define if you have termcap.h */
#cmakedefine HAVE_TERMCAP_H 1
/* Define if you have termios.h */
#cmakedefine HAVE_TERMIOS_H 1
/* Define if you have term.h */
#cmakedefine HAVE_TERM_H 1
/* Define if you have readline/history.h */
#cmakedefine HAVE_READLINE_HISTORY_H 1
/* Define if readline/readline.h is ok */
#cmakedefine READLINE_READLINE_H_OK 1
/* Define if time.h and sys/time.h can be included at the same time */
#cmakedefine TIME_WITH_SYS_TIME 1
/* Define if you have alloca.h */
#cmakedefine HAVE_ALLOCA_H 1
/* Define if you have pwd.h */
#cmakedefine HAVE_PWD_H 1
/* Define if you have unistd.h */
#cmakedefine HAVE_UNISTD_H 1
/* define if you have malloc.h */
#cmakedefine HAVE_MALLOC_H 1
/* Define if you have alloca */
#cmakedefine HAVE_ALLOCA 1
/* Define if you have getpagesize */
#cmakedefine GETPAGESIZE 1
/* Define if you have vprintf */
#cmakedefine HAVE_VPRINTF 1
/* Define if you have gettimeofday */
#cmakedefine HAVE_GETTIMEOFDAY 1
/* Define if you have atexit */
#cmakedefine HAVE_ATEXIT 1
/* Define if you have bcopy, bzero and bcmp
   Linux needs that define! */
#cmakedefine HAVE_BCOPY 1
/* Define if sprintf does not return number of printed chars */
#cmakedefine BSD_SPRINTF 1
/* define if you have explicit C++ constructors */
#cmakedefine HAVE_EXPLICIT_CONSTR 1
/* Define if you have the getcwd function.  */
#cmakedefine HAVE_GETCWD 1
/* Define if you have the getwd function.  */
#cmakedefine HAVE_GETWD 1
/* Define if you have snprintf */
#cmakedefine HAVE_VSNPRINTF 1
/* Define if you have readlink */
#cmakedefine HAVE_READLINK 1
/* Define if you have usleep */
#cmakedefine HAVE_USLEEP 1
/* Define if you have sleep */
#cmakedefine HAVE_SLEEP 1
/* Define if you have setenv */
#cmakedefine HAVE_SETENV 1
/* Define if you have petpwnam */
#cmakedefine HAVE_GETPWNAM 1
/* Define if you have popen */
#cmakedefine HAVE_POPEN 1
/* Define if you have sysconf */
#cmakedefine HAVE_SYSCONF 1
/* Define if you have siginterrupt (BSD4.3) */
#cmakedefine HAVE_SIGINTERRUPT 1
/* define for boost includes and lib */
//////////////////////// #undef HAVE_BOOST_DYNAMIC_BITSET_HPP
/* define for std:vector includes */
#cmakedefine USE_STDVECBOOL 1
/* Define sizeof(char) */
#define SIZEOF_CHAR 1
/* Define sizeof(short) */
#define SIZEOF_SHORT 2
/* Define sizeof(int) */
#define SIZEOF_INT 4
/* Define sizeof(long) */
#define SIZEOF_LONG 4
/* Define sizeof(void*) */
#define SIZEOF_VOIDP 4
/* Define sizeof(double) */
#define SIZEOF_DOUBLE 8
/* Define if your integer format is big endian */
#cmakedefine WORDS_BIGENDIAN 1
/* Define major version of Singular -- should be set in ../configure.in!!!*/
#define SINGULAR_MAJOR_VERSION 0
/* Define minor version of Singular -- should be set in ../configure.in!!! */
#define SINGULAR_MINOR_VERSION 0
/* Define sub version of Singular -- should be set in ../configure.in!!! */
#define SINGULAR_SUB_VERSION 0
/* Define version as a string */
#define S_VERSION1 ""
/* Define version date as a string */
#define S_VERSION2 ""
/* Define uname identifier as a string */
#define S_UNAME ""
/* Absolute pathname of root directory of Singular source */
#define S_ROOT_DIR ""
/* Define to enable dynamic module code */
#cmakedefine HAVE_DYNAMIC_LOADING 1
/* Define to enable plural */
#cmakedefine HAVE_PLURAL 1
/* Define to enable ratGB/ ratGRING */
#cmakedefine HAVE_RATGRING 1
/* Define to enable shiftbba */
#cmakedefine HAVE_SHIFTBBA 1
/* Define to enable libsvd */
#cmakedefine HAVE_SVD 1
/* CPU type: i[3456]86: */
#cmakedefine SI_CPU_I386 1
/* CPU type: sparc: */
#cmakedefine SI_CPU_SPARC 1
/* CPU type: ppc: */
#cmakedefine SI_CPU_PPC 1
/* CPU type: IA64: */
#cmakedefine SI_CPU_IA64 1
/* CPU type: x86_64: */
#cmakedefine SI_CPU_X86_64 1

/*******************************************************************
 * Defines which are not set by configure
 ******************************************************************/

/* Default value for timer resolution in ticks per second */
/* set to 10 for resolution of tenth of a second, etc */
#define TIMER_RESOLUTION 1

/* Undefine to disable the quote/eval of expressions */
#define SIQ 1

/* Define to enable TCL interface */
#cmakedefine HAVE_TCL  1

/* Undefine to disable Gerhard's and Wilfried's fast and dirty std computations */
#define FAST_AND_DIRTY

/* eigenvalues */
#ifndef HAVE_DYNAMIC_LOADING
#define HAVE_EIGENVAL 1

/* Gauss-Manin system */
#define HAVE_GMS 1
#endif

/* linear algebra extensions from pcv.h/pcv.cc */
#define HAVE_PCV 1

/* procedures to compute groebner bases with the f5 implementation */
/* still testing */
#cmakedefine HAVE_F5 1

/* procedures to compute groebner bases with the f5c implementation */
/* still testing */
#cmakedefine HAVE_F5C 1

/* letterplace gb:*/
#define HAVE_SHIFTBBA 1

/* rings as coefficients */
#define HAVE_RINGS

/* procedures to compute with units */
#define HAVE_UNITS

/* Define to use old mechanismen for saving currRing with procedures
 */
#cmakedefine USE_IILOCALRING


/* Define to use scanner when loading libraries */
#define HAVE_LIBPARSER

/*#define PROFILING*/
#ifdef PROFILING
#define PROFILER ,0,0
#else
#define PROFILER
#endif

/*******************************************************************
 * Evaluate the set defines
 ******************************************************************/
/* FGLM needs factory */
#ifdef HAVE_FACTORY
#define HAVE_FGLM
#endif

/* Define if you want fglm for homogeneous case */
#ifdef HAVE_FGLM
#undef HAVE_FGLM_HOME
#endif

/* Spectrum needs GMP */
#define HAVE_SPECTRUM 1

/* Undefine to disable real time measurments  */
#ifdef HAVE_GETTIMEOFDAY
#define HAVE_RTIMER
#endif

#if SIZEOF_VOIDP == 8
/* SIZEOF_LONG == SIZEOF_VOIDP is guaranteed by configure */
#define ALIGN_8
#define LOG_SIZEOF_LONG  3
#define LOG_SIZEOF_VOIDP 3
#else
#define LOG_SIZEOF_LONG  2
#define LOG_SIZEOF_VOIDP 2
#endif

#ifndef CHAR_BIT
#define CHAR_BIT 8
#endif

#define BIT_SIZEOF_LONG CHAR_BIT*SIZEOF_LONG

#define SINGULAR_PATCHLEVEL 6
#define SINGULAR_VERSION ((SINGULAR_MAJOR_VERSION*1000 + SINGULAR_MINOR_VERSION*100 + SINGULAR_SUB_VERSION*10)+SINGULAR_PATCHLEVEL)

/*******************************************************************
 * Miscellanous Defines
 ******************************************************************/
#ifndef HAVE_LIBPARSER
#  undef YYLPDEBUG
#else
#  define YYLPDEBUG 1
#endif

#ifndef FALSE
#define FALSE       0
#endif

#ifndef TRUE
#define TRUE        1
#endif

#ifndef NULL
#define NULL        (0)
#endif

#ifndef SEEK_END
#define SEEK_END 2
#endif

#ifndef SEEK_SET
#define SEEK_SET 0
#endif

#define HALT() m2_end(2)

#define memcpy4 memcpy

/* define OLD_RES for res/sres/mres(i,j,k) */
#cmakedefine OLD_RES

/* the maximal ascii length of an int number + 1 = 11 for 32 bit int */
#define MAX_INT_LEN 11
#define MAX_INT_VAL 0x7fffffff

#ifdef DO_PROFILE
/* define to enable explicit profiling of some crucial inline
 * routines and defines  */
#cmakedefine DO_DEEP_PROFILE
#endif

#define buildin_rand 1

/* define to enable assume */
#ifndef HAVE_ASSUME
#cmakedefine HAVE_ASSUME
#endif

/* define LINKAGE to "extern C" if compiling for shared libs */
#ifndef LINKAGE
#if defined(PIC)
#define LINKAGE extern "C"
#else
#define LINKAGE
#endif
#endif


/*******************************************************************
 * DEBUG OPTIONS
 * -- only significant for for compiling without -DSING_NDEBUG
 * -- you better know what your are doing, if you touch this
 ******************************************************************/
#ifndef SING_NDEBUG

/* undefine to enable inline */
#define NO_INLINE

/* undefine to disable assume -- should normally be defined for SING_NDEBUG */
#define HAVE_ASSUME

/* undef PDEBUG to disable checks of polys

 define PDEBUG to
  0 for enabling pTest
  1 plus tests in Level 1 poly routines (operations on monomials)
  2 plus tests in Level 2 poly routines (operations on single exponents)
 -- see also polys.h for more info

 NOTE: you can set the value of PDEBUG on a per-file basis, before
       including mod2.h, provided ! PDEBUG is defined in mod2.h E.g.:

       #define PDEBUG 2

       ...

       makes sure that all poly operations in your file are done with 
       PDEBUG == 2
 To break after an error occured, set a debugger breakpoint on
 dErrorBreak. 
*/
#ifndef PDEBUG
#define PDEBUG 0
#endif

/* define MDEBUG to enable memory checks */
#define MDEBUG 0

#ifdef MDEBUG
/* If ! defined(OM_NDEBUG) and (defined(OM_TRACK) or defined(OM_CHECK)
   then omDebug routines are used for memory allocation/free:

   The omDebug routines are controlled by the values of OM_TRACK, OM_CHECK
   and OM_KEEP.  There meaning is roughly as follows:
   OM_TRACK: strored with address                              : extra space
     0     : no additional info is stored                      : 0
     1     : file:line of location where address was allocated : 1 word
     2     : plus backtrace of stack where adress was allocated: 6 words
     3     : plus size/bin info and front-, and back padding   : 9 words
     4     : plus file:line of location where adress was freed : 10 words
     5     : plus backtrace of stack where adress was allocated: 15 words
   OM_CHECK: checks done
     0     : no checks
     1     : constant-time checks: i.e. addr checks only
     2     : plus linear-time checks and constant related bin check
     3     : plus quadratic-time checks and linear-time related bin checks and
             constant time all memory checks
     4     : and so on
     ==> for OM_CHECK >= 3 it gets rather slow
   OM_KEEP:  determines whether addresses are really freed  (
     0     : addresses are really freed
     1     : addresses are only marked as free and not really freed.

   OM_CHECK, OM_TRACK, and OM_KEEP can be set on a per-file basis 
   (as can OM_NDEBUG),  e.g.:
     #define OM_CHECK 3
     #define OM_TRACK 5
     #define OM_KEEP  1

     #include <omalloc/omalloc.h>
   ensures that all memory allocs/free in this file are done with 
   OM_CHECK==3 and OM_TRACK==5, and that all addresses allocated/freed 
   in this file are only marked as free and never really freed.
 
   To set OM_CHECK, OM_TRACK and OM_KEEP under dynamic scope, set 
   om_Opts.MinCheck, om_Opts.MinTrack to the respectiv values and 
   om_Opts.Keep to the number of addresses which are kept before they are 
   actually freed. E.g.:
     int check=om_Opts.MinCheck, track=om_Opts.MinTrack, keep= m_OPts.Keep;
     om_Opts.MinCheck = 3; om_Opts.MinTrack = 5; omOpts.Keep = LONG_MAX;
     ExternalRoutine();
     om_Opts.MinCheck = check; omOpts.MinTrack = track; omOpts.Keep = keep;
   ensures that all calls omDebug routines  occuring during the computation of
   ExternalRoutine() are done with OM_CHECK==3 and OM_TRACK==5, and 
   calls to omFree only mark addresses as free and not really free them.

   Furthermore, the value of OM_SING_KEEP (resp. om_Opts.Keep) specifies 
   how many addresses are kept before they are actually freed, independently 
   of the value of OM_KEEP.

   Some tips on possible values of OM_TRACK, OM_CHECK, OM_KEEP:
   + To find out about an address that has been freed twice, first locate the
     file(s) where the error occured, and then at the beginning of these files:
       #define OM_CHECK 3
       #define OM_TRACK 5
       #define OM_KEEP  1

       #include <omalloc/omalloc.h>
     Under dynamic scope, do (e.g., from within the debugger):
       om_Opts.MinCheck = 3; om_Opts.MinTrack = 5; omOpts.Keep = LONG_MAX;
   + to find out where "memory corruption" occured, increase value of 
     OM_CHECK - the higher this value is, the more consistency checks are 
     done (However a value > 3 checks the entire memory each time an omalloc 
     routine is used!)
   
   Some more tips on the usage of omalloc:
   + omAlloc*, omRealloc*, omFree*, omCheck* omDebug* omTest* rotuines 
     assume that sizes are > 0 and pointers are != NULL
   + omalloc*, omrealloc*, omfree* omcheck*, omdebug* omtest* routines allow
     NULL pointers and sizes == 0
   + You can safely use any free/realloc routine in combination with any alloc 
     routine (including the debug versions): E.g., an address allocated with
     omAllocBin can be freed with omfree, or an adress allocated with 
     om(Debug)Alloc can be freed with omfree, or omFree, or omFreeSize, etc.
     However, keep in mind that the efficiency decreases from 
     Bin over Size to General routines (i.e., omFreeBin is more efficient than
     omFreeSize which is more efficient than omFree, likewise with the alloc
     routines).
   + if OM_CHECK is undefined or 0, then all omCheck routines do nothing
   + if OM_CHECK and OM_TRACK are both undefined (or 0), or if OM_NDEBUG is 
     defined, then the "real" alloc/realloc/free macros are used, and all 
     omTest, omDebug and omCheck routines are undefined
   + to break after an omError occured within a debugger, 
     set a breakpoint on dErrorBreak
   + to do checks from within the debugger, or to do checks with explicit 
     check level, use omTest routines.
*/

/* by default, store alloc info and file/line where addr was freed */
#ifndef OM_TRACK
#define OM_TRACK 4
#endif
/* only do constant-time memory checks */
#ifndef OM_CHECK
#define OM_CHECK 1
#endif
/* Do actually free memory: 
   (be careful: if this is set, memory is never really freed, 
    but only marked as free) */
#ifndef OM_KEEP
#define OM_KEEP 0
#endif
/* but only after you have freed 1000 more addresses 
   (this is actually independent of the value of OM_KEEP and used
   to initialize om_Opts.Keep) */
#ifndef OM_SING_KEEP
#define OM_SING_KEEP 1000
#endif

#endif /* MDEBUG */


/* undef KDEBUG for check of data during std computations 
 *
 * define KDEBUG to
 * 0 for basic tests
 * 1 for tests in kSpoly 
 * NOTE: You can locally enable tests in kspoly by setting the 
 *       define at the beginning of kspoly.cc
 */
#define KDEBUG 0

/* define LDEBUG checking numbers, undefine otherwise */
#define LDEBUG
/* define RDEBUG checking rings (together with TRACE=9) */
//#define RDEBUG
/* define TEST for non time critical tests, undefine otherwise */
#define TEST

/* #define PAGE_TEST */

/* define YYDEBUG 1 for debugging bison texts, 0 otherwise */
#define YYDEBUG 1

/* Undefine to disable debugging of MP stuff */
#ifdef HAVE_MPSR
#define MPSR_DEBUG
#endif


#ifdef TEST
#ifndef buildin_rand
#define buildin_rand 1
#endif
#endif

/* define SPECTRUM_DEBUG and SPECTRUM_PRINT for debugging the spectrum code */
/* define SPECTRUM_IOSTREAM to use C++ iostream for error messages          */

/* #define SPECTRUM_DEBUG */
/* #define SPECTRUM_PRINT */
#cmakedefine  SPECTRUM_IOSTREAM

#ifdef  SPECTRUM_DEBUG
#define MULTICNT_DEBUG
#define GMPRAT_DEBUG
#define KMATRIX_DEBUG
#define SPLIST_DEBUG
#define NPOLYGON_DEBUG
#define SEMIC_DEBUG
#endif

#ifdef  SPECTRUM_PRINT
#define MULTICNT_PRINT
#define GMPRAT_PRINT
#define KMATRIX_PRINT
#define SPLIST_PRINT
#define NPOLYGON_PRINT
#define SEMIC_PRINT
#endif

#ifdef  SPECTRUM_IOSTREAM
#define MULTICNT_IOSTREAM
#define GMPRAT_IOSTREAM
#define KMATRIX_IOSTREAM
#define SPLIST_IOSTREAM
#define NPOLYGON_IOSTREAM
#define SEMIC_IOSTREAM
#endif


#else /* not SING_NDEBUG **************************************************** */

#define NO_PDEBUG

/* define YYDEBUG 1 for debugging bison texts, 0 otherwise */
#define YYDEBUG 0

#endif /* not SING_NDEBUG */

/*******************************************************************
 *
 * assume(x) -- a handy macro for assumptions
 *
 ******************************************************************/

#ifdef __cplusplus
extern "C" {
#endif
// routine which is used to report the error
// returns 0
extern int dReportError(const char* fmt, ...);
// within a debugger, set a breakpoint on dErrorBreak
// which is called after the error has been reported
extern void dErrorBreak();
#ifdef __cplusplus
}
#endif

#ifndef HAVE_ASSUME
#define assume(x) do {} while (0)
#define r_assume(x) do {} while (0)
#else /* ! HAVE_ASSUME */

#define assume_violation(s,f,l) \
  dReportError("assume violation at %s:%d condition: %s", f,l,s)

#define assume(x)   _assume(x, __FILE__, __LINE__)
#define r_assume(x) _r_assume(x, __FILE__, __LINE__)

#define _assume(x, f, l)                        \
do                                              \
{                                               \
  if (! (x))                                    \
  {                                             \
    assume_violation(#x, f, l);                 \
  }                                             \
}                                               \
while (0)

#define _r_assume(x, f, l)                      \
do                                              \
{                                               \
  if (! (x))                                    \
  {                                             \
    assume_violation(#x, f, l);                 \
    return 0;                                   \
  }                                             \
}                                               \
while (0)
#endif /* HAVE_ASSUME */

/* do have RDEBUG, unless we are doing the very real thing */
#ifdef HAVE_ASSUME
#ifndef RDEBUG
#define RDEBUG 
#endif
#endif

#if SIZEOF_VOIDP == 8
#ifndef OM_CHECK
#define OM_CHECK 0
#endif
#endif

/* If we're not using GNU C, elide __attribute__ */
#ifndef __GNUC__
#  define  __attribute__(x)  /*NOTHING*/
#endif

#endif /* MOD2_H  */
/* -*-c++-*- */
/*******************************************************************
 *  Computer Algebra System SINGULAR
 *
 *  mod2.h: Main configuration file for Singular
 *          DO NOT EDIT!
 *
 *******************************************************************/
#ifndef MOD2_H
#define MOD2_H

/*******************************************************************
 * Defines which are set by configure
 ******************************************************************/
/* Define to use dynamic linking */
#cmakedefine HAVE_DL 1
/* Define to use readline lib for fancy display: configure result */
#cmakedefine HAVE_LIBREADLINE 1
/* Define to use static readline lib for fancy display */
#cmakedefine HAVE_READLINE 1
/* define to use dynamic version of readline lib */
#cmakedefine HAVE_DYN_RL 1
/* Define to have dbm links */
#cmakedefine HAVE_DBM 1
/* Define to have MP links */
#cmakedefine HAVE_MPSR 1
/* Define to have factory functionality added */
#cmakedefine HAVE_FACTORY 1
/* Define if you have stdc headers */
#cmakedefine STDC_HEADERS 1
/* Define if you have asm/sigcontext.h */
#cmakedefine HAVE_ASM_SIGCONTEXT_H 1
/* Define if you have sys/file.h */
#cmakedefine HAVE_SYS_FILE_H 1
/* Define if you have sys/stat.h */
#cmakedefine HAVE_SYS_STAT_H 1
/* Define if you have sys/param.h */
#cmakedefine HAVE_SYS_PARAM_H 1
/* Define if you have sys/file.h */
#cmakedefine HAVE_SYS_TYPES_H 1
/* Define if you have sys/ioctl.h */
#cmakedefine HAVE_SYS_IOCTL_H 1
/* Define if you have sys/time.h */
#cmakedefine HAVE_SYS_TIME_H 1
/* Define if you have sys/times.h */
#cmakedefine HAVE_SYS_TIMES_H 1
/* io header: */
/* Define if you have termcap.h */
#cmakedefine HAVE_TERMCAP_H 1
/* Define if you have termios.h */
#cmakedefine HAVE_TERMIOS_H 1
/* Define if you have term.h */
#cmakedefine HAVE_TERM_H 1
/* Define if you have readline/history.h */
#cmakedefine HAVE_READLINE_HISTORY_H 1
/* Define if readline/readline.h is ok */
#cmakedefine READLINE_READLINE_H_OK 1
/* Define if time.h and sys/time.h can be included at the same time */
#cmakedefine TIME_WITH_SYS_TIME 1
/* Define if you have alloca.h */
#cmakedefine HAVE_ALLOCA_H 1
/* Define if you have pwd.h */
#cmakedefine HAVE_PWD_H 1
/* Define if you have unistd.h */
#cmakedefine HAVE_UNISTD_H 1
/* define if you have malloc.h */
#cmakedefine HAVE_MALLOC_H 1
/* Define if you have alloca */
#cmakedefine HAVE_ALLOCA 1
/* Define if you have getpagesize */
#cmakedefine GETPAGESIZE 1
/* Define if you have vprintf */
#cmakedefine HAVE_VPRINTF 1
/* Define if you have gettimeofday */
#cmakedefine HAVE_GETTIMEOFDAY 1
/* Define if you have atexit */
#cmakedefine HAVE_ATEXIT 1
/* Define if you have bcopy, bzero and bcmp
   Linux needs that define! */
#cmakedefine HAVE_BCOPY 1
/* Define if sprintf does not return number of printed chars */
#cmakedefine BSD_SPRINTF 1
/* define if you have explicit C++ constructors */
#cmakedefine HAVE_EXPLICIT_CONSTR 1
/* Define if you have the getcwd function.  */
#cmakedefine HAVE_GETCWD 1
/* Define if you have the getwd function.  */
#cmakedefine HAVE_GETWD 1
/* Define if you have snprintf */
#cmakedefine HAVE_VSNPRINTF 1
/* Define if you have readlink */
#cmakedefine HAVE_READLINK 1
/* Define if you have usleep */
#cmakedefine HAVE_USLEEP 1
/* Define if you have sleep */
#cmakedefine HAVE_SLEEP 1
/* Define if you have setenv */
#cmakedefine HAVE_SETENV 1
/* Define if you have petpwnam */
#cmakedefine HAVE_GETPWNAM 1
/* Define if you have popen */
#cmakedefine HAVE_POPEN 1
/* Define if you have sysconf */
#cmakedefine HAVE_SYSCONF 1
/* Define if you have siginterrupt (BSD4.3) */
#cmakedefine HAVE_SIGINTERRUPT 1
/* define for boost includes and lib */
//////////////////////// #undef HAVE_BOOST_DYNAMIC_BITSET_HPP
/* define for std:vector includes */
#cmakedefine USE_STDVECBOOL 1
/* Define sizeof(char) */
#define SIZEOF_CHAR 1
/* Define sizeof(short) */
#define SIZEOF_SHORT 2
/* Define sizeof(int) */
#define SIZEOF_INT 4
/* Define sizeof(long) */
#define SIZEOF_LONG 4
/* Define sizeof(void*) */
#define SIZEOF_VOIDP 4
/* Define sizeof(double) */
#define SIZEOF_DOUBLE 8
/* Define if your integer format is big endian */
#cmakedefine WORDS_BIGENDIAN 1
/* Define major version of Singular -- should be set in ../configure.in!!!*/
#define SINGULAR_MAJOR_VERSION 0
/* Define minor version of Singular -- should be set in ../configure.in!!! */
#define SINGULAR_MINOR_VERSION 0
/* Define sub version of Singular -- should be set in ../configure.in!!! */
#define SINGULAR_SUB_VERSION 0
/* Define version as a string */
#define S_VERSION1 ""
/* Define version date as a string */
#define S_VERSION2 ""
/* Define uname identifier as a string */
#define S_UNAME ""
/* Absolute pathname of root directory of Singular source */
#define S_ROOT_DIR ""
/* Define to enable dynamic module code */
#cmakedefine HAVE_DYNAMIC_LOADING 1
/* Define to enable plural */
#cmakedefine HAVE_PLURAL 1
/* Define to enable ratGB/ ratGRING */
#cmakedefine HAVE_RATGRING 1
/* Define to enable shiftbba */
#cmakedefine HAVE_SHIFTBBA 1
/* Define to enable libsvd */
#cmakedefine HAVE_SVD 1
/* CPU type: i[3456]86: */
#cmakedefine SI_CPU_I386 1
/* CPU type: sparc: */
#cmakedefine SI_CPU_SPARC 1
/* CPU type: ppc: */
#cmakedefine SI_CPU_PPC 1
/* CPU type: IA64: */
#cmakedefine SI_CPU_IA64 1
/* CPU type: x86_64: */
#cmakedefine SI_CPU_X86_64 1

/*******************************************************************
 * Defines which are not set by configure
 ******************************************************************/

/* Default value for timer resolution in ticks per second */
/* set to 10 for resolution of tenth of a second, etc */
#define TIMER_RESOLUTION 1

/* Undefine to disable the quote/eval of expressions */
#define SIQ 1

/* Define to enable TCL interface */
#cmakedefine HAVE_TCL  1

/* Undefine to disable Gerhard's and Wilfried's fast and dirty std computations */
#define FAST_AND_DIRTY

/* eigenvalues */
#ifndef HAVE_DYNAMIC_LOADING
#define HAVE_EIGENVAL 1

/* Gauss-Manin system */
#define HAVE_GMS 1
#endif

/* linear algebra extensions from pcv.h/pcv.cc */
#define HAVE_PCV 1

/* procedures to compute groebner bases with the f5 implementation */
/* still testing */
#cmakedefine HAVE_F5 1

/* procedures to compute groebner bases with the f5c implementation */
/* still testing */
#cmakedefine HAVE_F5C 1

/* letterplace gb:*/
#define HAVE_SHIFTBBA 1

/* rings as coefficients */
#define HAVE_RINGS

/* procedures to compute with units */
#define HAVE_UNITS

/* Define to use old mechanismen for saving currRing with procedures
 */
#cmakedefine USE_IILOCALRING


/* Define to use scanner when loading libraries */
#define HAVE_LIBPARSER

/*#define PROFILING*/
#ifdef PROFILING
#define PROFILER ,0,0
#else
#define PROFILER
#endif

/*******************************************************************
 * Evaluate the set defines
 ******************************************************************/
/* FGLM needs factory */
#ifdef HAVE_FACTORY
#define HAVE_FGLM
#endif

/* Define if you want fglm for homogeneous case */
#ifdef HAVE_FGLM
#undef HAVE_FGLM_HOME
#endif

/* Spectrum needs GMP */
#define HAVE_SPECTRUM 1

/* Undefine to disable real time measurments  */
#ifdef HAVE_GETTIMEOFDAY
#define HAVE_RTIMER
#endif

#if SIZEOF_VOIDP == 8
/* SIZEOF_LONG == SIZEOF_VOIDP is guaranteed by configure */
#define ALIGN_8
#define LOG_SIZEOF_LONG  3
#define LOG_SIZEOF_VOIDP 3
#else
#define LOG_SIZEOF_LONG  2
#define LOG_SIZEOF_VOIDP 2
#endif

#ifndef CHAR_BIT
#define CHAR_BIT 8
#endif

#define BIT_SIZEOF_LONG CHAR_BIT*SIZEOF_LONG

#define SINGULAR_PATCHLEVEL 6
#define SINGULAR_VERSION ((SINGULAR_MAJOR_VERSION*1000 + SINGULAR_MINOR_VERSION*100 + SINGULAR_SUB_VERSION*10)+SINGULAR_PATCHLEVEL)

/*******************************************************************
 * Miscellanous Defines
 ******************************************************************/
/* Under HPUX 9, system(...) returns -1 if SIGCHLD does not equal
   SIG_DFL. However, if it stays at SIG_DFL we get zombie processes
   for terminated childs generated by fork. Therefors some special treatment 
   is necessary */
#ifdef HPUX_9
#include <stdlib.h>
#define system hpux9_system
#ifdef __cplusplus
extern "C" {
#endif
int hpux9_system(const char* system);
#ifdef __cplusplus
}
#endif
#endif

#ifndef HAVE_LIBPARSER
#  undef YYLPDEBUG
#else
#  define YYLPDEBUG 1
#endif

#ifndef FALSE
#define FALSE       0
#endif

#ifndef TRUE
#define TRUE        1
#endif

#ifndef NULL
#define NULL        (0)
#endif

#ifndef SEEK_END
#define SEEK_END 2
#endif

#ifndef SEEK_SET
#define SEEK_SET 0
#endif

#define HALT() m2_end(2)

#define memcpy4 memcpy

/* define OLD_RES for res/sres/mres(i,j,k) */
#cmakedefine OLD_RES

/* the maximal ascii length of an int number + 1 = 11 for 32 bit int */
#define MAX_INT_LEN 11
#define MAX_INT_VAL 0x7fffffff

#ifdef DO_PROFILE
/* define to enable explicit profiling of some crucial inline
 * routines and defines  */
#cmakedefine DO_DEEP_PROFILE
#endif

#define buildin_rand 1

/* define to enable assume */
#ifndef HAVE_ASSUME
#cmakedefine HAVE_ASSUME
#endif

/* define LINKAGE to "extern C" if compiling for shared libs */
#ifndef LINKAGE
#if defined(PIC)
#define LINKAGE extern "C"
#else
#define LINKAGE
#endif
#endif


/*******************************************************************
 * DEBUG OPTIONS
 * -- only significant for for compiling without -DSING_NDEBUG
 * -- you better know what your are doing, if you touch this
 ******************************************************************/
#ifndef SING_NDEBUG

/* undefine to enable inline */
#define NO_INLINE

/* undefine to disable assume -- should normally be defined for SING_NDEBUG */
#define HAVE_ASSUME

/* undef PDEBUG to disable checks of polys

 define PDEBUG to
  0 for enabling pTest
  1 plus tests in Level 1 poly routines (operations on monomials)
  2 plus tests in Level 2 poly routines (operations on single exponents)
 -- see also polys.h for more info

 NOTE: you can set the value of PDEBUG on a per-file basis, before
       including mod2.h, provided ! PDEBUG is defined in mod2.h E.g.:

       #define PDEBUG 2

       ...

       makes sure that all poly operations in your file are done with 
       PDEBUG == 2
 To break after an error occured, set a debugger breakpoint on
 dErrorBreak. 
*/
#ifndef PDEBUG
#define PDEBUG 0
#endif

/* define MDEBUG to enable memory checks */
#define MDEBUG 0

#ifdef MDEBUG
/* If ! defined(OM_NDEBUG) and (defined(OM_TRACK) or defined(OM_CHECK)
   then omDebug routines are used for memory allocation/free:

   The omDebug routines are controlled by the values of OM_TRACK, OM_CHECK
   and OM_KEEP.  There meaning is roughly as follows:
   OM_TRACK: strored with address                              : extra space
     0     : no additional info is stored                      : 0
     1     : file:line of location where address was allocated : 1 word
     2     : plus backtrace of stack where adress was allocated: 6 words
     3     : plus size/bin info and front-, and back padding   : 9 words
     4     : plus file:line of location where adress was freed : 10 words
     5     : plus backtrace of stack where adress was allocated: 15 words
   OM_CHECK: checks done
     0     : no checks
     1     : constant-time checks: i.e. addr checks only
     2     : plus linear-time checks and constant related bin check
     3     : plus quadratic-time checks and linear-time related bin checks and
             constant time all memory checks
     4     : and so on
     ==> for OM_CHECK >= 3 it gets rather slow
   OM_KEEP:  determines whether addresses are really freed  (
     0     : addresses are really freed
     1     : addresses are only marked as free and not really freed.

   OM_CHECK, OM_TRACK, and OM_KEEP can be set on a per-file basis 
   (as can OM_NDEBUG),  e.g.:
     #define OM_CHECK 3
     #define OM_TRACK 5
     #define OM_KEEP  1

     #include <omalloc/omalloc.h>
   ensures that all memory allocs/free in this file are done with 
   OM_CHECK==3 and OM_TRACK==5, and that all addresses allocated/freed 
   in this file are only marked as free and never really freed.
 
   To set OM_CHECK, OM_TRACK and OM_KEEP under dynamic scope, set 
   om_Opts.MinCheck, om_Opts.MinTrack to the respectiv values and 
   om_Opts.Keep to the number of addresses which are kept before they are 
   actually freed. E.g.:
     int check=om_Opts.MinCheck, track=om_Opts.MinTrack, keep= m_OPts.Keep;
     om_Opts.MinCheck = 3; om_Opts.MinTrack = 5; omOpts.Keep = LONG_MAX;
     ExternalRoutine();
     om_Opts.MinCheck = check; omOpts.MinTrack = track; omOpts.Keep = keep;
   ensures that all calls omDebug routines  occuring during the computation of
   ExternalRoutine() are done with OM_CHECK==3 and OM_TRACK==5, and 
   calls to omFree only mark addresses as free and not really free them.

   Furthermore, the value of OM_SING_KEEP (resp. om_Opts.Keep) specifies 
   how many addresses are kept before they are actually freed, independently 
   of the value of OM_KEEP.

   Some tips on possible values of OM_TRACK, OM_CHECK, OM_KEEP:
   + To find out about an address that has been freed twice, first locate the
     file(s) where the error occured, and then at the beginning of these files:
       #define OM_CHECK 3
       #define OM_TRACK 5
       #define OM_KEEP  1
       #include <kernel/mod2.h>
       #include <omalloc/omalloc.h>
     Under dynamic scope, do (e.g., from within the debugger):
       om_Opts.MinCheck = 3; om_Opts.MinTrack = 5; omOpts.Keep = LONG_MAX;
   + to find out where "memory corruption" occured, increase value of 
     OM_CHECK - the higher this value is, the more consistency checks are 
     done (However a value > 3 checks the entire memory each time an omalloc 
     routine is used!)
   
   Some more tips on the usage of omalloc:
   + omAlloc*, omRealloc*, omFree*, omCheck* omDebug* omTest* rotuines 
     assume that sizes are > 0 and pointers are != NULL
   + omalloc*, omrealloc*, omfree* omcheck*, omdebug* omtest* routines allow
     NULL pointers and sizes == 0
   + You can safely use any free/realloc routine in combination with any alloc 
     routine (including the debug versions): E.g., an address allocated with
     omAllocBin can be freed with omfree, or an adress allocated with 
     om(Debug)Alloc can be freed with omfree, or omFree, or omFreeSize, etc.
     However, keep in mind that the efficiency decreases from 
     Bin over Size to General routines (i.e., omFreeBin is more efficient than
     omFreeSize which is more efficient than omFree, likewise with the alloc
     routines).
   + if OM_CHECK is undefined or 0, then all omCheck routines do nothing
   + if OM_CHECK and OM_TRACK are both undefined (or 0), or if OM_NDEBUG is 
     defined, then the "real" alloc/realloc/free macros are used, and all 
     omTest, omDebug and omCheck routines are undefined
   + to break after an omError occured within a debugger, 
     set a breakpoint on dErrorBreak
   + to do checks from within the debugger, or to do checks with explicit 
     check level, use omTest routines.
*/

/* by default, store alloc info and file/line where addr was freed */
#ifndef OM_TRACK
#define OM_TRACK 4
#endif
/* only do constant-time memory checks */
#ifndef OM_CHECK
#define OM_CHECK 1
#endif
/* Do actually free memory: 
   (be careful: if this is set, memory is never really freed, 
    but only marked as free) */
#ifndef OM_KEEP
#define OM_KEEP 0
#endif
/* but only after you have freed 1000 more addresses 
   (this is actually independent of the value of OM_KEEP and used
   to initialize om_Opts.Keep) */
#ifndef OM_SING_KEEP
#define OM_SING_KEEP 1000
#endif

#endif /* MDEBUG */


/* undef KDEBUG for check of data during std computations 
 *
 * define KDEBUG to
 * 0 for basic tests
 * 1 for tests in kSpoly 
 * NOTE: You can locally enable tests in kspoly by setting the 
 *       define at the beginning of kspoly.cc
 */
#define KDEBUG 0

/* define LDEBUG checking numbers, undefine otherwise */
#define LDEBUG
/* define RDEBUG checking rings (together with TRACE=9) */
//#define RDEBUG
/* define TEST for non time critical tests, undefine otherwise */
#define TEST

/* #define PAGE_TEST */

/* define YYDEBUG 1 for debugging bison texts, 0 otherwise */
#define YYDEBUG 1

/* Undefine to disable debugging of MP stuff */
#ifdef HAVE_MPSR
#define MPSR_DEBUG
#endif


#ifdef TEST
#ifndef buildin_rand
#define buildin_rand 1
#endif
#endif

/* define SPECTRUM_DEBUG and SPECTRUM_PRINT for debugging the spectrum code */
/* define SPECTRUM_IOSTREAM to use C++ iostream for error messages          */

/* #define SPECTRUM_DEBUG */
/* #define SPECTRUM_PRINT */
#cmakedefine  SPECTRUM_IOSTREAM

#ifdef  SPECTRUM_DEBUG
#define MULTICNT_DEBUG
#define GMPRAT_DEBUG
#define KMATRIX_DEBUG
#define SPLIST_DEBUG
#define NPOLYGON_DEBUG
#define SEMIC_DEBUG
#endif

#ifdef  SPECTRUM_PRINT
#define MULTICNT_PRINT
#define GMPRAT_PRINT
#define KMATRIX_PRINT
#define SPLIST_PRINT
#define NPOLYGON_PRINT
#define SEMIC_PRINT
#endif

#ifdef  SPECTRUM_IOSTREAM
#define MULTICNT_IOSTREAM
#define GMPRAT_IOSTREAM
#define KMATRIX_IOSTREAM
#define SPLIST_IOSTREAM
#define NPOLYGON_IOSTREAM
#define SEMIC_IOSTREAM
#endif


#else /* not SING_NDEBUG **************************************************** */

#define NO_PDEBUG

/* define YYDEBUG 1 for debugging bison texts, 0 otherwise */
#define YYDEBUG 0

#endif /* not SING_NDEBUG */

/*******************************************************************
 *
 * assume(x) -- a handy macro for assumptions
 *
 ******************************************************************/

#ifdef __cplusplus
extern "C" {
#endif
// routine which is used to report the error
// returns 0
extern int dReportError(const char* fmt, ...);
// within a debugger, set a breakpoint on dErrorBreak
// which is called after the error has been reported
extern void dErrorBreak();
#ifdef __cplusplus
}
#endif

#ifndef HAVE_ASSUME
#define assume(x) do {} while (0)
#define r_assume(x) do {} while (0)
#else /* ! HAVE_ASSUME */

#define assume_violation(s,f,l) \
  dReportError("assume violation at %s:%d condition: %s", f,l,s)

#define assume(x)   _assume(x, __FILE__, __LINE__)
#define r_assume(x) _r_assume(x, __FILE__, __LINE__)

#define _assume(x, f, l)                        \
do                                              \
{                                               \
  if (! (x))                                    \
  {                                             \
    assume_violation(#x, f, l);                 \
  }                                             \
}                                               \
while (0)

#define _r_assume(x, f, l)                      \
do                                              \
{                                               \
  if (! (x))                                    \
  {                                             \
    assume_violation(#x, f, l);                 \
    return 0;                                   \
  }                                             \
}                                               \
while (0)
#endif /* HAVE_ASSUME */

/* do have RDEBUG, unless we are doing the very real thing */
#ifdef HAVE_ASSUME
#ifndef RDEBUG
#define RDEBUG 
#endif
#endif

#if SIZEOF_VOIDP == 8
#ifndef OM_CHECK
#define OM_CHECK 0
#endif
#endif

/* If we're not using GNU C, elide __attribute__ */
#ifndef __GNUC__
#  define  __attribute__(x)  /*NOTHING*/
#endif

#endif /* MOD2_H  */
